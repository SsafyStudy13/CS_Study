# Java

</br>

## 프로그램과 운영체제

> ### 프로그램
>
> : 특정 작업을 수행하는 일련의 **명령어들의 모음**

</br>

> ### 운영체제(OS, Operating System)
>
> : 하드웨어와 응용 프로그램 간의 상호작용을 관리, 제어하는 컴퓨터 시스템의 소프트웨어
>
> → 프로그램은 운영체제 위에서 실행됨
>
> - 목적
>
>   : 사용자와 하드웨어 사이의 인터페이스를 제공해 효율적으로 응용 프로그램이 동작하도록 지원
>
>   : 시스템 자원을 효율적으로 관리하여 응용 프로그램이 원활하게 동작할 수 있도록 함
>
> - **커널(Kernel)**
>
>   : 운영체제의 코어 부분
>
>   : 일반적으로 커널에 여러가지 기능(라이브러리, 시스템 프로그램 등)이 추가된 상태를 `운영체제`라고 함
>
> >  `사용자 (User)` ↔ `응용 프로그램 (Application)` ↔ `운영체제 (Operating System)` ↔ `하드웨어 (Hardware)`
>
> - 역할
>
>   1. **자원 관리**
>
>      : 하드웨어 자원을 효율적으로 관리
>
>      : CPU, 메모리, 저장장치, 입출력 장치 등 하드웨어의 자원을 할당하고 관리하여 여러 응용 프로그램이 동시에 실행될 수 있도록 함
>
>   2. **메모리 관리**
>
>      : 운영체제는 컴퓨터 메모리를 효율적으로 관리하여 응용 프로그램이 필요한 메모리 공간을 할당
>
>      : 메모리 할당, 해제, 가상 메모리 관리를 포함
>
>   3. **프로세스 관리**
>
>      : 운영체제는 실행 중인 응용 프로그램의 프로세스를 관리
>
>      : 프로세스의 생성, 실행, 일시정지, 중지 작업 제어
>
>   4. **디스크 및 파일 시스템 관리**
>
>      : 파일의 생성, 삭제, 복사, 이동 등의 작업 처리
>
>   5. **입출력 관리**
>
>      : 입출력 장치와의 통신 지원 및 성능 최적화
>
>   6. **사용자 인터페이스**
>
>      : 텍스트 기반의 터미널 환경(CLI, Command Line Interface)과 그래픽 사용자 환경(GUI, Graphical User Interface)을 통해 사용자가 컴퓨터를 조작할 수 있도록 함
>
>   7. **네트워킹**
>
>      : 컴퓨터 네트워크 관리 및 네트워크 프로토콜을 지원하여 통신을 가능하게 함
>
>      : 인터넷 연결, 데이터 전송, 네트워크 보안 등을 관리
>
>   8. **오류 처리**
>
>      : 프로세스의 비정상 종료, 메모리 오버플로우, 입출력 오류 등을 감지하고 처리
>
>      : 시스템의 안정성과 신뢰성 유지
>
>   9. **시스템 보안**
>
>      : 접근 제처, 사용자 인증, 암호화 등의 기능 제공
>
> - 종류
>
>   - Windows : microsoft에서 개발한 운영체제
>   - macOS : Apple에서 개발한 운영체제, 시스템 안정성과 사용자 편의성에 중점을 둠
>   - Linux : 오픈 소스 운영체제, 서버 시스템 및 임베디드 시스템에서 주로 사용, 안정성과 보안성이 높은 운영체제
>   - UNIX : 다중 사용자 및 다중 작업을 지원하는 운영체제, 서버 환경에서 주로 사용, 안정성과 신뢰성이 높은 운영체

</br>

## 컴퓨터의 자료 표현

- Bit (Binary Digit)

  : 컴퓨터가 값을 저장할 수 있는 최소 단위, 0또는 1로 표현

- Byte

  : **정보의 최소 단위**

  `1 Byte = 8 bits = 256개의 값 표현` 

- 2의 보수

  : bit를 반전시킨 후, 1을 더한 값

</br>

## Java 등장 배경

- **기존 언어의 플랫폼 종속성**

  :  C, C++ 등 이전 프로그래밍 언어의 경우, 컴파일되면 CPU와 운영체제에 종속된 기계어 코드로 변환되기 때문에, 실행하고자 하는 플랫폼(하드웨어 + 운영체제)에 맞는 기계어 프로그램을 생성해야함

  → 플랫폼의 종속성(Platform Dependence)

- **Java의 플랫폼 독립성**

  : C, C++의 한계를 극복하고자 플랫폼에 독립적으로 설계됨

  : Java는 운영체제, CPU 등 플랫폼에 상관없이 JVM(자바 가상 머신)만 있으면 어떤 컴퓨터에서든 동일하게 실행됨

  → `WORA (Write Once Run Anywhere)`

  → Java의 플랫폼 독립성을 가능하게 하는 것

  	1. JVM
  	1. 바이트 코드

</br>

## JVM(Java Virtual Machine, 자바 가상 머신)

> ### 바이트 코드
>
> : 자바 컴파일러가 자바 소스 프로그램을 컴파일한 일종의 기계어
>
> : JVM에 의해 실행되는 바이너리 코드
>
> : CPU에 의해 직접 실행되지 않고, JVM에 의해 인터프리터 방식으로 한 명령씩 해석되어 실행

</br>

>  ### JVM
>
> : 자바 바이트 코드 실행하는 주체
>
> : JVM은 플랫폼에 맞게 서로 다르게 구현되므로 플랫폼 종속적임. 그러나 모든 자바 프로그램에게 동일한 인터페이스와 실행 환경을 제공함
>
> : JVM의 명령어 체계는 유일하므로, 작성된 자바 응용 프로그램은 어떤 회사의 JVM에서든 정상적으로 실행됨

</br>

## Java의 메모리 영역

1. **Static  영역 (Method 영역)**

   : **class와 메서드의 바이트 코드, static 변수, 생성자 등이 저장되는 영역**

   : JVM이 실행되어 class가 로딩될 때 생성

   : static 영역에 있는 것은 어디서든 접근 가능

   : JVM 종료 시(프로그램 종료 시), 메모리에서 해제됨

</br>

2. **Heap 영역**

   : **동적으로 할당된 객체들이 저장되는 영역**, 인스턴스를 생성할 때 사용

   : 참조형 데이터 객체의 실제 데이터가 저장되는 공간

   ​	→ 참조형 데이터 타입이 저장됨

   : stack 영역에서 실제 데이터가 존재하는 heap 영역의 참조값을 가지고 있음

   ​	→ new 키워드로 인스턴스를 생성할 때, heap 영역에는 생성된 객체가 저장되고, stack 영역에는 생성된 객체에 대한 주소값이 저장됨

   : 호출이 종료되어도 삭제되지 않음, **GC에 의해 메모리에서 해제**

   : thread 개수에 상관없이, 단 하나의 영역만 존재

   ​	→ stack의 경우, thread 별로 1개씩 생성

</br>

3. **Stack 영역**

   : **메서드 호출과 관련된 지역 변수, 매개변수 및 메서드 호출에 대한 정보가 저장되는 영역**

   : haep 영역에 생성된 데이터의 참조값이 할당됨

   : **메서드가 호출될 때 메모리에 할당**되고, 메서드가 종료될 때 메모리에서 삭제됨

   : 자료구조 중 **Stack 구조를 따름**

   : 각 thread 마다 자신만의 stack을 가짐

</br>

```java
public class Variable { 

	public static int age = 20; // 클래스 변수(전역 변수)
    
    int height = 60; // 인스턴스 변수(전역 변수)
    
    public static void main(String[] args) { // 매개변수(파라미터)
 		int size = 50; // 지역변수
        
    }
}
```

| 변수 종류                              | 선언 위치   | 설명                                                       | 생성 시기                              | 소멸 시기        | 저장 메모리 |
| -------------------------------------- | ----------- | ---------------------------------------------------------- | -------------------------------------- | ---------------- | ----------- |
| 클래스 변수<br/>(Static Variable)      | 클래스 영역 | static 키워드가 붙고 여러 객체에서 공통으로 사용할 때 사용 | 클래스가 메모리에 올라갈 때            | 프로그램 종료 시 | Static      |
| 인스턴스 변수<br />(Instance Variable) | 클래스 영역 | 클래스 영역에서 static이 아닌 변수                         | 인스턴스가 생성될 때                   | 인스턴스 소멸 시 | Heap        |
| 지역 변수<br />(Local Variable)        | 메서드 영역 | 메서드 내부에서 선언, 초기 값을 지정해야 사용 가능         | 블록 내에서 변수의 선언문이 실행 될 떄 | 블록을 벗어날 때 | Stack       |

</br>

4. **PC 레지스터**

   : 각 스레드가 현재 실행 중인 명령어의 주소를 저장하는 레지스터

   : 스레드가 다음에 실행할 명령어를 가리킴

   : 각 스레드마다 별도의 PC 레지스터를 가짐

5. **Native Method Stack**

   : 네이티브 코드를 실행하는 데 사용되는 스택

   ​	→ 네이티브 메서드는 Java가 아닌 다른 언어로 작성된 코드를 의미

</br>

## Java 응용 프로그램 실행 환경

: 자바 컴파일러는 **자바 소스 프로그램을 컴파일**하여 **바이트 코드를 클래스 파일**에 저장

: 자바 프로그램이 실행되기 위해서, **자바 플랫폼에서 제공하는 다양한 클래스 라이브러리(JDK APIs)가 반드시 필요**

: JVM은 사용자가 작성한 **클래스 파일을 로딩**하여 **바이트 코드를 하나씩 실행**

: 프로그램 실행 중, JDK의 클래스 파일이나 사용자가 작성한 다른 클래스 파일이 필요하면, 그 때 필요한 클래스 파일을 로딩하고 실행함

→ 하지만, 메모리가 충분한 PC에서는 클래스 로딩으로 인한 시간 지연을 줄이기 위해, 사용자 클래스 파일과 필요한 JDK 클래스 파일을 미리 로딩해둠

#### Java 컴파일 과정

```text
자바 소스 코드(.java)
→ 자바 컴파일러(javac)를 사용해 소스 코드 컴파일
→ 바이트 코드(.class, 목적 파일) 생성
→ JVM의 클래스 로더에서 .class 파일을 실행 (이 때 실행에 필요한 자바 클래스 라이브러리인 JDK APIs가 필요)
→ 클래스 로더의 동적 로딩 (필요한 클래스 로딩 및 링크)
→ JVM 메모리에 올라감
→ 실행 엔진에서 메모리에 올라온 바이트 코드를 명령어 단위로 하나씩 실행
```

</br>

> ### C/C++과 Java의 실행 차이
>
> - C / C++
>
>   : 컴파일한 목적 파일을 링크시켜 하나의 실행 파일(exe)을 만들고, 이 파일 하나만 있으면 실행이 가능. 실행 파일은 CPU가 바로 실행
>
> - Java
>
>   : 링크 과정이 없고, JVM이 컴파일된 클래스 파일을 실행함. 컴파일된 클래스 파일들이나 이들을 하나로 압축한 jar 파일 형태로 배포

</br>

## JDK

> ### JRE (Java Runtime Environment)
>
> : 자바 응용 프로그램이 실행될 때 필요한 환경
>
> : 일반 사용자의 경우, 자바 프로그램을 실행시키기 전, JVM을 포함하는 자바 실행 환경만 필요하기 때문에 JRE만 다운받을 수 있음

</br>

> ### JDK
>
> : 배포판을 통해 자바 개발자에게 무료로 배포하는 소프트웨어 도구
>
> : 구성
>
> ​	(1) 표준 클래스 파일을 포함하는 JRE
>
> ​	(2) 개발에 필요한 도구(컴파일러, 클래스 라이브러리, 자바 응용 프로그램 샘플 소스)
>
> ​	(3) 자바 응용 프로그램이 실행될 때 필요한 JVM
> </br>
>
> - 자바의 배포판
>
>   - **JAVA SE (Standard Edition)**
>
>     : 자바 표준 배포판
>
>     : 데스크톱 응용 프로그램과 서버 응용 프로그램의 개발 플랫폼
>
>   - **JAVA ME (Micro Edition)**
>
>     : 모바일용 배포판
>
>     : 휴대전화, PDA, 셋톱박스와 같이 제한된 리소스를 갖는 하드웨어에서 응용 프로그램 개발을 위한 플랫폼
>
>   - **JAVA EE (Enterprise Edition)**
>
>     : 기업용 배포판
>
>     : 자바를 이용한 다중 사용자, 대규모 기업 응용 프로그램 개발을 위한 플랫폼
>
> </br>
>
> - JDK 구성
>
>   ![JDK구성](https://github.com/SsafyStudy13/CS_Study/assets/122426072/630f07aa-b330-4f68-b2f7-f49e549c3b83)
>
>   - `bin` 디렉토리에 포함된 주요 개발 도구
>     - javac : 자바 소스를 바이트 코드로 변환하는 컴파일러
>     - java : 자바 프로그램 실행기, JVM을 작동시켜 자바 프로그램을 실행
>     - javadoc : 자바 소스 프로그램으로부터 HTML 형식의 API 도큐먼트를 생성
>     - jar : 자바 클래스 파일을 압축한 자바 아카이브 파일(JAR) 생성, 관리
>     - jdb : 자바 응용프로그램의 실행 중 오류를 찾는 데 사용하는 디버거
>     - javap : 클래스 파일의 바이트 코드를 소스와 함께 보여주는 디어셈블러
>     - appletviewer : 웹 브라우저 없이 자바 애플릿을 실행하는 유틸리티
>
> </br>
>
> - **JDK 버전**
>
>   > #### :star: Java 8 (2014)
>   >
>   > - 오라클이 java를 인수한 이후 첫번째 LTS 출시 버전
>   > - 32비트를 지원하는 마지막 버전
>   > - `날짜, 시간 API` : LocalDateTime과 같은 api 제공
>   > - `Unsigned Integer` :  unsigned Integer 계산 가능
>   >
>   > - `Lamda` : 이전 익명 클래스의 사용을 람다를 이용하여 더욱 간결하고 직관적인 구현 가능
>   >
>   > - `Stream` : 스트림 API를 통해 컬렉션을 처리하면서 발생하는 (1) 모호함과 반복적인 코드 문제, (2) 멀티코어 활용 어려움 문제 해결
>   >
>   >   → 멀티코어 문제 : 병렬 처리 문제를 의미, 이전에는 컬렉션을 처리할 때 명시적인 스레드 관리를 통해 병렬 처리를 수행해야 했는데, 이는 코드를 복잡하게 만들고 오류를 발생시킬 수 있는 위험이 있었음. 또한 데이터를 안전하게 동기화하고 스레드 간 상태를 관리하는 데 어려움이 있었음
>   >
>   >   → 스트림 API는 내부적으로 멀티스레딩을 사용하여 병렬 처리를 쉽게 수행할 수 있도록 도와줌. 코드의 가독성 향상과 성능 향상에 도움
>
>   </br>
>
>   > #### Java 9 (2017)
>   >
>   > - `컬렉션` : list, set, map을 쉽게 구성할 수 있는 추가 기능 지원
>   > - `Stream` : takeWhile, dropWhile, iterate 메서드의 형태로 추가 기능 지원
>   > - `Optional` : ifPresentOrElse 추가 기능
>   > - `인터페이스` : private method 사용 가능
>
>   </br>
>
>   >  #### Java 10 (2018)
>   >
>   > - `var` : 로컬 변수 유형 추론이라는 var 키워드 도입
>   >
>   >   → 변수 유형을 직접 명시하지 않고 컴파일러가 초기화 값으로부터 유형을 유추
>   >
>   >   → 따라서 초기화 값이 없거나 초기화 값으로 유형을 유추할 수 없는 경우 컴파일 오류 발생
>   >
>   >   → var 키워드를 사용하여 선언된 변수의 유형은 변경할 수 없음
>   >
>   >   → 코드의 가독성을 해치는 경우에는 var 키워드 사용을 피할 것
>   >
>   >   → 메서드 내부의 변수에만 적용 가능
>
>   </br>
>
>   > #### :star: Java 11 (2018)
>   >
>   > - Open JDK와 Oracle JDK 통합
>   > - G1 Garbage Collection이 기본 GC로 설정
>   > - `var` : 람다 표현식에 var 키워드 사용 가능
>
>   </br>
>
>   > #### Java 14 (2020)
>   >
>   > - `Switch 표현식` : 12, 13버전에서 preview였던 스위치 표현식의 표준화
>   >
>   >   → 스위치 표현식이 값을 반환할 수 있고, 표현식에 람다 스타일 구문 사용 가능
>   >
>   > - `NullPointerExceptions` : 어떤 변수가 null인지 정확하게 알려줌
>   >
>   > - `instanceOf` : 이전에는 instanceOf 내부에서 객체 캐스팅이 필수적이었으나, 14버전에서는 캐스팅 과정 삭제 가능 (preview)
>
>   </br>
>
>   > #### Java 15 (2020)
>   >
>   > - `Sealed Class` : 상속 가능한 클래스를 지정할 수 있는 봉인 클래스 제공
>   >
>   >   → 상속 가능한 대상은 상위 클래스 또는 인터페이스 패키지 내에 속해 있어야 함
>   >
>   > - `ZGC` : 스케일링 가능한 낮은 지연의 가비지 컬렉터 추가
>
>   </br>
>
>   > #### :star:Java 17
>   >
>   > - 11 버전 이후 새로운 LTS(장기 지원) 릴리스
>   >
>   > - `recode` : recode class 키워드 사용 가능
>   >
>   >   → 불변 데이터를 간결하게 표현 가능
>   >
>   >   → equals(), hashCode(), toString() 등 메서드 자동 생성
>   >
>   > - `난수 생성 API` : 난수 생성 api 추가
>   >
>   > - `Sealed Class` : 정식 추가
>   >
>   > - `Stream.toList()` : 사용 가능

</br>

## 객체지향 프로그래밍(Object-Oriented Programming, OOP)

- 정의

  : 프로그래밍에서 필요한 **데이터를 추상화**시켜, **상태와 행위를 가진 객체**를 만들고, 그 객체들 간의 **유기적인 상호작용**을 통해 **로직을 구성하는 프로그래밍 방법**

</br>

- 장점

  → **코드의 재사용**

  ​	: 이미 만들어진 클래스를 가져와서 이용할 수도 있고, 상속을 통해 확장시켜 사용할 수도 있음

  → **유지보수**

  ​	: 절차 지향 프로그래밍에서는 수정이 어려운 반면, 객체 지향 프로그래밍에서는 수정 부분이 클래스 내부에 멤버 변수나 메서드로 존재하기 때문에 수정이 쉬움

  → **대형 프로젝트에 적합**

  ​	: 클래스 단위로 모듈화해서 개발할 수 있으므로 업무 분담이 쉬움

</br>

- 단점

  → **느린 처리 속도**

  → **객체가 많아질 수록 용량이 커짐**

  → 설계 시 상대적으로 많은 시간과 노력이 필요

</br>

> #### :star: 객체 지향 프로그래밍 키워드 5가지
>
> 1. **클래스와 인스턴스**
>
>    → 클래스 : 속성(attribute)과 행위(behavior)를 변수와 메서드로 정의한 것, 객체를 만들기 위한 메타 정보, 추상화 과정을 거친 결과
>
>    → 인스턴스(객체) : 클래스에서 정의한 것을 토대로 실제 메모리에 할당된 것
>
> 2. **추상화**
>
>    → **공통**의 속성이나 기능을 묶어 클래스를 설계하는 과정
>
> 3. **캡슐화**
>
>    → 데이터와 데이터를 처리하는 메서드를 하나로 묶어서 외부에서의 접근을 제어하는 것
>
>    → 기능과 특성의 모음을 `클래스`라는 `캡슐`에 분류해서 넣는 것
>
>    → 접근 제어자를 활용해 **정보를 은닉**할 수 있음, 객체 간 상호 의존성을 낮춰 결합도를 줄임
>
>    → 객체 내부의 구체적인 구현에 대해서는 알 필요 없이, 공개된 인터페이스만을 통해 객체와 상호작용할 수 있으므로 **코드의 재사용성과 유지보수성 향상**
>
> 4. **상속**
>
>    → 부모 클래스의 속성과 기능을 그대로 이어 받아 사용할 수 있고, 자식 클래스에서 일부분을 수정하여 다시 사용할 수 있도록 하는 것
>
>    → 다중 상속은 불가능, 상속 관계에서 혼란을 줄 수 있기 때문
>
> 5. **다형성**
>
>    → 하나의 변수명, 함수명이 상황에 따라 다른 의미로 해석될 수 있음
>
>    > ##### Overriding 과 Overloading
>    >
>    > - `Overriding` : 부모클래스의 메서드와 매개변수를 재정의하는 것
>    > - `Overloading` : 같은 이름의 메서드를 여러 개 정의하고, 매개변수의 타입과 개수를 다르게 하여 매개변수에 따라 다르게 호출할 수 있도록 하는 것

</br>

## 객체 지향 설계 5원칙 SOLID

> ##### SRP(Single Responsibility Principle): 단일 책임 원칙
>
> ##### OCP(Open Closed Priciple): 개방 폐쇄 원칙
>
> ##### LSP(Listov Substitution Priciple): 리스코프 치환 원칙
>
> ##### ISP(Interface Segregation Principle): 인터페이스 분리 원칙
>
> ##### DIP(Dependency Inversion Principle): 의존 역전 원칙

</br>

1. **SRP(Single Responsibility Principle) : 단일 책임 원칙**

   : **변경**이 있을 때 연관된 요소들에 영향을 미치지 않아야 함

   : 클래스의 응집도(cohesion)를 높이고, 클래스 간의 의존성을 낮추어 변경에 대한 영향을 최소화할 수 있음

2. **OCP(Open Closed Priciple): 개방 폐쇄 원칙**

   : 확장에는 열려 있고(Open), 수정에는 닫혀 있어야(Closed) 함

   : 기존의 코드를 변경하지 않고도 새로운 기능을 추가할 수 있어야 함

   : 코드의 유연성을 높이고, 코드 변경으로 인한 부작용을 줄일 수 있음

   : 추상화와 다형성이 OCP를 가능하게 하는 주요 메커니즘임 → 객체 지향의 장점 극대화

3. **LSP(Listov Substitution Priciple): 리스코프 치환 원칙**

   : 상위 타입의 객체는 하위 타입의 객체로 치환 가능해야 함

   ​	→ 하위 클래스는 상위 클래스의 기능을 포함해야 하며, 상위 클래스의 대체 가능성을 손상시키지 않아야 함

   : 객체 간의 계층 구조를 안정적으로 유지하여 다형성을 지원

4. **ISP(Interface Segregation Principle): 인터페이스 분리 원칙**

   : 클라이언트는 자신이 사용하지 않는 메서드에 의존하지 않아야 함

   ​	→ 인터페이스는 클라이언트의 요구에 따라 작게 분리되어야 함

   : 인터페이스의 재사용성을 높이고, 결합도를 낮춰 유연한 설계를 가능하게 함

5. **DIP(Dependency Inversion Principle): 의존 역전 원칙**

   : 추상화된 것은 구체적 구현에 의존해서는 안 되며, 추상화에 의존해야 함

   ​	→ 추상화에 의존하면 변경이 쉬워지고, 유연한 설계를 할 수 있음

   ​	→ 인터페이스를 적극 활용할 것

   : 객체 간의 결합도를 줄이고, 의존성을 역전시켜 더 유연하고 확장 가능한 코드를 만듦

</br>

## Garbage Collection(GC)

: 프로그램 실행 중에 JVM의 Heap 영역에서 동적으로 할당했던 메모리 중에서 더 이상 사용되지 않는 객체를 자동으로 찾아서 제거하는 자동 메모리 관리 기법

cf) C에서는 free() 함수를 통해 직접 메모리를 해제해주어야하나, Java에서는 자동으로 처리

→ JVM의 Garbage Collector가 불필요한 메모리를 알아서 정리해주기 때문

</br>

- 단점

  : 메모리가 언제 해제되는지 정확하게 알 수 없기 때문에 제어가 힘듦

  : GC가 동작하는 동안에는 다른 동작을 멈추기 때문에 오버헤드가 발생되는 문제점

  ​	→ STW (Stop The World)

</br>

- 도달성(Reachability)

  : 객체에 레퍼런스가 있는 경우 → Reachable

  : 객체가 참조되고 있지 않은 경우, GC의 대상인 경우 → Unreachable

</br>

- Mark-Sweep

  : unreachable 객체들을 삭제하는 내부 알고리즘,  garbage collection 동작의 과정

  1. `Mark` → Root Space로부터 그래프 순회를 통해 연결된 객체들을 찾아내어 어떤 객체를 참조하고 있는지 마킹함
  2. `Sweep` → unreachable 객체들을 heap에서 제거
  3. `Compact` → sweep 이후 분산된 객체들을 heap의 시작 주소로 모아 메모리가 할당된 부분과 그렇지 않은 부분으로 압축 (GC 종류에 따라 하지 않는 경우도 有)

</br>

## Class와 Interface

> ### Class
>
> 1. 일반 클래스
>
> 2. 추상 클래스
>
>    : 클래스 내 추상 메서드가 존재하거나 abstract로 클래스가 정의된 경우
>
>    : 추상 클래스를 상속받아 기능을 수정, 추가할 수 있고, 확장이 용이함
>
>    : 구현을 포함할 수 있음
>
>    : `extends` 활용하여 상속. 다중 상속 불가, 상속을 통해 다형성 구현

</br>

> ### Interface
>
> : 모든 메서드가 추상 메서드인 경우
>
> : 추상 메서드와 상수만 포함할 수 있기 때문에, 추상 메서드의 구현이 강제적임
>
> : 인터페이스의 변경이 구현 클래스에 미치는 영향을 최소화할 수 있음
>
> : `implements` 활용하여 상속, 다중 상속 가능, 구현을 통해 다형성 구현

</br>

## 접근 제어자

: 클래스, 멤버 변수, 멤버 메서드 등의 선언부에서 **접근 허용 범위를 지정**

</br>

> ### 클래스 접근 제어자
>
> 1. public
>
>    : 패키지에 상관없이 모든 클래스에서 해당 클래스에 접근이 가능
>
> 2. default (생략)
>
>    : 클래스 앞에 접근 제어자가 없으면 default 클래스임
>
>    : 같은 패키지 안의 클래스에서만 접근 가능

</br>

> ### 클래스 멤버의 접근 제어자
>
> 1. public
>
>    : 패키지에 상관없이 모든 클래스에서 접근 가능
>
> 2. private
>
>    : 같은 클래스 안에 있는 멤버들만 접근 가능
>
> 3. protected
>
>    : 같은 패키지 안의 모든 클래스와, 다른 패키지의 자식 클래스에서 접근 가능
>
> 4. default
>
>    : 접근 지정자가 없는 경우 default 멤버임
>
>    : 같은 패키지 안의 클래스에서만 접근 가능
>
> - 공개 범위
>
> ```text
> public > protected > default > private
> ```
>
> |           | 클래스 내부 | 동일 패키지 | (다른 패키지 내의)<br />하위 클래스 | 다른 패키지 |
> | --------- | ----------- | ----------- | ----------------------------------- | ----------- |
> | private   | O           |             |                                     |             |
> | default   | O           | O           |                                     |             |
> | protected | O           | O           | O                                   |             |
> | public    | O           | O           | O                                   | O           |

</br>

## Getter와 Setter

: private으로 접근 제어자를 설정해 멤버 변수에 직접 접근을 막은 후, public으로 getter와 setter 메서드를 만들어서 접근하는 방식을 통상적으로 사용

→ 메서드를 통해 접근하기 때문에, 올바르지 않은 입력에 대해 메서드 안에서 사전에 제한할 수 있기 때문에 해당 방식 채택

</br>

## Java의 예외 처리 방법

: 안정적인 프로그램을 위한 필수적 방법

: 프로세스가 강제적으로 종료되지 않고, 예외 상황이 발생해도 운영이 가능하도록 핸들링 할 수 있음

1. try-catch

   `try` : 예외가 발생할 수 있는 코드 작성

   `catch` : 발생한 예외를 처리하는 코드 작성

   `finally` : 예외 발생 여부에 관계없이 무조건 실행되어야하는 코드 작성

2. throw 와 throws

   `throw` : 예외를 발생시킬 때 사용하는 키워드

   `throws` : 메서드 선언부에서 해당 메서드가 어떤 예외를 던질 수 있는지 명시, 호출하는 쪽에서 해당 예외를 처리하도록 요구

</br>

→ 예외 복구, 예외 처리 회피, 예외 전환으로 활용

- 예외 복구

  : 예외 상황을 파악해서 정상 상태로 돌려놓는 방법

  : 네트워크 연결과 같은 로직에서 사용

- 예외 처리 회피

  : 예외처리를 직접 담당하지 않고 호출한 쪽으로 던져 회피하는 방법

- 예외 전환

  : 예외를 발생시켜 던지지만, 이때 적절한 예외로 필터링해서 넘기는 방법

</br>

## Java의 Exception

: 자바에서는 예외를 처리하기 위해 `java.lang.Exception` 클래스를 사용

: 해당 클래스는 모든 예외의 최상위 클래스이며, 크레 `일반예외(Exception)`과 `실행예외(RuntimeException)`으로 나뉨

- 일반 예외 (컴파일 체크 예외) : 자바 소스를 컴파일 하는 과정에서 예외 처리 코드가 필요한지 검사, 예외 처리 코드가 없다면 컴파일 오류 발생

  ex) `IOException` `SQLException`

- 실행 예외 : 컴파일 과정에서 예외 코드를 검사하지 않는 예외, 일반 예외와 달리 Exception을 상속받은 `java.lang.RuntimeException`을 상속 받음

  ex) `NullPointerException` `ArrayIndexOutOfBoundsException` `ArithmeticException`

> #### IOException
>
> : 입출력에서 읽을 파일이 없거나, 데이터 형식이 잘못되거나, 네트워크 문제로 데이터 송수신이 정상적으로 이루어지지 않을 때 발생하는 예외

> #### NullPointerException (NPE)
>
> : null 상태인 객체에 접근했을 때 발생하는 예외

> #### ArrayIndexOutOfBoundsException
>
> : 할당된 배열의 인덱스 범위를 초과해서 사용할 경우 발생하는 예외

> #### ClassCastException
>
> : 상위 클래스를 하위 클래스로 형변환하려고 할 때, 실제 객체가 형변환하려는 클래스의 인스턴스가 아닌 경우에 발생하는 예외

</br>

## String을 불변 객체로 설정한 이유

- 불변 객체 : 객체가 생성된 후 내부 상태가 변하지 않고 계속 유지되는 객체

  → 변수에 객체가 한 번 할당되면, 해당 객체의 참조를 변경하거나 내부 상태를 수정할 수 없음

1. `스레드 안정성` : 여러 스레드가 동시에 문자열에 접근하더라도 변경할 수 없기 때문에 동기화 문제를 해결하며 스레드 안정성을 보장함
2. `보안성` : 원본 문자열을 수정하는 메서드를 호출하더라도 원본 문자열에는 영향을 주지 않기 때문에 보안적 측면에서 중요함
3. `캐싱` : 동일한 내용의 문자열이 여러 번 사용될 경우 캐싱될 수 있기 때문에 메모리 사용량을 줄이고 성능을 향상시킬 수 있음
4. `데이터 구조의 안정성` : 불면 문자열은 해시맵 등의 데이터 자료 구조에서 키로 사용될 수 있고, 이는 해시맵의 안정성을 보장함
5. `최적화` : 불변 문자열은 자주 사용되는 문자열을 재사용하여 메모리 사용량을 최적화할 수 있고, 문자열 연산의 성능을 향상시킴

</br>

