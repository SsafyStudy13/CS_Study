## 1. 가비지 컬렉션에 대해 설명해주세요. (유지연)
`가비지 컬렉션`이란, JVM의 Heap 영역에서 사용하지 않는 객체를 삭제하는 과정을 말합니다.  
GC의 Root들로 부터 유효한 참조가 존재하지 않는 Unreachable한 객체들을 수거합니다. 여기서 Root란 Stack 영역의 데이터, Method 영역의 static 데이터, JNI에 의해 생성된 객체들을 의미합니다.  
이때, `마크-앤-스윕(Mark And Sweep)` 방식을 통해 Root부터 탐색해 닿을 수 없는 객체를 식별해 제거한 뒤, Heap의 분산된 데이터들을 다시 메모리 앞쪽부터 채워나가는 과정을 거칩니다.  
또한 JVM의 Heap 설계 전제에 따라, Heap은 Young, Old, 그리고 영구 영역으로 설계되어 있으며 Young 영역에서는 Minor GC, Old 영역에서는 Major GC가 발생합니다.  
새로운 객체는 Young 영역에 할당되고, Young 영역에서 Reachable한 상태를 오래 유지한 객체는 Old 영역에 존재하게 됩니다.  
처음 생성된 객체는 Young 영역의 Eden에 위치하게되고, Eden이 꽉차면 Minor GC가 발생하게 됩니다. 이때도 Reachable한 객체는 S0 영역과 S1 영역 이동을 반복하며, 과정중에 age가 증가하게 되는데, 임계값 이상 된 객체는 Old 영역으로 이동하게 됩니다.  
C/C++와 달리 Java는 직접 메모리를 관리하지 않아도 된다는 장점이 있지만, 원하는 시간에 GC를 호출할 수 없어 발생 시점이 불명확하다는 단점이 존재합니다.  
또한 Minor, Major GC가 진행되는 동안은 GC 관련 스레드를 제외한 모든 스레들이 멈추고 이에 따른 오버헤드가 발생할 수 있다는 단점이 있습니다.  
- [Java Garbage Collection Basics (oracle.com)](https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html)
## 2. 객체지향 프로그래밍이 뭔가요? (유지연)
`객체지향 프로그래밍`이란, *컴퓨터 프로그램을 명령어들의 목록이 아닌*, **상태와 행동을 갖는 객체**로 **데이터를 추상화** 시킨 뒤, 이들 간의 **상호작용**으로 **파악**하고자 하는 **프로그래밍 패러다임**을 말합니다.  
객체지향적인 프로그래밍은 `추상화`, `상속`, `다형성`, `캡슐화`(`A PIE` 또는 `캡상추다`)라는 특징을 갖고 있습니다.  
`추상화`란, 현실의 `객체`의 **공통적인 특성**과 **행동**을 파악해 **`인터페이스`를 구성**하고, 실질적인 **구현**은 이를 구현하는 **`클래스`** 에서 이뤄지도록 하는 것을 말합니다.  
`상속`이란, 부모 클래스의 자산, 즉 멤버를 기반으로 자식 클래스를 작성하는 것을 말합니다. 기존에 존재하는 클래스의 멤버를 물려받아 코드 재사용이 가능하고 부모의 코드만 바꿔주어도 모든 자식에게 전파되기 때문에 유지 보수가 편리하다는 장점이 있습니다.  
`다형성`이란, 클래스 간 상속 관계가 있을 때 `조상 클래스 타입`으로 `자식 클래스 객체`를 **참조할 수 있다**는 성질을 말합니다. 이를 통해 조상 클래스를 인수로 받게되면 인수의 타입에 따라 메서드를 만들 필요가 없어지게 된다는 장점이 있습니다.  
`캡슐화`란,  `클래스의 속성과 기능`을 **외부로부터 접근을 차단**해 **보호**하고, 필요한 부분만 노출하는 것을 말합니다.  
객체지향 프로그래밍을 적용하면 컴포넌트의 재사용성이 높아지고, 기능의 추가/수정/삭제가 용이하다는 `장점`이 있습니다. 다만, 이를 위한 설계에 많은 시간이 소요되고 객체를 위해 부가적으로 메모리를 쓰거나 처리가 필요하기 때문에 절차지향 프로그래밍보다 성능이 떨어진다는 `단점`이 존재합니다.  
## 3. 오버라이딩과 오버로딩의 차이점을 설명해주세요. (유지연)
두 가지 모두 같은 이름의 메서드가 이미 존재하는 상황에서, 똑같은 이름으로 메서드를 또 다시 선언하는 것을 말합니다.  
다만, `오버로딩`은 상위 클래스 또는 같은 클래스 내의 메서드와 이름은 동일하지만, `매개변수`만 다른 메서드를 선언하는 것을 의미합니다.  
반면, `오버라이딩`은 상위 클래스의 메서드를 하위 클래스에서 필요에 맞게 내부 행동을 재정의하는 것을 의미해, `이름`, `반환 타입`, `매개변수` 모두 동일하게 선언하는 것을 말합니다.  
또한 부모의 메서드가 `final`이거나 `static`일 경우 재정의가 불가능하며, 재정의한 메서드의 접근 제한자는 부모의 것과 같거나 더 범위가 넓어야 합니다.  
추가로 `오버로딩한 메서드`는 `런타임 시간`에 메서드를 호출한 인스턴스의 타입에 따라 결정되는 반면, `오버라이딩한 메서드`는 `컴파일 시간`에 호출하게 될 메서드가 결정됩니다.  
## 4. 자바의 메모리 영역에 대해 설명해주세요. (김은솔)
자바 애플리케이션 실행시 사용되는 JVM 메모리 영역은 크게 `메서드 영역`, `힙 영역`, `스택 영역`, `PC 레지스터`, `네이티브 메서드 스택`으로 구성되어 있습니다.  
이때 `메서드 영역`, `힙 영역`은 모든 스레드가 공유하고, 나머지 `스택 영역`, `PC 레지스터`, `네이티브 메서드 스택`은 각 스레드 별로 생성 됩니다.  
`메서드 영역`은 클래스 이름, 직속 부모 클래스 이름, 메서드 및 변수와 같은 모든 `클래스 레벨 정보`들이 저장됩니다.  
`힙 영역`은 모든 `동적으로 생성된 객체,즉 인스턴스`의 정보가 저장됩니다.  
`스택 영역`은 `스택 프레임`이라 부르는 블록들로 구성된 공간으로, 메서드 호출 시 이를 위한 `스택 프레임`이 생성되어 메서드 내부에서 사용되는 로컬 변수의 원시 타입 값, 객체에 대한 참조가 저장됩니다.  
`PC 레지스터`는 스레드 시작시 생성되며, 현재 실행중인 JVM 명령어 주소를 저장합니다.  
`네이티브 메서드 스택`은 다른 언어로 작성 된 `네이티브 메서드`를 실행하기 위해 관련 정보를 저장하는 영역으로, 네이티브 메서드가 실행되면 스레드는 자바 스택에서 네이티브 메서드 스택으로 전환하게 됩니다.  

## 5. SOLID 원칙에 대해 설명해주세요. (김은솔)
SOLID 원칙이란, 객체 지향적 설계 원칙 다섯 가지를 의미합니다.  
S는 `단일 책임 원칙`을 의미하며, 클래스는 하나의 책임을 가져야 하고 변경할 때도 단 하나의 이유로 변경해야함을 의미합니다. 즉, 한 객체 내부에서 여러 로직들을 연결시키지 않고, 여러 클래스로 분리해야함을 의미합니다.  
O는 `개방-폐쇄 원칙`을 의미하며, 확장에 열려있어야 하고 변경에는 닫혀 있어야 함을 의미합니다. 즉, 클래스나 함수와 같은 개체들이 기존의 엔티티를 수정하지 않고 필요한 기능을 확장해 새 엔티티에 적용해야 함을 의미합니다.  
L는 `리스코프 치환 원칙`을 의미하며, 상위 타입의 객체를 하위 타입의 객체로 치환하여도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 함을 의미합니다. 즉, 클라이언트가 특정 서브 클래스의 세부 구현사항에 대해 걱정할 필요 없이 다형성과 추상화를 활용할 수 있어야 함을 의미합니다.  
I는 `인터페이스 분리 원칙`을 의미하며, 인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리해야함을 의미합니다. 즉, 인터페이스를 사용하는 클래스가 사용하지 않는 메서드에 의존하도록 강요해서는 안됨을 의미합니다.  
D는 `의존 역전 원칙`을 의미하며, 고수준의 모듈이 저수준의 모듈의 `구현`에 의존해선 안됨을 의미합니다. 즉, 예를 들어 자동차를 운전한다면, 내부의 엔진이나 타이어가 바뀌었다고 자동차의 코드까지 바뀌진 않아야함을 의미합니다. 이를 해결하기 위해서는 저수준 모듈인 엔진, 타이어 역시 추상화되어 있어야 합니다.  
## 6. 자바의 컴파일 과정에 대해 설명해주세요. (김은솔)
자바 언어로 작성된 소스코드(`.java` 파일)은 먼저 자바 컴파일러에 의해 컴파일 되어 `바이트코드` 라는 JVM에서 이해할 수 있는 코드로 컴파일되며 각 클래스들의 내용이 `.class` 파일에 저장되게 됩니다.
이후 JVM에서 이들을 `클래스로더`로 읽어 대응되는 바이너리 데이터를 `메서드 영역`에, 클래스의 이름, 변수와 메서드 정보같은 관련 정보를 저장하는 `로딩`, class 파일을 검증하고 정적 변수에 필요한 메모리를 할당하는 등의 작업인 `링킹`, 모든 정적 변수들을 코드에 정의된 값으로 할당하는 `초기화`와 같은 작업을 거칩니다.  
이후 `실행 엔진`을 통해 바이트 코드로 변환된 `.class` 파일을 한 줄씩 읽고 메모리 영역에 존재하는 데이터와 정보를 이용해 명령어를 실행하게 됩니다.  
이때, 이러한 인터프리팅 방식의 효율을 높이기 위해, `JIT 컴파일러`를 사용해 반복되는 메서드 호출에 대해 런타임에 바이트 코드를 네이티브 코드로 컴파일한 뒤 직접 네이티브 코드를 제공하게 됩니다.  
따라서 한 메서드를 여러 번 해석하지 않아 효율성을 향상시킬 수 있습니다.  
## 7. 클래스와 인터페이스의 차이점에 대해 설명해주세요. (송채은)
인터페이스는 인스턴스화 될 수 없지만, 클래스는 인스턴스화를 통해 객체를 생성할 수 있습니다. 따라서 클래스는 생성자를 포함할 수 있지만, 인터페이스는 불가능합니다.  
인터페이스에는 함수의 선언부만 필요하지만, 클래스에는 함수 동작에 대한 구현도 포함되어야 합니다. 다만, jdk 1.8부터는 default 메서드를 통해 구현부가 존재하는 메서드를 선언할 수 있습니다.  
인터페이스 간에는 다중 상속이 가능하지만, 클래스 간에는 단일 상속만 가능합니다. 또한, 클래스는 인터페이스와 클래스 모두 상속할 수 있지만 인터페이스는 인터페이스만 상속할 수 있습니다.  
인터페이스의 멤버 변수는 `public static final`이어야 하며, 메서드는 `public abstract`여야 하지만, 클래스에는 이러한 제한이 없습니다.  
- [Differences between Interface and Class in Java - GeeksforGeeks](https://www.geeksforgeeks.org/differences-between-interface-and-class-in-java/)
## 8. 접근 제어자란 무엇인지, 어떤 것들이 있는지 설명해주세요. (송채은)
`접근 제어자`란, 프로그램의 요소에 대해 이를 외부에서 사용할 수 있는지를 설정하는 제한자를 말합니다.  
`public`, `protected`, `package`, `private` 으로 나뉘며, 모두 생성자와 멤버에 사용할 수 있습니다. 다만, 클래스에는 public과 package 제한자만 사용할 수 있습니다.  
`public`은 `어디서든 접근`할 수 있고, `protected`는 `같은 패키지 내에 존재하거나, 자식 클래스`에서 까지만 접근할 수 있습니다.  
`package` 또는 `default` 제한자는 `같은 패키지 내의 클래스`까지만 접근할 수 있고, `private`의 경우 `같은 클래스 내부`에서만 접근할 수 있습니다.  
이러한 접근 제어자를 통해, 지켜야 하는 변수를 외부에서 직접 접근하지 못하도록 보호할 수 있습니다.

## 9. 자바의 예외 처리 방법에 대해 설명해주세요. (송채은)
`try-catch`문을 통해 직접 예외를 처리하거나, `throw` 문을 통해 호출 스택상 위에 존재하는 메서드에 예외를 넘길 수 있습니다.  
`try` 블록 으로 예외가 발생할 것 같은 구간을 감싸고, 던져진 예외는 이를 처리할 수 있는 `catch` 블록에 넘겨져 처리됩니다. `catch` 블록은 여러 개 사용가능한데, 선언된 순서대로 검사되며 `catch` 블록 내부에서 다시 `throw`문으로 예외를 던질 수도 있습니다.  
추가로 예외가 발생하든 안하는 항상 실행되는 `finally` 블록도 쓸 수 있습니다.  
만약 `throw` 문을 통해 넘기기로 했다면, 런타임 시스템에서 호출 스택에서 예외를 처리할 수 있는 코드 블록이 포함 되어있는 메서드를 찾습니다.  
콜 스택에서 예외가 발생한 메서드부터 메서드가 호출된 역순으로 찾아가며, 던져진 예외 객체와 코드 블럭에서 처리할 수 있는 예외 객체가 일치하는 구간을 찾으면 이를 전달합니다.  
만약 그러지 못하면 디폴트 예외 핸들러로 이를 넘기게 되고, 핸들러는 예외 정보를 출력하고 프로그램을 비정상 종료하게 됩니다.  
- [Exceptions in Java - GeeksforGeeks](https://www.geeksforgeeks.org/exceptions-in-java/)
- [Java Exceptions (Try...Catch) (w3schools.com)](https://www.w3schools.com/java/java_try_catch.asp)
## 10. 자바의 Exception 종류에 대해 설명해주세요. (박규영)
`CheckedException`, `UncheckedException`, `Error`가 있습니다.
**`체크드익셉션`** 은 `IOException` 같이 **컴파일**시 **검사 가능**한 예외이고, **`언체크드익셉션`** 의 경우 0으로 나눌 경우 발생하는 `산술연산익셉션`이나 `어레이인덱스아웃오브바운드익셉션` 같이 **런타임**에 **발생**하는 오류입니다.  
추가로 Spring JPA에서 `@Transactional`을 사용할 경우, 기본적으로 `체크드익셉션`이 발생할 경우 트랜잭션이 롤백되지 않고, `언체크드익셉션`이 발생할 경우 롤백되게 됩니다.  
**`에러`** 는 Java 프로그램 **외부에서 발생한 예외**로, 디스크 고장과 같은 외부의 요인으로 프로그램이 제대로 동작하지 못한 경우 발생합니다.  
`에러`는 **프로세스에 영향**을 주고, `익셉션`은 **스레드에 영향**을 줍니다.  
이외에도 사용자 정의 익셉션이 있는데, 결국 체크드익셉션이 되는 Exception 또는 언체크드익셉션이 되는 RuntimeException을 상속해야 합니다.  
## 11. 자바에서 왜 String을 불변 객체로 설정했는지 설명해주세요. (박규영)
**성능**, **동기화**, **보안**을 이유로 불변 객체로 만든 것으로 알고 있습니다.  
`new` 키워드를 통해 생성 시 **Java Heap**에 저장되지만, `Literal`을 이용해 생성시 Java Heap 내에 존재한 **문자열 상수 풀(String Constant Pool)** 에 저장되기 됩니다.  
이를 통해 같은 문자열 리터럴을 참조하는 String 객체들은 **동일한 리터럴**을 가르켜도 **불변 객체**이므로 문제가 발생하지 않아 **Java Heap 공간을 절약**할 수 있습니다.  
또한 값이 바뀔 일이 없으므로 `Thread-Safe`하다는 장점이 있습니다. 다른 Thread에서 문자열 값을 변경해도, 문자열 풀에 새 문자열이 생성 되므로 안전합니다.  
또한, 특정 함수에 문자열 값을 넘길때 처음 보안 검사를 해도, 해당 함수를 호출한 클라이언트는 여전히 변수로 넘긴 문자열의 참조값을 갖고 있으므로 보안 검사 - 실제 작업이 실행되는 시간 사이에 참조를 통해 값을 변경한다면 공격의 위험이 발생할 수 있습니다. 따라서 String을 불변 객체로 만드므로써 보안 면에서도 이점을 얻을 수 있습니다.  
## 12. 알고있는 자바 JDK 버전과 각 버전 별 변경 사항에 대해 설명해주세요. (박규영)
**Java 7**에서는 `switch` 문에서 `String`을 사용할 수 있게 되었고, `try-with-resources` 문법이 추가되어 `AutoCloseable` 인터페이스를 구현하는 자원을 자동으로 반납할 수 있게 되었습니다. 그리고 제네릭 클래스 객체를 생성할 때, 타입을 생략하는게 가능해졌습니다.  
**Java 8**에서는 이름과 반환 타입 없이 구현부를 선언하는 익명 메서드 생성 문법인`lambda`가 추가되었고, 이를 활용해 배열과 컬렉션을 함수형으로 처리할 수 있게해주는 `Stream API`가 추가되었습니다. 또한 `interface`에 `default method`가 추가 되었으며, `NPE`을 간편하게 대응할 수 있는 `Optional 구조체`, 하나의 특정 메서드만 호출하는 `lambda식`을 축약해주는 `메서드 레퍼런스`가 추가되었습니다.  
**Java 9**에서는 외부에서 호출할 수 있는 API를 갖고있는 `모듈`을 생성할 수 있는 시스템인 `jigsaw`가 등장 했습니다. 클라이언트는 해당 모듈에서 *API 작성자가 노출한 API 외에는* **접근 불가능**합니다. 또한, interface에서 `private method`가 사용 가능해졌습니다.  
**Java 14**에서는 switch 표현식에서 화살표 함수, 즉 람다 형태로 구현하고 값을 반환할 수 있는 개선된 swtich문이 표준으로 자리잡았고, 불변 데이터 객체 역할을 하는 `Record` 클래스의 프리뷰가 등장했습니다.  
**Java 17**에서는 클래스를 상속할 수 있는 클래스 타입을 제한하는 `sealed`, `permit` 키워드와, switch문에서 패턴 매칭을 할 수 있는 기능의 프리뷰가 등장했습니다.  
- [Java 8부터 16까지의 신규 기능들 정리 (oracle.com)](https://blogs.oracle.com/javakr/post/java8-16)