# Java

### 1. 가비지 컬렉션에 대해 설명해주세요. (유지연)

[https://mangkyu.tistory.com/118](https://mangkyu.tistory.com/118)

[https://jellili.tistory.com/60](https://jellili.tistory.com/60)

- 가비지
    - Heap 영역에서 동적으로 할당했던 메모리 중 필요 없게 된 메모리 객체
- 가비지 판단 방법
    - Reachable : 객체가 참조되고 있는 상태
    - Unreachable : 객체가 참조되고 있지 않은 상태 (GC의 대상)

![Untitled](Java%20f02d301fc1934a619033c2a3f7fe455b/Untitled.png)

- 가비지 컬렉션
    - 자바의 메모리 관리 방법 중 하나로 JVM의 **Heap 영역에서 동적으로 할당했던 메모리** 중 필요 없게 된 메모리 객체를 모아 **주기적으로 제거**하는 프로세스
- **객체**들은 실질적으로 **Heap 영역**에만 생성되고 **Method Area 영역과 Stack**에서는 Heap 영역에 생성된 **객체의 주소만을 참조**
- Heap 영역에 객체들이 메서드가 끝나는 등의 특정 이벤트들로 인하여 Heap 영역 객체의 메모리 주소를 가지고 있는 참조 변수가 삭제되는 현상 발생 → 어디에서도 참조하고 있지 않은 객체 발생 → 가비지 컬렉션이 제거
- Heap
    - **Young 영역**
        - 새롭게 생성된 객체가 할당되는 영역
        - 대부분의 객체가 금방 Unreachable 상태가 되기 때문에 많은 객체가 Young 영역에 생성되었다가 사라짐
        - Young 영역에 대한 가비지 컬렉션을 Minor GC라고 함
        - Young = Eden + 2 * Survivor
            - Eden : 새로 생성된 객체가 할당되는 영역
            - Survivor : 최소 1번의 GC 이상 살아남은 객체가 존재하는 영역
        - **Minor GC의 동작 과정**
            1. 새로 생성된 객체가 Eden 영역에 할당
            2. 객체가 계속 생성되어 Eden 영역이 꽉 참
            3. Minor GC 실행
                1. Eden 영역에서 사용되지 않는 객체의 메모리 해제
                2. Eden 영역에서 살아남은 객체는 1개의 Survivor 영역으로 이동
            4. 1-2번 과정 반복되다가 Survivor 영역이 가득 참
            5. Survivor 영역의 살아남은 객체를 다른 Survivior 영역으로 이동 (1개의 Survivor 영역은 반드시 빈 상태가 됨)
            6. 이러한 과정을 반복하여 살아남은 객체는 Old 영역으로 이동 (Promotion)
                1. 객체의 생존 횟수를 카운트하기 위해 age를 Object Header에 기록
                2. age의 임계값(31)이 차면 Old 영역으로 이동
    - **Old 영역**
        - Young 영역에서 Reachable 상태를 유지하여 살아남은 객체가 복사되는 영역
        - Young 영역보다 크게 할당되며 영역의 크기가 큰 만큼 가비지가 적게 발생
            - 큰 객체들은 Young 영역이 아니라 바로 Old 영역에 할당됨
        - Old 영역에 대한 가비지 컬렉션을 Major GC라고 함
        - **Major GC의 동작 과정**
            1. age 임계값이 찬 객체가 Old 영역에 Promotion 됨
            2. Promotion 된 객체가 쌓여서 Old 영역의 메모리가 부족해지면
            3. Major GC 발생
                1. Minor GC 실행시간은 0.5초 ~ 1초
                2. Major GC 실행시간은 10배 이상 → STW 발생
    - Minor GC + Major GC 동시에 처리하는 Full GC도 있음
    - Old 영역에 있는 객체가 Young 영역의 객체를 참조하는 경우도 존재
        - Old 영역에는 512bytes의 덩어리로 되어있는 카드 테이블이 존재
    - 카드 테이블
        - Old 영역에 있는 객체가 Young 영역의 객체를 참조할 때마다 그에 대한 정보가 표시
        - Young 영역에서 GC가 실행될 때 모든 Old 영역에 존재하는 객체를 검사하여 참조되지 않는 Young 영역의 객체를 식별하는 것은 비효율적이기에 생김
        - Young 영역에서 가비지 컬렉션이 진행될 때 카드 테이블만 조회하여 GC 대상인지 식별
- 가비지 컬렉션의 동작 방식
    - **Stop The World**
        - JVM이 GC 실행을 위해 애플리케이션의 실행을 멈추는 작업
        - GC가 실행될 때는 GC를 실행하는 스레드를 제외한 모든 스레드들의 작업이 중단됨
    - **Mark and Sweep**
        - Makr : 사용되는 메모리와 사용되지 않는 메모리를 식별하는 작업
        - Sweep : Mark 단계에서 사용되지 않음으로 식별된 메모리를 해제하는 작업
    - **Stop The World → Reachable 객체를 스캔 → 어떤 객체를 참고하고 있는지 탐색 → 사용되고 있는 메모리 식별 (Mark) → Mark가 되지 않은 객체들을 메모리에서 제거 (Sweep)**

### 2. 객체지향 프로그래밍이 뭔가요? (유지연)

[https://velog.io/@zzangzzong/객체지향-프로그래밍Object-Oriented-Programming](https://velog.io/@zzangzzong/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8DObject-Oriented-Programming)[https://jongminfire.dev/객체지향-프로그래밍이란](https://jongminfire.dev/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%B4%EB%9E%80)

- 절차지향 프로그래밍
    - 프로그램 전체가 유기적으로 연결되도록 만드는 프로그래밍 방법
    - 순차적인 처리가 중요
    - 장점 : 실행속도가 빠름
    - 단점 : 유지보수가 어려움
    - 언어 : C언어
- 객체지향 프로그래밍
    - 프로그래밍에서 필요한 **데이터를 추상화** 시켜 **상태와 행위를 가진 객체로** 만들고 **객체들 간의 상호작용**을 통해 로직을 구성하는 프로그래밍 방법
    - 언어 : C++, C#, Java, Python, JavaScript, Ruby, Swift
- 객체
    - 프로그램에서 사용되는 데이터 또는 식별자에 의해 참조되는 공간
    - **값을 저장할 변수와 작업을 수행할 메서드**를 서로 연관된 것들끼리 묶어서 만든 것
- 특징
    - **추상화 (Abstraction)**
        - 객체에서 **공통된 속성과 행위를 추출**하는 것
        - **불필요한 정보는 숨기고** 중요한 정보만을 표현함으로써 프로그램을 간단하게 만드는 것
        - 속성 위주가 아닌 동작 위주로 정의하는 작업
    - **캡슐화 (Encapsulation)**
        - **데이터 구조와 데이터를 다루는 방법들을 결합**시켜 묶는 것 (변수와 함수를 하나로 묶는 것)
        - **낮은 결합도를 유지**할 수 있도록 설계하는 것
        - 속성과 기능을 정의하는 **변수와 메서드를 클래스라는 캡슐에 넣어서 분류**하는 것으로 **재활용이 원활함**
        - 캡슐화를 통해 **정보은닉을 활용**할 수 있음 (접근제어자의 활용)
        - 객**체의 데이터를 외부에서 직접 접근하지 못하게 막음** (함수를 통해서만 조작이 가능하게 하는 작업)
    - **상속 (Inheritance)**
        - 클래스의 속성과 행위를 **하위 클래스에 물려주거나** 하위 클래스가 상위 클래스의 속성과 행위를 물려받는 것. 새로운 클래스가 기존의 클래스의 데이터와 연산을 이용할 수 있게 하는 기능
        - 장점
            - 재사용성
            - 범용적인 사용
            - 자료와 메서드의 자유로운 사용 및 추가
        - 단점
            - 상위 클래스의 변경이 어려움
            - 불필요한 클래스의 증가
    - **다형성 (Polymorphism)**
        - 하나의 변수명, 함수명이 상황에 따라 다른 의미로 해석될 수 있는 것
        - 하나의 클래스 내부에 같은 이름의 행위를 여러 개 정의하거나 상위 클래스의 행위를 하위 클래스에서재정의하여 사용할 수 있음
        - 상속을 통해 기능을 확장하거나 변경하는 것을 가능하게 함
        - 형태가 같은데 다른 기능을 한느 것을 의미
        - 코드의 재사용, 간결한 코드, 유지보수 용이

### 3. 오버라이딩과 오버로딩의 차이점을 설명해주세요. (유지연)

- 오버라이딩
    - 자식 클래스에서 부모 클래스의 메서드를 재정의해서 사용하는 것
    - 조건
        - 메서드의 이름이 일치해야 함
        - 매개변수의 개수, 순서, 데이터 타입이 일치해야 함
        - return 타입이 일치해야 함
- 오버로딩
    - 같은 이름의 메서드를 메서드마다 다른 용도로 사용하며 그 결과물도 다르게 구현
    - 이름은 같지만 매개변수의 개수나 데이터 타입이 달라야 함
    - 같은 이름의 속성을 유지함으로써 인터페이스를 유지하고 메서드 이름을 낭비하지 않음
    - 같은 클래스 내부에서 메서드르 확장하기 위한 개념
    - 조건
        - 메서드 이름 일치
        - 매개변수의 개수 또는 타입이 달라야 함

### 4. 자바의 메모리 영역에 대해 설명해주세요. (김은솔)

- JVM
    - 자바 버츄얼 머신. 자바 가상 머신
    - 자바의 바이트 코드를 해석하고 실행하는 역할
    - OS에 상관없이 실행할 수 있음
    - 실행 순서
        1. .java 파일을 컴파일러를 통해 .class 파일로 변환
        2. .class 파일을 JVM의 ClassLoader에게 보냄
        3. 클래스로더에서 JVM 런타임 영역으로 할당하여 메모리에 올림
- JVM 런타임 데이터 영역
    - Static
    - Heap
    - Stack
    - PC Register
    - Native Method Stack
- 순서
    - java 프로그램 실행 → JVM은 OS로 부터 메모리를 할당 받음 → 할당 받은 메모리를 자바 프로그램에 맞게 여러 개의 영역으로 나누어 사용
- 변수
    - 클래스 변수 (Static)
        - 선언 위치 : 클래스 영역
        - static 키워드가 붙음
        - 사용 : 여러 객체에서 공통으로 사용
        - 생성 시기 : 클래스가 메모리에 올라갈 때
        - 소멸 시기 : 프로그램 종료 시
        - 저장 메모리 : Static
    - 인스턴스 변수 (Instance)
        - 선언 위치 : 클래스 영역
        - 클래스 영역에서 static이 아닌 변수
        - 생성 시기 : 인스턴스가 생성될 때
        - 소멸 시기 : 인스턴스 소멸 시
        - 저장 메모리 : Heap
    - 지역 변수 (Local)
        - 선언 위치 : 메서드 영역
        - 메서드 내부에서 선언
        - 초기값을 지정해야 사용 가능
        - 생성 시기 : 블록 내에서 변수의 선언문이 실행될 때
        - 소멸 시기 : 블록을 벗어날 때
        - 저장 메모리 : Stack
- **Static (Method) 영역**
    - **클래스 변수나 static으로 선언된 것**들이 해당 메모리 영역에 저장
    - **JVM이 실행될 때** Class가 로딩될 때 생성
    - Class의 정보, Static 변수, 생성자, 메서드와 같은 것들을 저장
    - Static 영역에 있는 것은 **어디서든 접근 가능**
    - JVM이 종료 시 메모리에서 해제됨
- **Heap 영역**
    - **인스턴스를 생성할 때** 사용되는 메모리 영역
    - 참조형 데이터 객체의 **실제 데이터가 저장**되는 공간
    - Stack 영역에서 실제 데이터가 존재하는 Heap 영역의 참조값을 가짐
    - **new를 사용해 객체를 생성할 때** 저장
    - **참조형 데이터 타입**이 저장 (String, 배열, enum, class, Interface)
    - Heap 영역의 데이터들을 가르키는 참조주소는 스택 영역에 적재
    - 참조를 통해서만 힙 영역의 데이터에 접근, 핸들링 할 수 있음
    - 호출이 종료되어도 삭제 되지 않음 → **GC에 의해 메모리에서 해제**
    - 스레드가 몇 개 존재하든 **단 하나의 영역만 존재** (Stack 영역의 경우 스레드 별로 1개씩 생성)
    
    ![Untitled](Java%20f02d301fc1934a619033c2a3f7fe455b/Untitled%201.png)
    
- **Stack 영역**
    - **기본 자료형, 지역변수, 매개변수**가 저장되는 메모리
    - 메서드 내부의 기본자료형에 해당하는 변수를 적재
    - 힙 영역에 생성된 데이터의 **참조값이 할당**
    - **메서드가 호출될 때** 메모리에 할당, 메서드 종료 시 메모리에서 삭제됨
    - 자료구조 스택의 구조. LIFO
    - **각 Thread마다 자신만의 스택을 가진다**
    - 스레드는 내부적으로 스태틱, 힙, 스택 영역을 가짐
    - 스레드는 다른 스레드에 접근할 수 없지만 스태틱, 힙 영역을 공유하여 사용 가능

### 5. SOLID 원칙에 대해 설명해주세요. (김은솔)

- SOLID 원칙 : 객체지향 설계에서 지켜야 할 5가지 소프트웨어 개발 원칙
- **SRP (Single Responsibility Principle, 단일 책임 원칙)**
    - 클래스는 단 하나의 책임만 가져야 한다
    - 하나의 클래스는 **하나의 기능을 담당**하여 하나의 책임을 수행해야 함
- **OCP (Open Closed Principle, 개방 폐쇄 원칙)**
    - 확장에는 열려있고 수정에는 닫혀있어야 한다
    - **추상화** 사용을 통한 관계 구축을 권장
    - 새로운 변경 사항이 발생했을 때 유연하게 코드를 추가
    - 새로운 변경 사항이 발생했을 때 객체를 직접적으로 수정하는 걸 제한
- **LSP (Listov Substitution Principle, 리스코프 치환 원칙)**
    - 서브 타입은 언제나 부모 타입으로 교체할 수 있어야 한다
    - **다형성** 원리를 이용하기 위한 원칙
    - 상위 클래스 타입으로 객체를 선언하여 하위 클래스의 인스턴스를 받으면 업캐스팅된 상태에서 부모의 메서드를 사용해도 동작이 의도대로 흘러가야 함
    - 부모 객체를 호출하는 동작에서 자식 객체가 부모 객체를 완전히 대체할 수 있어야 함
- **ISP (Interface Segregation Principle, 인터페이스 분리 원칙)**
    - 인터페이스를 각각 사용에 맞게끔 잘게 분리해야 한다
    - 인터페이스 단일 책임을 강조
    - 클라이언트의 목적과 용도에 적합한 인터페이스만을 제공
    - 한 번 인터페이스를 분리하여 구성해놓고 나중에 수정사항이 생겨서 또 인터페이스들을 분리하는 행위 ㄴㄴ
- **DIP (Dependency Inversion Principle, 의존 역전 원칙)**
    - 어떤 클래스를 참조해야 하는 상황에서 클래스를 직접 참조하지 않고 대상의 상위 요소 (추상 클래스 / 인터페이스)로 참조하라는 원칙
    - 구현 클래스에 의존하지 말고 인터페이스에 의존
    - 의존 관계를 맺을 때 변화하기 쉬운 것, 자주 변화하는 것보다는 변화하기 어려운 것, 거의 변화가 없는 것에 의존하라는 것
    - 클래스 간의 결합도를 낮추는 것

### 6. 자바의 컴파일 과정에 대해 설명해주세요. (김은솔)

1. 자바 소스코드 작성 (**.java**)
2. 자바 컴파일러가 자바 소스파일을 컴파일 → 자바 바이트 코드 (**.class**) 파일로 아직 컴퓨터가 읽을 수 없는 JVM이 이해할 수 있는 코드
3. 컴파일된 바이트 코드를 JVM **클래스로더에게 전달**
4. 클래스로더는 동적 로딩을 통해 필요한 클래스들을 로딩 및 링크하여 **런타임 데이터 영역, JVM 메모리에 올림**
    1. 로드 : 클래스 파일을 가져와서 JVM 메모리에 로드
    2. 검증 : 자바 언어 명세 및 JVM 명세에 명시된 대로 구성되어 있는지 검사
    3. 준비 : 클래스가 필요로 하는 메모리를 할당
    4. 분석 : 클래스의 상수 풀 내 모든 심볼릭 레퍼런스를 다이렉트 레퍼런스로 변경
    5. 초기화 : 클래스 변수들을 적절한 값으로 초기화
5. 실행엔진은 JVM 메모리에 올라온 **바이트 코드들을 명령어 단위로 하나씩 가져와서 실행**
    1. **인터프리터** : 바이트 코드 명령어를 **하나씩 읽어서 해석하고 실행**
    2. **JIT 컴파일러** : 바이트 코드 **전체를 컴파일**하여 바이너리 코드로 변경 → 해당 메서드를 더이상 인터프리팅 하지 않고 바이너리 코드로 직접 실행

### 7. 클래스와 인터페이스의 차이점에 대해 설명해주세요. (송채은)

![Screenshot 2024-04-16 at 4.43.57 PM.png](Java%20f02d301fc1934a619033c2a3f7fe455b/Screenshot_2024-04-16_at_4.43.57_PM.png)

- 추상 클래스
    - 일반 클래스와 달리 abstract 명령어가 붙는다. 객체 생성 불가능
    - 미완성 설계도
    - 다중 상속 불가능
    - 추상화를 하면서 중복되는 클래스 멤버들을 통합 및 확장할 수 있음
    - **클래스 간의 연관 관계를 구축**하는 것에 초점
    - **기능을 확장**시키는 데 목적
    - extends
    - 언제 사용?
        - 상속 받을 클래스들이 공통으로 가지는 메서드와 필드가 많아 중복 멤버 통합을 할 때
        - 퍼블릭 외 접근자 선언이 필요한 경우
        - 하위 클래스가 오버라이드하여 재정의하는 기능들을 공유하기 위한 상속 개념을 사용할 때
- 인터페이스
    - 기본 설계도
    - 클래스에 다중 구현 지원
    - 인터페이스끼리 다중 상속 지원
    - 구체적인 메서드를 가질 수 있음
    - 멤버변수 상수만 가능
    - 클래스와 별도로 **구현 객체가 같은 동작을 한다는 것을 보장**하기 위해 사용
    - implements
    - 언제 사용?
        - 서로 관련성이 없는 클래스들을 묶어주고 싶을 때
        - 다중 상속을 통한 추상화 설계를 해야 할 때

### 8. 접근 제어자란 무엇인지, 어떤 것들이 있는지 설명해주세요. (송채은)

- 접근 제어자
    - 클래스와 클래스의 멤버(필드, 메서드, 생성자)를 사용할 때 접근할 수 있는 범위를 지정
- 클래스의 접근 제어자
    - public
        - 모든 클래스에서 이 클래스에 접근 가능 (패키지에 상관없음)
    - default(생략)
        - 같은 패키지 안의 클래스에서만 접근 가능
- 클래스 멤버의 접근 제어자
    - public
        - 모든 클래스에서 접근 가능 (패키지와 상관없음)
    - protected
        - 같은 패키지 안의 모든 클래스, 다른 패키지의 자식 클래스에서 접근 가능
    - default(생략)
        - 같은 패키지 안의 클래스에서만 접근 가능
    - private
        - 같은 클래스 안에 있는 멤버들만 접근 가능

### 9. 자바의 예외 처리 방법에 대해 설명해주세요. (송채은)

- 예외 : 프로그래머가 작성한 로직으로 인해 발생하는 문제. 미리 예측하여 처리 가능
- 에러 : 시스템 레벨에서 발생하는 심각한 수준의 문제. 미리 예측 불가. 로직으로 처리 불가
- 예외 처리를 하는 이유
    - 예외적인 상황을 대비하여 미리 안전장치를 하는 것
- 예외 복구 : 예외 상황을 파악하고 문제를 해결하여 정상 상태로 돌려놓는 방법
- 예외 회피 : throws 키워들르 통해 직접 처리하지 않고 호출한 쪽으로 던져 회피
- 예외 전환 : 회피와 비슷하게 메서드 밖으로 예외를 throw 하지만 그냥 던지지 않고 적합한 의미를 가진 예외로 변경하여 던짐
- try-catch
    - try : 예외 발생 가능성이 있는 문장
    - catch : 예외가 발생하면 어떻게 처리할 것인지 작성
    - final : 예외가 발생하든 말든 최종적으로 처리되는 로직
- throw
    - 예외를 고의로 발생시킴
    - 예외 클래스 객체를 만들어주고 예외를 강제적으로 발생시킴
    - 상위 블럭이나 캐치문으로 예외를 던짐
- throws
    - 예외가 발생하면 상위 메서드로 예외를 던짐
    - 자신을 호출한 상위 메서드로 예외를 던지는 역할

### 10. 자바의 Exception 종류에 대해 설명해주세요. (박규영)

- Checked Exception (OtherException)
    - 컴파일러가 예외 체크함
    - 반드시 명시적인 예외처리 (트라이캐치, throws)를 해야 하며 컴파일 시점에서 예외 발생과 제대로 처리했는지 확인된다
    - ex) IOException, SQLException
- Unchecked Exception (RuntimeException)
    - 컴파일러가 예외를 체크하지 않음
    - 컴파일 후 런타임 시 발생할 수 있는 예외. 명시적인 예외처리를 해주지 않아도 컴파일 됨
    - 프로그래밍 버그나 논리 오류에서 기인한다
    - ex) NullPointerException, ArithmeticException(/0), ArrayIndexOutOfBoundsException

### 11. 자바에서 왜 String을 불변 객체로 설정했는지 설명해주세요. (박규영)

- 불변 객체
    - 변경이 불가능한 객체 (힙 영역에서 그 객체가 가리키고 있는 데이터 자체의 변화가 불가능)
    - 객체 생성 후 외부에 의해 그 상태를 바꿀 수 없음
- String을 생성하는 방법
    - String Literal
        - 힙 영역 내 String Constant Pool에 할당, 재사용 가능
        - 값이 같으면 동일한 객체를 재사용
        - String Constant Pool에 각 문자열 값의 복사본을 하나 저장
        - JVM은  String Constant Pool에서 동일한 값의 문자열을 검색하고 있으면 그 주소값을 반환하여 재사용 (Interning)
    - new 연산자
        - 힙 영역, 재사용 불가
        - 개별적인 객체로 서로 다른 객체를 참조
- 왜?
    - 보안, 캐싱, 복사가 필요없는 빠른 재사용성, 동기화
    - 보안
        - String은 민감한 정보를 저장하기 위해 많이 사용됨
    - 해시코드 캐싱
        - String은 HashMap, HashTable, HashSet과 같은 해시 구현에서도 사용됨 → 변경되지 않는 문자열을 보장하기 때문에 가능
    - 복사가 필요없는 재사용성
        - String Constant Pool에서 관리하여 같은 값에 대해 객체를 다시 만들지 않고 이미 존재하는 객체를 참조할 수 있음
    - 동기화
        - 불변 객체는 값이 바뀌지 않기 때문에 멀티스레드 환경에서 스레드-세이프 하다는 장점이 있음
        - 스레드가 값을 변경하면 동일한 스트링을 수정하는 대신 String Constant Pool에 새 문자열이 생성되기 때문
- String을 new 연산자로 생성하면 힙 영역에 매번 객체가 생성됨. 불변성의 장점을 위해 String Literal을 이용해서 생성~~!

### 12. 알고있는 자바 JDK 버전과 각 버전 별 변경 사항에 대해 설명해주세요. (박규영)

[https://techblog.gccompany.co.kr/우리팀이-jdk-17을-도입한-이유-ced2b754cd7](https://techblog.gccompany.co.kr/%EC%9A%B0%EB%A6%AC%ED%8C%80%EC%9D%B4-jdk-17%EC%9D%84-%EB%8F%84%EC%9E%85%ED%95%9C-%EC%9D%B4%EC%9C%A0-ced2b754cd7)

- Java 8 (1.8)
    - Lambda 제공
    - stream api 제공
    - new Date and Time API (LocalDateTime..) 제공
    - 가장 오랜 Support를 보장
    - 국내 대다수 java8로 개발되어 운영하고 있음
- Java 11
    - Oracle JDK와 OpenJDK 통합
    - lambda 지역변수 var 키워드 사용 가능
    - 컬렉션, 스트림 등에 메서드 추가
    - 새로운 가비지 컬렉터 추가
- Java 17
    - record 클래스 키워드 사용 가능
        - getter, setter, toString, equals, hashCode 메서드를 자동으로 생성해줌
    - 난수 생성 api cnrk
    - 봉인 클래스(Sealed Class) 정식 추가
    - String 여러 줄 사용 시 텍스트 블록 기능 사용 가능
    - NumberFormat, DateTimeFormatter 기능 향상
    - Stream.toList() 사용 가능
- Java17을 사용한 이유
    - Java 서포트 기간이 길다 (LTS)
    - SpringBoot3.0부터는 java17 이상을 지원
    - 신규 버전을 위한 대비