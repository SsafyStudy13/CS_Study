# 알고리즘

### (참고) 알고리즘 기법과 알고리즘 설계기법

- 알고리즘 기법
    - 문제를 해결하기 위해 사용되는 절차적인 방법
    - 정렬 알고리즘, 검색 알고리즘, 그래프 탐색 알고리즘 등
- 알고리즘 설계 기법
    - 문제 해결을 위해 알고리즘을 설계하는 방법이나 접근 방식
    - 분할 정복, DP, 그리디, 백트래킹 등

### 동적 계획법(DP)에 대해 설명해주세요. (유지연)

- **복잡한 문제를 더 작은 하위 문제로 나누어 해결**하는 알고리즘 설계 기법
- **Bottom-Up - 반복문 사용**
    - 작은 하위 문제로 시작하여 결과를 저장하고 점진적으로 큰 문제의 해를 구함
- **Top-Down - 재귀 사용**
    - 큰 문제를 작은 부분 문제로 나누어 해결하는 방식
- **메모이제이션**
    - 중복되는 계산 결과를 저장하는 메모리 기법
    - 중복 계산을 방지. 계산 속도 향상
- Tabulation
    - 테이블에 저장된 값에 직접 접근하여 재활용
- 적용시킬 수 있는 조건
    - 중복되는 부분 문제
        - **동일한 작은 문제들이 반복하여 나타나는 경우**
    - 최적 부분 구조
        - **부분 문제의 최적 결과 값을 사용해 전체 문제의 최적 결과를 낼 수 있는 경우**
    - ex) 피보나치-탑다운, 배낭 문제-바텀업, 최장증가부분수열-바텀업, 최단경로-바텀업
- 장점
    - 중복 계산을 줄일 수 있다
    - 효율적인 시간 복잡도
- 단점
    - 메모리 사용량이 크다

<aside>
📢 동적계획법은 복잡한 문제를 작은 문제로 쪼개서 해결하는 알고리즘 설계 기법입니다. DP의 사용 조건은 첫 번째, 동일한 작은 문제들이 반복하여 나타나야 하고 두 번째, 부분 문제의 최적 결과 값으로 전체 문제의 최적 결과를 낼 수 있어야 합니다. 구현 방법으로는 Bottom-Up 방식과 Top-Down 방식이 있습니다. Bottom-up 방식은 아래에서부터 계산을 수행하고 누적시켜서 전체 문제를 해결하는 방식으로 반복문을 통해 점화식으로 결과를 냅니다. Top-Down 방식은 위에서부터 바로 호출을 시작하여 결과값을 재귀를 통해 전이시켜 재활용하는 방식으로 이전 계산 값을 저장해놓는 걸 메모이제이션이라고 합니다. DP를 사용하는 대표적인 문제로는 피보나치 수열과 배낭 문제가 있습니다.

</aside>

### 재귀 알고리즘과 사용되는 사례에 대해 설명해주세요. (유지연)

- **내부적으로 자기 자신을 호출하는 함수**
- **종료조건이 반드시 필요 (없으면 무한루프에 빠짐)**
- **모든 case는 종료 case로 수렴해야 함**
- 재귀 호출을 너무 많이 하면 스택 메모리 영역에 너무 많은 공간을 할당하게 되어 스택 오버플로우 발생
- 예제
    - 피보나치 수열 (중복계산이 많아서 재귀로 푸는 건 비효율적)
    - 팩토리얼

<aside>
📢 재귀 알고리즘이란 내부적으로 자기 자신을 호출하는 함수를 사용하는 알고리즘입니다. 재귀 함수는 종료 조건이 없으면 무한 루프에 빠지므로 반드시 필요합니다. 모든 case는 종료 case로 수렴해야 합니다. 모든 재귀 함수는 반복문으로 똑같이 구현할 수 있습니다. 재귀 호출을 너무 많이 하면 스택 메모리 영역에 많은 공간을 할당하여 스택 오버 플로우가 발생할 수 있습니다.

</aside>

### 최단거리 알고리즘에 대해 설명해주세요. (유지연)

- 최단거리 알고리즘
    - 그래프 상에서 노드 간의 탐색 비용을 최소화하는 알고리즘
    - 네비게이션과 같은 길찾기에 적용
- 다익스트라
    - 그래프에서 특정 노드에서 다른 모든 노드까지의 최단 거리를 구하는 알고리즘
    - 그리디 + DP
        - 현재 위치한 노드에서 최선의 경로를 반복적으로 찾음
        - 계산해둔 경로를 활용해 중복된 하위 문제 해결
    - 음의 가중치 불가
    - 시간 복잡도 : O(ElogV) V: 노드 E: 간선
- 플로이드-워셜
    - 모든 노드 간의 최단 거리를 구하는 알고리즘
    - DP
    - 음의 가중치 가능
    - 음의 사이클 불가
    - 경출도 (경유지 - 출발지 - 도착지)
        - 각 단계마다 특정한 노드를 거쳐가는 경우를 확인
    - 시간 복잡도 : O(V^3)
- 벨만-포드
    - 유향 그래프 상에서 특정 한 노드로부터 다른 노드까지의 최단 경로를 구하는 알고리즘
    - DP
    - 음의 가중치 가능
    - 음의 사이클 확인
    - 모든 노드가 한번씩 출발점이 되어 다른 노드까지의 최소 비용을 구함
    - 시간 복잡도 : 평균 - O(VE), 최악 - O(V^3)

<aside>
📢 최단 거리 알고리즘은 그래프 상에서 노드 간의 탐색 비용을 최소화하는 알고리즘입니다. 최단 거리 알고리즘의 종류에는 다익스트라, 벨만-포드, 플로이드-워셜이 있습니다. 다익스트라는 특정 노드에서 시작하여 모든 노드와의 최단 거리를 구하는 알고리즘으로 그리디 방법과 DP를 합쳐서 사용합니다. 음의 가중치가 있으면 사용할 수 없으며 시간 복잡도는 O(ElogV)입니다. 벨만-포드는 다익스트라와 비슷하지만 음의 가중치가 있어도 사용 가능하다는 차이점이 있습니다. DP 방식을 사용하여 모든 노드가 한번씩 출발점이 되어 다른 노드까지의 최소 비용을 구합니다. 시간 복잡도는 평균 O(VE), 최악의 경우 O(V^3)까지 나올 수 있습니다. 플로이드-워셜은 모든 노드 간의 최단 거리를 구하는 알고리즘으로 DP 방식을 사용합니다. 음의 가중치가 있어도 사용 가능하며 음의 사이클이 있을 땐 사용 불가합니다. 각 단계마다 특정한 노드를 거쳐가는 경우를 확인하여 시간 복잡도는 O(N^3)이 나옵니다.

</aside>

### 빅오표기법에 대해 설명해주세요. (특징, 성능 순서 등) (김은솔)

- 빅오표기법이란 알고리즘의 효율성을 표기해주는 표기법
- **최악의 실행시간을 표기**
- 시간복잡도와 공간복잡도를 나타내는데 주로 사용
- 특징
    - 상수항 무시
    - 계수 무시
    - 최고차항만 표기
- 성능 (>>>갈수록 효율 떨어짐)
    - O(1) < O(logN) < O(N) < O(NlogN) < O(N^2) < O(2^N)

<aside>
📢 빅오표기법이란 알고리즘의 효율성을 따지는 표기법으로 최악의 실행 시간을 표기합니다. 빅오표기법은 상수항과 계수를 무시하고 최고차항만 표기한다는 특징을 가지고 있습니다. 성능은 O(1) < O(logN) < O(N) < O(NlogN) < O(N^2) < O(2^N) 순으로 좋습니다.

</aside>

### 선택정렬에 대해 설명해주세요. (김은솔)

- 해당 자리를 선택하고 그 자리에 오는 값을 찾는 알고리즘
- 정렬되지 않은 데이터들에 대해 **가장 작은 데이터를 찾아 가장 앞의 데이터와 교환**해나가는 방식
- 제자리 정렬 (추가적인 메모리 요구 ㄴㄴ)
- 과정
    - 주어진 배열 중에서 최솟값을 찾는다
    - 그 값을 맨 앞에 위치한 값과 교체한다
    - 맨 처음 위치를 뺀 나머지 배열을 같은 방법으로 교체한다
- 특징
    - 자료 이동 횟수가 정해져있음
    - 불안정 정렬
        - 값이 같은 레코드가 있는 경우 상대적인 위치가 변경될 수 있음
- 시간 복잡도 : O(N^2)

<aside>
📢 선택정렬이란 최소값을 찾아 가장 앞의 값과 교환하는 방식으로 정렬하는 알고리즘입니다. 시간 복잡도는 O(N^2)이고 제자리 정렬이기에 추가적인 메모리는 필요하지 않습니다. 자료 이동 횟수가 정해져있고 값이 같은 레코드가 있는 경우 상대적인 위치가 변경될 수 있습니다.

</aside>

### 이진탐색에 대해 설명해주세요. (김은솔)

- **정렬된 배열**에서 범위를 줄이며 특정 값을 찾는 알고리즘
- 과정
    - **중간값**을 찾는다
    - 중간값과 검색값을 비교한다
        - 같으면 종료
        - 중간값이 크면 배열의 왼쪽 구간 탐색
        - 중간값이 작으면 배열의 오른쪽 구간 탐색
    - 값을 찾거나 간격이 비어있을 때까지 반복
- 시간 복잡도 : O(logN)

<aside>
📢 이진탐색이란 정렬된 배열에서 범위를 좁혀가며 특정 값을 찾는 알고리즘 기법입니다. 탐색 과정은 먼저 중간값을 찾고 검색값과 비교하여 중간값이 크면 왼쪽 구간, 작으면 오른쪽 구간을 탐색합니다. 값을 찾거나 간격이 비어있을 때까지 반복합니다. 시간복잡도는 O(logN)으로 빠른 편입니다.

</aside>

### 스위핑 알고리즘에 대해 설명해주세요. (박규영)

- **한 쪽 방향에서 시작해 다른 방향으로 스캔**하면서 쓸어가는 알고리즘 기법
- **정렬된 요소를 한 번만 순회**하도록 구현
- ex) 선긋기
    - 하나도 안 겹칠 때 (start, end 값 갱신
    - 일부만 겹칠 때 (end 값 갱신)
    - 모두 겹칠 때
- 시간 복잡도 : O(NlogN)

<aside>
📢 스위핑 알고리즘이란 한 쪽 방향에서 시작하여 다른 쪽 방향으로 스캔하면서 쓸어가는 방식의 알고리즘입니다. 정렬된 요소를 한 번만 순회하도록 구현해야 합니다. 시간 복잡도는 O(NlogN)입니다.

</aside>

### KMP 알고리즘에 대해 설명해주세요. (박규영)

- **전체 문자열에서 특정 문자열을 찾는** 알고리즘
- **불일치가 일어났을 때** 지금까지 일치한 글자수를 이용하여 다음으로 시작해야 할 위치를 빠르게 찾음
- **부분 일치 테이블**을 구현
- 시간 복잡도 : O(N+M)

### 위상 정렬에 대해 설명해주세요. (박규영)

- **순서가 정해져있는** 일련의 작업을 **차례대로 수행해야 할 때** 사용하는 알고리즘
- **사이클이 없는 방향 그래프**의 모든 노드를 방향성에 거스르지 않도록 순서대로 나열하는 것
- ex) 선수과목
- **진입차수**
    - 특정한 노드로 들어오는 간선의 개수
    - **내 앞에 몇 개**
- **진출차수**
    - 특정한 노드에서 나가는 간선의 개수
    - **내 뒤에 몇 개**
- 구현
    - 진입차수가 0인 노드를 큐에 넣음
    - 큐에서 원소를 꺼내 해당 노드에서 나가는 간선을 그래프에서 제거
    - 새롭게 진입차수가 0이 된 노드를 큐에 삽입
    - 큐가 빌 때까지 반복
- 특징
    - **사이클이 없는 그래프에서만 가능**
    - **여러 답 존재 가능**
    - **모든 원소를 방문하기 전에 큐가 비면 사이클 존재**
- 시간 복잡도 : O(V+E)

### BFS와 DFS에 대해 설명해주세요. (송채은)

- DFS (깊이우선탐색, Depth-First-Search)
    - 구현 방법 : 스택, 재귀 호출
    - 시작 노드에서 한 경로를 따라 최대한 깊게 탐색한 후 다른 경로 탐색
    - 경로마다 특징을 저장해야 할 때
- BFS (너비우선탐색, Breadth-First-Search)
    - 구현 방법 : 큐
    - 시작 노드에서 인접한 노드를 모두 탐색한 후 다음 노드로 이동
    - 최단 경로, 노드 간의 최단 거리
- 시간 복잡도
    - 인접리스트 : O(V+E)
    - 인접 행렬 : O(V^2)
    - 공간 복잡도 : O(V)

### Prim과 Kruskal 알고리즘에 대해 설명해주세요. (송채은)

- 최소 스패닝 트리
    - 간선들의 가중치 합이 최소인 신장 트리
- 크루스칼
    - 구현
        - **가중치를 기준으로 간선 오름차순 정렬**
        - **간선들을 순서대로 모든 정점이 연결될 때까지 연결**
    - 간선 위주 알고리즘
    - 사이클이 생기는지 확인하기 위해 **유니온 파인드** 사용 > O(1)
    - 시간 복잡도 : **퀵정렬 사용 시 O(ElogE)**
- 프림
    - 구현
        - 임의의 노드 하나 선택
        - 새로운 노드를 연결할 때마다 갈 수 있는 아직 연결 안 된 정점들에 대한 간선을 추가
    - 정점 위주 알고리즘
    - 노드에서 갈 수 있는 노드를 모두 minHeap에 추가 > 최대 E번 힙에 넣음
    - 우선순위큐를 이용한 최소힙으로 구현
    - 시간 복잡도 : O(ElogV)
- 간선의 개수가 작은 경우 크루스칼, 간선의 개수가 많은 경우 프림

### 알고 있는 정렬 알고리즘에 대해 설명해주시고 비교해서 어떤 차이가 있는지 설명해주세요. (송채은)

- 버블정렬
    - 옆에 있는 데이터와 비교하며 작은 값을 앞으로 보내는 정렬
    - 가장 느리고 효율성이 떨어짐
    - O(N^2)
- 선택정렬
    - 가장 작은 값을 선택하여 앞으로 보내는 정렬
    - O(N^2)
- 삽입정렬
    - 데이터를 순서대로 뽑아서 적절한 위치를 찾아 삽입
    - 이미 정렬되어 있다면 빠름
    - 평균, 최악: O(N^2), 최선: O(N)
- 병합정렬
    - 분할 → 정렬 → 결합
    - 데이터 배열을 2개 이상의 부분 배열로 분할하고 부분 배열에서 정렬한 뒤 결합하여 다시 정렬
    - O(NlogN)
- 퀵소트
    - 임의의 기준값을 정해서 두 부분 집합으로 나누고 기준값(피봇)을 기준으로 왼쪽엔 작은값, 오른쪽엔 큰값을 배치하여 더이상 집합을 나눌 수 없을 때까지 재귀
    - 이미 정렬된 데이터에서는 비효율적
    - 평균, 최선: O(NlogN), 최악: O(N^2)
- 힙소트
    - 이진트리 기반의 트리형 자료구조로 최솟값 최댓값을 찾아내기 위해 사용
    - O(NlogN)