# Algorithm

</br>

## 빅오표기법

- 정의 및 특징

  : 시간 복잡도를 표현하기 위한 방법 중 하나

  → 알고리즘 로직이 문제를 해결하는 데 얼마의 시간이 걸리는가

  : 입력 범위 n을 기준으로 로직이 몇 번 반복되는지 나타냄

  : 가장 큰 영향을 끼치는 항의 상수 인자를 빼고, 나머지 항을 없앰

  : 효율적인 코드로 개선하는 데 쓰이는 척도로 활용

- 성능 순서

  ```text
  O(1) < O(log n) < O(n) < O(n log n) < O(n²) < O(2ⁿ) < O(n!)
  ```

</br>

## BFS와 DFS

> ### BFS (Breadth First Search)
>
> : 다차원 배열, 그래프에서 각 칸, 노드를 방문할 때 너비를 우선으로 방문하는 알고리즘
>
> - 특징
>
>   : 시작 정점으로부터 가까운 정점들을 먼저 방문
>
>   : 큐를 사용하여 구현
>
>   : **최단 경로**를 찾을 때 주로 사용
>
> - 시간 복잡도 
>
>   → 방문하는 칸의 개수가 n개일 때 `O(n)`
>
>   → 행렬로 구현한 그래프의 경우, 정점의 수 V 일 때 `O(V²)`
>
>   → 리스트로 구현한 그래프의 경우, 정점의 수 V, 간선의 수 E일 때 `O(V + E)`

</br>

> ### DFS (Depth First Search)
>
> : 다차원 배열, 그래프에서 각 칸, 노드를 방문할 때 깊이를 우선으로 방문하는 알고리즘
>
> - 특징
>
>   : 한 정점에서 시작하여 더 이상 방문할 곳이 없을 때까지 최대한 깊게 방문
>
>   : 재귀 함수 또는 스택을 사용하여 구현
>
>   : 사이클을 탐지할 때 주로 사용
>
>   : 깊이가 무한히 깊어지면 stack overflow 발생 가능성 有
>
>   
>
> - 시간 복잡도 (BFS와 동일)
>
>   → 다차원 배열의 경우, 방문하는 칸의 개수가 n개일 때 `O(n)`
>
>   → 행렬로 구현한 그래프의 경우, 정점의 수 V 일 때 `O(V²)`
>
>   → 리스트로 구현한 그래프의 경우, 정점의 수 V, 간선의 수 E일 때 `O(V + E)`

</br>

## 재귀

- 정의

  : 함수가 자기 자신을 호출하여 문제를 해결하는 알고리즘

- 특징

  : 특정 입력에 대해서는 자기 자신을 호출하지 않고 종료되어야 함 (Base Condition)

  → 모든 입력은 Base Condition으로 수렴

  : 모든 재귀 함수는 반복문만으로 동일한 동작을 하는 함수를 만들 수 있음

  → 재귀는 반복문으로 구현했을 때보다 코드가 간결하지만, 메모리와 시간 측면에서 손해를 봄

  : 한 함수가 자신을 여러 번 호출하게 되면 비효율적일 수 있음

  → 재귀 함수가 자기 자신을 부를 때 스택 영역에 데이터가 계속 누적이 되기 때문

- 예시
  - 팩토리얼 계산
  - 피보나치 수열
  - 하노이탑
  - 이진 트리 순회

</br>

## 정렬

: 요소들을 특정 순서대로 재배치하는 알고리즘

: 정렬할 데이터의 양, 메모리 사용량, 초기 정렬된 정도 등에 따라 알고리즘을 선택

> ### 버블 정렬
>
> : **서로 인접해 있는 요소 간 대소 비교**를 통해 정렬
>
> : 쉽게 구현할 수 있으나 비효율적임
>
> : 추가적인 메모리 공간이 필요하지 않음
>
> - 시간 복잡도
>   - 평균 : `O(n²)`
>   - 최고 : `O(n)`
>   - 최악 : `O(n²)`

</br>

> ### 삽입 정렬
>
> : 정렬을 진행할 원소의 **index보다 작은 곳에 있는 원소들을 탐색**하여 알맞은 위치에 삽입하여 정렬
>
> - 시간 복잡도
>   - 평균 : `O(n²)`
>   - 최고 : `O(n)`
>   - 최악 : `O(n²)`

</br>

>### 선택 정렬
>
>: 배열에서 **최대/최소값을 찾아** 정렬
>
>→ 최대값 선택 시, 내림차순 정렬 / 최소값 선택 시, 오름차순 정렬
>
>: 찾은 최대/최소값을 맨 앞의 값과 바꾼 후, 바꾼 앞 값을 제외한 나머지 원소에서 다시 최대/최소값 탐색
>
>: 이미 정렬되어 있는 자료구조에 삽입, 제거하는 경우, 또는 배열의 크기가 작은 경우에 효율적
>
>: 추가 메모리 공간이 필요하지 않음
>
>- 시간 복잡도
>  - 최고, 평균, 최악 모두 `O(n²)`

</br>

> ### 퀵 정렬
>
> : **pivot을 기준으로** 큰 값과 작은 값을 나누어 정렬
>
> : 분할 정복 방법 사용
>
> : 대용량 데이터를 정렬할 때 유리
>
> - 시간 복잡도
>   - 최고, 평균 `O(nlogn)`
>   - 최악 `O(n²)`

</br>

> ### 병합 정렬
>
> : 배열을 반으로 나눈 후, 각각을 정렬하고 합쳐서 정렬된 리스트를 생성
>
> : 분할 정복과 재귀 알고리즘을 사용
>
> : 원소가 하나만 남을 때까지 이분할 진행
>
> : 추가적인 메모리 공간이 필요함
>
> - 시간 복잡도
>   - 최고, 평균, 최악 모두 `O(nlogn)`

</br>

> ### 힙 정렬
>
> : 힙 자료구조인 **완전이진트리를 기반으로 정렬**
>
> : 오름차순 정렬의 경우, 최소 힙 / 내림차순 정렬의 경우, 최대 힙 사용
>
> ​	→ 최소힙의 경우, 부모 노드가 항상 자식 노드보다 작은 값을 가짐
>
> ​	→ 최대힙의 경우, 부모 노드가 항상 자식 노드보다 큰 값을 가짐
>
> : 완전이진트리이기 때문에, 중앙 값에 가까운 값을 근사치로 빠르게 탐색할 수 있음
>
> : 이진탐색트리와 달리 중복된 값을 허용
>
> : **우선순위큐, 다익스트라, 프림알고리즘에 활용**
>
> - 시간 복잡도
>   - 최고, 평균, 최악 모두 `O(nlogn)`

| 버블정렬 | 삽입 정렬 | 선택 정렬 | 퀵 정렬 | 병합 정렬 | 힙 정렬 |
| :------: | :-------: | :-------: | :-----: | :-------: | :-----: |
|    n²    |    n²     |    n²     |  nlogn  |   nlogn   |  nlogn  |

</br>

## 동적 계획법(DP, Dynamic Programming)

: 하나의 큰 문제를 여러 개의 부분 문제로 나누어 그 결과를 쌓아올려 주어진 문제를 해결하는 알고리즘

: 문제를 해결하기 위한 점화식을 찾아낸 뒤, 점화식의 항을 차례로 구해나감

: 재귀를 사용할 때, 동일한 연산을 반복 수행하는 비효율적인 경우를 개선시킬 수 있음

​	→ 동일한 연산이 반복해서 나타나는 경우 + 부분 문제의 결과 값을 사용해 전체 문제의 결과를 낼 수 있는 경우에 사용

- 구현 방법

  1. **Bottom-Up 방식 (= Tabulation)**

     : dp[0] 부터 계산하여 dp[n]의 값을 도출하는 방식

  2. **Top-Down 방식 (= Memoization)**

     : 위에서부터 호출하여 dp[0]까지 내려간 다음 해당 결과 값을 재귀를 통해 전이시켜 재활용하는 방식

- 분할 정복과의 비교

  : 주어진 문제를 나누어 해결한 뒤 큰 문제를 해결한다는 점에서는 동일

  : 분할 정복은 하위 문제가 중복 발생하지 않는 경우에 사용되고, DP는 하위 문제가 중복 발생하는 경우에 사용 됨

</br>

## 이진 탐색

: **정렬된 데이터**에서 특정 값을 탐색하는 알고리즘

: 배열의 중간 값과 비교하여 찾고자 하는 값이 왼쪽/오른쪽에 위치하는지를 반복적으로 탐색

: 배열이 정렬되어 있어야 한다는 전제 조건이 필요

: 탐색 범위를 반으로 나누기 때문에, 선형 탐색보다 훨씬 빠른 속도를 보임

- 시간 복잡도
  - 최고 `O(1)`
  - 최악, 평균 `O(logn)`

</br>

## 위상 정렬

: **방향 그래프**에서 간선으로 주어진 정점 간 **선후관계를 위배하지 않도록 나열**하는 정렬 알고리즘

: **사이클이 존재하지 않는 방향 그래프(DAG, Directed Acyclic Graph)에서 사용**

: 컴파일러, 작업 스케줄링 등에 사용

: 특정 정점에 들어오는 간선의 개수 indegree 배열을 사용하여 구현

​	[구현 방법]

		1. 모든 간선을 읽으며 indegree 테이블을 채움
		1. indegree가 0인 모든 정점들을 큐에 넣음
		1. 큐에서 정점을 꺼내며 위상 정렬 결과에 추가
		1. 해당 정점으로부터 연결된 모든 정점의 indegree 값을 1 감소하고 indegree가 0이 된 정점은 큐에 추가
		1. 큐가 비어있을 때까지 3, 4 과정 반복

</br>

## 최소 신장 트리(MST, Minimum Spanning Tree)

: 모든 정점을 간선의 최소 가중치 합으로 연결한 트리

: 선택된 간선의 수는 정점의 수보다 1 작음

: 한 그래프에는 여러개의 최소 신장 트리가 존재할 수 있음

> ### Kruskal
>
> : 그리디 알고리즘을 기반으로 최소 가중치를 차례대로 선택하여 최소 신장 트리를 찾는 알고리즘
>
> [구현 방법]
>
> 1. 간선 가중치를 오름차순으로 정렬하고 제일 낮은 비용의 간선을 선택
>
> 2. 현재 선택한 간선이 정점 A, B를 연결한다고 할 때
>
>    → Union-Find를 활용하여 A와 B의 부모 노드 확인 및 연결 작업
>
>    → A와 B의 부모 노드가 같은 경우? 그냥 넘어감
>
>    → A와 B의 부모 노드가 다른 경우? 두 정점의 부모를 동일하게 만들고 현재 선택한 간선을 최소 신장 트리에 추가
>
> 3. 최소 신장 트리에 V - 1개의 간선을 추가했다면 이 과정을 종료, 그렇지 않은 경우 최소 비용의 간선을 선택한 후 2번 과정 반복

</br>

> ### Prim
>
> : 시작 정점에서부터 신장 트리를 확장해 나가는 방식으로 최소 신장 트리를 찾는 알고리즘
>
> [구현 방법]
>
> 1. 시작 정점을 선택해 최소 신장 트리에 추가
> 2. 최소 신장 트리에 포함된 정점과 최소 신장 트리에 포함되지 않은 정점을 연결하는 간선 중, 최소 가중치 간선을 최소 신장 트리에 추가
> 3. 최소 신장 트리에 V - 1개의 간선이 추가될 때까지 2번 과정을 반복

➡️ 간선의 개수가 많은 경우, 크루스칼 알고리즘

➡️ 간선의 개수가 적은 경우, 프림 알고리즘

</br>

## 최단 거리 알고리즘

: 그래프에서 노드 간 탐색 비용을 최소화하는 알고리즘

: 네비게이션 길찾기 등에 사용

> ### 플로이드 워셜 알고리즘
>
> : **DP를 활용**하여 **모든 노드 간 최단 거리**를 구하는 데 사용
>
> : **가중치 값이 음수일 때도 사용 가능**(단, 음의 사이클이 존재한다면 벨만 포드 사용)
>
> : 노드 A에서 C로 이동할 때, A에서 B를 거쳐 C로 가는 것과 비교하여 최단 거리를 갱신
>
> - 시간복잡도
>
>   - 반복문이 3중이므로 `O(V³)`
>
>     → 정점의 수가 매우 많은 경우 비효율적

</br>

> ### 다익스트라 알고리즘
>
> : **우선순위큐(힙)를 사용**하여 **하나의 시작 노드에서 다른 모든 노드까지의 최단 거리**를 구하는 데 사용
>
> : 그리디와 DP가 합쳐진 형태
>
> : 음의 가중치를 포함하는 그래프에서는 사용 불가
>
> ​	→ 최단 경로를 DP 테이블에 저장한 뒤, 이후 재방문을 허용하지 않기 때문에 음의 가중치가 있다면 이러한 규칙에 위배됨
>
> - 시간복잡도
>
>    `O((V + E)logV)`

</br>

> ### 벨만 포드 알고리즘
>
> : 음의 가중치를 허용하지 않는 다익스트라의 한계점을 보완한 알고리즘
>
> ​	→ 다익스트라는 그리디하게 최소 경로를 찾아가지만 벨만 포드는 모든 경우의 수를 고려하기 때문에, 가중치가 모두 양수일 때는 다익스트라를 사용 하는 것이 효율적
>
> : 모든 노드가 한번씩 출발 노드가 되어 다른 노드까지의 최소 비용을 구하는 과정을 V - 1 번 반복 진행
>
> : V - 1번 진행한 결과와 V번 진행한 결과가 다르다면 음의 사이클이 존재함을 의미
>
> - 시간복잡도
>
>   `O(VE)` → 다익스트라보다 느림

</br>

## 스위핑 알고리즘

: **스위핑 라인**이라는 가상의 선을 사용하여 기하학적 객체들을 효율적으로 처리하는 알고리즘

: **정렬된 데이터를 기반**으로 스위핑 라인을 이동하면서 조건에 부합하는 요소를 확인

: 최단 경로 문제, 충돌 탐지 등에 활용

- 시간복잡도
  - 최고 평균 `O(nlogn)` → 정렬의 시간복잡도
  - 최악 `O(n²)`

​	❓ 관련 백준 알고리즘 문제

​		`2170 선긋기`

​		`1668 트로피 진열`

​		`2672 여러 직사각형의 전체 면적 구하기`

</br>

## KMP 알고리즘

: 문자열 탐색에 유용한 알고리즘

: 주어진 문자열의 0 ~ i까지의 부분 문자열 중, prefix == suffix를 만족하는 부분 문자열의 최대 길이를 저장하는 pi 배열을 사용

: pi 배열을 사용하여 문자열을 탐색할 때, 다음 탐색할 index를 정할 수 있음

: 문자열을 처음부터 끝까지 비교하지 않기 때문에 효율적인 검색이 가능

- 시간복잡도
  - 원본 문자열의 길이가 N, 탐색 문자열의 길이가 M일 때 `O(N + M)`

</br>