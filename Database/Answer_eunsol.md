# DB

### 📌 키의 종류 5가지와 각각 특징을 설명하세요. (전재우)

- 기본키(Primary Key)
    - 유일성과 최소성을 만족한 후보키에서 선택된 키
    - Null값ㄴㄴ, 유니크ㅇㅇ
- 외래키(Foreign Key)
    - 다른 테이블의 기본키를 참조하는 속성
    - 테이블 간의 관계를 나타내기 위해 사용
- 후보키(Candidate Key)
    - **유일성과 최소성**을 만족하는 키
    - 기본키가 될 수 있는 후보
- 슈퍼키(Super Key)
    - 유일성을 만족하는 키
- 대체키(Alternate Key)
    - 후보키 중에서 기본키로 선택되지 못한 키

<aside>
📢 먼저 유일성을 만족하는 키를 슈퍼키라고 합니다. 유일성과 최소성을 만족하는 키를 후보키라 하고 그 중 하나를 기본키로 선택합니다. 기본키는 null값이 들어갈 수 없고 유니크한 값을 가져야 합니다. 후보키 중 기본키로 선택되지 못한 키를 대체키라고 합니다. 다른 테이블의 기본키를 참조하는 걸 외래키라고 합니다.

</aside>

### 📌 트랜잭션의 특징 4가지를 설명하세요. (전재우)

- 트랜잭션이란?
    - DB의 상태를 변화시키기 위해 수행하는 작업 단위
    - SELECT / UPDATE / DELETE / INSERT 등의 조작어를 사용하는 행동
    - 상황에 따라 COMMIT / ROLLBACK 됨
    - ex) 은행 송금 과정
        - 은행 송금 과정 중에 해당 계좌에서 출금 행위가 일어나는 상황. 두 트랜잭션이 동시에 일어날 수 있기에 트랜잭션 처리를 잘 해주어야 함.
- 원자성(Atomicity)
    - 트랜잭션 작업이 모두 반영되거나 모두 반영되지 않아야 함
    - 부분적으로 실행되거나 중단되지 않는 것을 보장
    - Save Point : 특정 부분에서 트랜잭션 취소 가능
- 일관성(Constency)
    - 트랜잭션의 작업 처리 결과는 항상 일관성이 있어야 함
    - 트리거 : DML문 수행 시 자동으로 동작하여 일관성 보장
- 고립성(Isolation)
    - 트랜잭션 수행 시 다른 트랜잭션의 작업이 끼어들지 못하도록 보장해야 함
    - 락 / 언락 : 데이터를 읽거나 쓸 때 해당 영역에 락을 걸어서 다른 트랜잭션이 접근 못하도록 함. 먼저 들어온 트랜잭션의 요청이 끝나면 언락하여 다른 트랜잭션이 처리될 수 있도록 허용하며 고립성 보장. but 잘못하면 데드락에 빠질 수 있음
- 영속성(Durability)
    - 성공적으로 수행된 트랜잭션은 영원히 반영되어야 함

<aside>
📢 트랜잭션의 특징은 원자성, 일관성, 고립성, 영속성이 있습니다. 트랜잭션 작업이 모두 반영되거나 모두 반영되지 않아야 합니다. 트랜잭션의 작업 처리 결과는 항상 일정해야 하며 트랜잭션 수행 시 다른 트랜잭션의 작업이 끼어들지 못해야 합니다. 마지막으로 성공적으로 수행된 트랜잭션은 영원히 반영되어야 합니다.

</aside>

### 📌 반정규화에 대해 설명하세요. (전재우)

- 정규화 : 중복을 최소화하도록 설계된 데이터베이스
- 반정규화란?
    - 데이터베이스 성능향상을 위해 데이터 중복을 허용하고 조인을 줄이는 방법
- 장점
    - 데이터를 빠르게 조회할 수 있음
- 단점
    - 데이터 삽입, 삭제, 수정 시 비용이 높아짐
    - 데이터 무결성, 일관성이 깨질 수 있음
    - 저장공간을 많이 차지함
- 언제 사용?
    - 수행 속도가 많이 느린 경우
    - 조인 연산을 지나치게 사용하여야 하는 경우

<aside>
📢 반정규화란 데이터베이스 성능 향상을 위해 데이터의 중복을 허용하고 조인 연산을 줄이는 방법입니다. 반정규화를 진행하면 데이터를 빠르게 조회할 수 있는 장점이 있습니다. 다만 데이터의 삽입, 삭제, 수정 비용이 높아지고 데이터 무결성이 깨질 수 있습니다. 수행 속도가 많이 느리거나 조인 연산을 지나치게 사용해야 하는 경우 반정규화를 진행합니다.

</aside>

- 기법까지 말할 수 있을까..?
- 

### 📌 Join과 Union의 차이에 대해 설명해주세요.

- Join : 두 개의 테이블을 서로 묶어서 데이터를 조회하는 방법으로 적어도 하나 이상의 컬럼을 공유하고 있어야 함
- Union : 여러 개의 SELECT문의 결과를 단일 결과 세트로 연결할 때 사용. 중복되는 행은 한번만 표시 (All : 중복되는 행 모두 표시)
    - 각 SELECT문은 같은 수의 열을 가져야 함
    - SELECT문의 열은 동일한 순서로 있어야 함
    - 열은 호환되는 데이터를 가져야 함
- 차이점
    - Join
        - 적어도 하나의 속성이 공통인 두 테이블 속성을 결합할 때 사용
        - 공통 열을 기반으로 결합
    - Union
        - 하나의 결과 세트를 나타냄
        - 새로운 행으로 결합 (수직)

<aside>
📢 Union과 Join은 모두 데이터를 조합할 때 사용합니다. Join은 적어도 하나 이상의 공통된 속성으로 두 개의 테이블을 서로 묶어 데이터를 조회합니다. 공통된 열을 기반으로 데이터를 결합합니다. Union은 여러 개의 SELECT문의 결과를 단일 결과 세트로 연결합니다. 중복되는 행은 한번만 표시하고 새로운 행으로 결합합니다.

</aside>

### 📌 커밋되지 않은 읽기(read uncommitted)와 커밋된 읽기(read committed)에서 발생할 수 있는 문제점에 대해 설명해주세요.

- 트랜잭션 격리 수준 : 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있도록 허용할지 말지 정하는 것
- 커밋되지 않은 읽기 < 커밋된 읽기 < 반복 가능한 읽기 < 직렬화 가능 순으로 격리 수준이 높음
- 커밋되지 않은 읽기
    - 커밋이나 롤백 여부에 상관없이 다른 트랜잭션에서 조회 가능
    - 트랜잭션 작업이 완료되지 않았음에도 조회 가능
    - Dirty-Read : 트랜잭션A에서 update한 데이터가 커밋되지 않았음에도 트랜잭션B에서 조회해버림 → 트랜잭션A에서 롤백한다면 트랜잭션B는 데이터무결성이 깨진 데이터를 읽게 됨
    - Phantom-Read : 트랜잭션B에서 데이터를 조회 → 트랜잭션A에서 해당 데이터 지움 → 트랜잭션B는 지운 데이터를 조회해버림
- 커밋된 읽기
    - 커밋이 된 데이터만 읽음
    - 트랜잭션A에서 데이터 업데이트 후 커밋 완 → 트랜잭션B에는 아직 완료 ㄴㄴ 였다가 다시 조회하면 업데이트 된 데이터가 조회되어 다른 결과 발생
    - Non-Repeatable-Read : 같은 SELECT 조회문인데 다른 결과 발생
    - 실제 테이블 값이 아닌 이전 커밋된 데이터를 저장하는 UNDO 영역에서 가져옴

<aside>
📢 커밋되지 않은 읽기에서는 Dirty-Read, Non-Repeatable-Read, Phantom-Read가 발생할 수 있습니다. Dirty-Read는 트랜잭션A에서 업데이트한 데이터가 커밋되지 않았음에도 트랜잭션B에서 조회하여 데이터 무결성이 깨질 수 있는 문제입니다. Non-Repeatable-Read는 트랜잭션B에서 데이터를 조회했다가 트랜잭션A에서 데이터를 업데이트 했을 때 트랜잭션B에서 다시 데이터를 조회한다면 다른 결과가 나오는 문제입니다. Phantom-Read는 이미 지운 데이터가 조회되는 문제입니다.

</aside>

- 문제 해결 방법을 함께 말하는 게 좋아보임
- mysql 엔진 추가 질문도 나올 수 있음
- 네이버 면접 기출
- 락 개념에 대해 잘 알아야 하나…?

### 📌 데이터베이스 샤딩에 대해 설명해주세요.

- 각 DB 서버에 데이터를 분할하여 저장하는 방법 (DB 서버를 분할)
- 테이블을 특정한 기준으로 나눠서 저장하고 검색하는 개념
- 같은 테이블 스키마를 가진 데이터를 다수의 데이터베이스에 분산하여 저장하는 방법을 의미합니다.
- 장점
    - 스케일 아웃 가능
    - 스캔 범위를 줄여서 쿼리 속도 향상
    - 장애가 샤드 단위로 발생
- 단점
    - 프로그래밍 복잡도 증가
    - 여러 샤드에 걸친 데이터 조인하기 어려움

<aside>
📢 샤딩이란 여러 개의 데이터베이스 서버를 두어 데이터를 분산하여 저장하는 방식입니다. 스캔 범위를 줄여서 쿼리 속도를 향상할 수 있고 장애가 샤드 단위로 발생한다는 장점이 있지만 프로그래밍하기 복잡하고 여러 샤드에 걸친 데이터를 조인하기 어렵다는 단점이 있습니다.

</aside>

- 수평적 파티셔닝이랑 비교해서 설명하는 거 좋음

### 📌 인덱스가 뭔가요? 사용해 본 적 있나요? (유지연)

- 인덱스란? 추가적인 쓰기 작업과 저장공간을 활용하여 DB 조회 속도를 향상시키는 방법
- 장점
    - 검색 대상 레코드 범위를 줄여 검색 속도를 향상
    - 중복 데이터 방지 (특정 컬럼의 유일성 보장)
- 단점
    - 추가적인 저장 공간 필요
    - 삽입 수정 삭제 시 인덱스도 업데이트 필요
- 언제?
    - 대량의 데이터 검색 시
    - 정렬된 결과 출력 시
    - 조인 연산 수행 시
    - 유니크한 값을 가져올 때
    - 검색 빈도가 높을 때
    - Where절, 외래키, Join에 자주 사용되는 컬럼

<aside>
📢 인덱스란 추가적인 쓰기 작업과 저장 공간을 활용하여 데이터 검색 속도를 향상시키는 방법입니다. 검색 대상 레코드 범위를 줄여 검색 속도를 향상시키고 중복 데이터를 방지하는 장점이 있습니다. 다만 데이터베이스의 10-15퍼센트의 저장 공간이 필요하고 삽입, 수정, 삭제 시 인덱스의 추가적인 업데이트 작업도 필요하다는 단점이 있습니다.

</aside>

- 왜 안 썼는지 이유 말할 수 있기
- 자료구조에 대해서도 정리하면 좋을 거 같음
- 

### 📌 RDBMS vs NoSQL에 대해서 설명해 주세요. (유지연)

- RDBMS : 관계형 데이터베이스. 모든 데이터를 2차원 테이블 형태로 표현함. 외래키를 통해 테이블 간에 조인 가능
    - 장점
        - 정해진 스키마에 따라 데이터를 저장하여 명확한 데이터 구조 보장
        - 각 데이터를 중복없이 한번만 저장할 수 있음
    - 단점
        - 
- NoSQL : Not Only SQL. 테이블 간 관계를 정의하지 않음. Join 불가능.
    - Key-Value : 키와 밸류가 쌍으로 저장. 어떤 형태의 데이터도 가능. ex) 레디스, 다이나모
    - Document : 키와 도큐먼트. 객체와 유사하며 하나의 단위로 취급되어 저장. ex) 몽고디비
    - 장점
        - 자유로운 데이터 구조
        - 데이터 분산이 용이
    - 단점
        - 데이터 중복이 발생할 수 있음
    - 비정형 데이터를 다룰 때 사용. 데이터(json, xml)를 직렬화 하거나 역직렬화만 할 때. 아주 많은 양의 데이터를 저장해야 할 때.

<aside>
📢 RDBMS는 관계형 데이터베이스로 모든 데이터를 2차원 테이블 형태로 표현합니다. 외래키를 통해 테이블 간에 조인이 가능합니다. 장점으로는 정해진 스키마에 따라 데이터를 저장하므로 명확한 데이터 구조를 보장하고 각 데이터를 중복없이 한번만 저장할 수 있습니다. NoSQL은 낫온리에스큐엘로 테이블 간의 관계를 정의하지 않습니다. 데이터 구조가 자유롭고 데이터 분산이 용이하다는 장점이 있으나 데이터 중복이 발생할 수 있다는 단점이 있습니다. 키-밸류, 도큐먼트, 그래프 등의 저장방식이 있습니다.

</aside>

### 📌 정규화에 대해 아시는 만큼 설명해 주세요. (개념과 장단점 정도) (유지연)

- 이상현상이 있는 릴레이션을 분해하여 이상현상을 없애는 과정
- 테이블 간에 중복된 데이터를 허용하지 않도록 설계하는 방식
- 장점
    - 이상 현상 제거
    - 데이터 무결성 유지
- 단점
    - Join연산이 많아짐

<aside>
📢 정규화란 중복을 최소화하도록 설계된 데이터베이스로 이상현상이 있는 릴레이션을 분해하여 이상현상을 없애는 과정입니다. 데이터 무결성이 유지된다는 장점이 있으나 조인 연산이 많아진다는 단점이 있습니다.

</aside>

- 정규화 종류 설명하기
- 

### 📌 데이터 무결성에 대해 설명해주세요. (김은솔)

- 데이터의 정확성, 일관성, 유효성이 유지되는 것.
- 종류
    - 개체 무결성 : 기본키 제약. 기본키에 널값ㄴㄴ 유니크ㅇㅇ
    - 참조 무결성 : 외래키 제약. 널 가능. 참조 릴레이션의 기본키 값과 동일해야 함. 참조할 수 없는 값을 가질 수 없음
    - 도메인 무결성 : 필드의 무결성을 보장. 필드의 타입, 널값허용 등의 조건이 잘 적용되었는지 확인
    - Null 무결성, 고유 무결성, 키 무결성, 관계 무결성 등등
- 장점
    - 논리적 관계 유지
    - 에러 방지

<aside>
📢 데이터 무결성이란 데이터의 정확성, 일관성, 유효성이 유지되는 것으로 논리적 관계를 유지하고 에러를 방지하기 위해 필요합니다. 기본키에 대한 제약 조건인 개체 무결성, 외래키에 대한 제약 조건인 참조 무결성, 필드에 대한 제약 조건인 도메인 무결성 그리고 널, 고유, 키, 관계 무결성 등이 있습니다.

</aside>

### 📌 SQL 인젝션에 대한 설명 또는 대응했던 경험을 말해주세요. (김은솔)

- 데이터베이스를 대상으로 하는 공격. 사용자의 입력값이 서버측에서 코드로 실행되는 코드 인젝션 공격 기법 중 하나.
- 정보 유출, 원격 코드 실행, 인증 우회 등의 공격을 받을 수 있음
- 항상 참이 되는 구문 (OR ‘1’ = ‘1’)을 삽입하여 true로 만들고 뒤에 - - 를 입력하여 뒷 부분은 주석처리 되도록 함 → 로그인 그냥 뚫을 수 있음
- JPA는 내부적으로 파라미터 바인딩을 활용하고 있어 SQL 인젝션을 막아주고 있다.
- MyBatis : #{} 사용하면 파라미터가 String 형태로 들어옴, ${}는 파라미터 그대로 들어와서 위험함
- 블랙리스트, 화이트리스트 활용 : 블랙리스트는 금지어 만들기, 화이트리스트는 되는 언어만 허용하기

<aside>
📢 SQL 인젝션이란 데이터베이스를 대상으로 하는 공격으로 사용자의 입력값이 서버 측 코드로 실행되는 코드 인젝션 공격 기법 중 하나입니다. 항상 참이 되는 구문이나 주석 표시를 사용하여 정보 유출, 원격 코드 실행, 인증 우회 등의 공격을 합니다. JPA는 내부적으로 파라미터 바인딩을 활용하고 있어 SQL 인젝션을 막아주고 있습니다.

</aside>

- 종류별로 설명해서 좋음
- 서블릿 필터
- 필터 사용 경험 면접 기출!

### 📌 데이터베이스 뷰에 대해 설명해주세요. (김은솔)

- 사용자에게 접근이 허용된 자료만을 제한적으로 보여주기 위해 하나 이상의 기본 테이블로부터 유도된 이름을 가지는 가상 테이블
- 물리적으로 존재 ㄴㄴ. 쿼리문 자체를 저장
- 임시적인 작업을 위한 용도
- 장점
    - 논리적 데이터 독립성 제공
    - 동일 데이터에 대해 동시에 여러 사용자의 상이한 응용이나 요구를 지원 (특정 사용자만 특정 뷰에 접근할 수 있음 → 보안 강화)
- 단점
    - 독립적인 인덱스를 가질 수 없음
    - ALTER 안됨
    - 기본키를 포함하고 있어야 연산 가능

<aside>
📢 뷰는 다른 테이블에서 유도된 가상 테이블입니다. 물리적으로 존재하지 않으며 쿼리문 자체를 저장하여 정의된 쿼리에 따라 데이터를 표현합니다. 복잡한 SQL 쿼리를 뷰로 정의하여 간단한 쿼리로 동일한 결과를 얻을 수 있습니다.

</aside>

### 📌 DDL, DML, DCL에 대해 설명해주세요. (송채은)

- DDL
    - 데이터 정의어
    - CREATE, ALTER, DROP, TRUNCATE (데이터베이스, 테이블을 생성, 수정, 삭제하는 명령어)
- DML
    - 데이터 조작어
    - SELECT, INSERT, UPDATE, DELETE (데이터베이스에 입력된 데이터의 조회, 삽입, 수정, 삭제하는 명령어)
- DCL
    - 데이터 제어어
    - 데이터베이스에 접근하거나 객체에 권한을 주는 명령어
    - GRANT, REVOKE (권한 부여, 박탈)
- TCL
    - COMMIT, ROLLBACK (트랜잭션 저장, 취소)

<aside>
📢 DDL은 데이터 정의어로 데이터베이스, 테이블의 구조를 정의하는 명령어입니다. CREATE, ALTER, DROP, TRUNCATE가 있습니다. DML은 데이터 조작어로 데이터베이스에 입력된 데이터의 변형을 가하여 조작하는 명령어입니다. 셀렉트, 인설트, 업데이트, 딜리티드 등이 있습니다. DCL은 데이터 제어어로 데이터베이스에 접근할 수 있는 권한 부여에 관한 명령어입니다. 그랜트, 리보크, 커밋, 롤백 등이 있습니다.

</aside>

- 대상까지 말하면 좋을 거 같다

### 📌 지연로딩(Lazy)과 즉시로딩(Eager)에 대해 설명해주세요. (송채은)

- Fetch Type
    - JPA에서 엔티티를 조회할 때 연관관계에 있는 객체들을 어떻게 가져올 것인지 나타내는 설정값
- Eager
    - 데이터를 조회할 때 연관된 모든 객체의 데이터까지 한번에 불러옴
    - ManyToOne에서 디폴트값
    - 필요하지 않은 데이터까지 조회하느라 성능이 느려질 수 있음
    - N+1 문제가 발생할 수 있다. (한번 쿼리했는데 그 결과 개수만큼 추가적인 쿼리가 나가는 것)
- Lazy
    - 필요한 시점에 연관된 객체의 데이터를 불러오는 것
    - OneToMany에서 디폴드값
    - 엔티티를 조회하는 시점이 아닌 연결된 엔티티를 사용하는 시점에 쿼리가 나가도록 함

<aside>
📢 즉시로딩은 데이터를 조회할 때 연관된 모든 객체의 데이터까지 한번에 불러오는 방법입니다. 필요하지 않은 데이터까지 조회하느라 성능이 느려질 수 있고 N+1 문제가 발생할 수 있습니다. 지연로딩은 필요한 시점에 연관된 객체의 데이터를 불러오는 방법입니다. 주인 엔티티를 조회하는 시점이 아닌 연결된 엔티티를 사용하는 시점에 쿼리가 나가도록 합니다.

</aside>

### 📌 데이터베이스 클러스터링에 대해 설명해주세요. (송채은)

- DB를 여러 개의 서버가 나눠서 처리하는 방법
- 특징
    - 여러 데이터베이스 서버로 부하를 분산시켜 사용자의 요청을 더 많이 수용할 수 있다 (로드 밸런싱)
    - 여러 대의 데이터베이스 서버를 가지므로 높은 가용성을 보장한다. (가용성 : DB가 동작하고 있는 시간과 정지한 시간의 비율)
- Active 클러스터링
    - 서버 하나가 죽어도 다른 서버가 역할을 바로 수행하여 중단되지 않는다.
    - 병목현상이 발생될 수 있다. (전체 시스템의 성능이 하나의 구성 요소로 인해 제한을 받는 현상)
    - 두 대의 서버를 동시에 운용해야 하기 때문에 비용이 많이 든다.
- standBy 클러스터링
    - 하나만 액티브
    - 스탠바이를 액티브로 바꿀 때 fail over 동안에 데이터가 유실될 수 있음
- 마스터 슬레이브
    - 마스터에 작업하는 데이터를 슬레이브로 복제한다. (원본-백업)
    - 트래픽 분산 시 - 마스터 : 데이터 변경, 슬레이브 : 데이터 읽기

<aside>
📢 클러스터링이란 DB를 여러 개의 서버가 나눠서 처리하는 방법입니다. 데이터베이스 서버를 여러 개 둠으로써 부하를 분산시켜 사용자의 요청을 더 많이 수용할 수 있습니다. 액티브 클러스터링은 서버 하나가 죽어도 다른 서버가 역할을 바로 수행하여 무중단 서비스를 제공할 수 있다는 장점이 있지만 병목현상이 발생할 수 있고 스탠바이 클러스터링은 병목현상을 방지할 수 있지만 액티브로 전환할 때 데이터가 유실될 수 있습니다.

</aside>