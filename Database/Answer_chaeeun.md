# Database

: 통합하여 관리되는 데이터의 집합체

: DBMS(DataBase Management System)이라는 미들웨어에 의해 관리됨

</br>

> ## **키의 종류와 특징**
>
> - **슈퍼키(Super Key)**
>   - **유일성**을 만족하는 키
>   - 여러 개의 속성을 묶어 중복된 값을 가지지 않는다면 슈퍼키로 사용 가능
> - **후보키(Candidate Key)**
>   - **유일성**과 **최소성**을 만족하는 키
>   - 기본키가 될 수 있는 후보
> - **기본키(Primary Key)**
>   - 후보키에서 선택된 키 (따라서 유일성, 최소성 만족)
>   - 테이블에서 기본 키는 오직 1개
>   - NULL 값이 들어갈 수 없음
>   - 중복된 값을 가질 수 없음
> - **대체키(Surrogate Key)**
>   - 후보키 중 기본키로 선택되지 않은 키
>   - 대체키의 경우 NULL 값을 가질 수 있음
> - **외래키(Foreign Key)**
>   - 어떤 테이블의 기본키를 참조하는 속성
>   - 테이블 간의 관계를 나타내는 데 사용
>   - 부모테이블이 먼저 생성된 뒤 데이터를 넣고, 참조하는 자식 테이블이 다음에 생겨야함
>   - 부모테이블이 먼저 삭제된다면 자식테이블은 참조하는 것이 없기에 외래키 오류가 발생하므로, 부모테이블이 먼저 삭제될 수 없음
>
> ```
> - 유일성 : 하나의 키 값으로 튜플을 유일하게 식별할 수 있는 성질
> ex) 주민번호, 나이, 혈액형 속성이 존재할 때, 나이와 혈액형은 중복될 수 있는 속성이지만 주민번호는 고유한 값을 가지므로 유일성을 만족함
> ```
>
> ```
> - 최소성 : 키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성하는 성질
> ex) 하나의 테이블에 학번과 주민번호 속성이 존재할 때, 학번과 주민번호는 모두 유일성을 만족하는 속성이므로 공간 낭비가 발생함 → 최소성 만족하지 않음
> ```

</br>

> ## **트랜잭션의 정의와 특징**
>
> - 정의
>   - **데이터베이스의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위** 또는 **한번에 수행되어야 할 연산**
>   - 논리적 작업들을 모두 완벽하게 처리하는 기능 수행
>   - 작업을 처리하지 못한 경우, 이전 상태로 복구하여 작업의 일부만 적용되는 현상이 발생하지 않도록 만들어 주는 기능 수행
>   - 작업의 **완전성**을 보장
>   - 하나의 트랜잭션은 **Commit** 되거나 **Rollback** 된다.
>
> 
>
> - 특징
>
>   → 트랜잭션이 성공적으로 처리되어 데이터베이스의 **무결성과 일관성을 보장하기 위해** 아래 4가지 특징을 만족해야 함
>
>   (1) **원자성**(**A**tomicity)
>
>   ​	: 트랜잭션의 연산은 데이터베이스에 모두 반영되거나 아니면 전혀 반영되지 않아야함
>
>   (2) **일관성**(**C**onsistency)
>
>   ​	: 트랜잭션이 성공적으로 실행되면 일관성 있는 데이터베이스 상태를 유지해야 함
>
>   ​	: 시스템이 가지고 있는 고정요소는 트랜잭션 전과 후의 상태가 같아야 함
>
>   (3) **독립성**(**I**solation)
>
>   ​	: 트랜잭션 실행 도중 다른 트랜잭션의 영향을 받지 않아야 함
>
>   ​	: 실행 중인 트랜잭션이 완전히 완료될 때까지 다른 트랜잭션에서 수행 결과를 참조할 수 없음
>
>   (4) **지속성**(**D**urability)
>
>   ​	: 트랜잭션이 성공적으로 완료되면 해당 내용은 영구적으로 저장되어야 함
>
> 
>
> - 연산
>
>   - **Commit**
>
>     : 트랜잭션이 성공적으로 끝나고, 데이터베이스가 일관된 상태에 있을 때 갱신 연산이 완료된 것을 관리자에게 알려주는 연산
>
>   - **Rollback**
>
>     : 트랜잭션이 비정상적으로 종료되어 데이터베이스의 일관성을 깨뜨렸을 때, 트랜잭션의 일부가 정상적으로 처리되었더라도, 트랜잭션의 원자성을 구현하기 위해 트랜잭션이 행한 모든 연산을 취소하는 연산

</br>

> ## 정규화의 정의와 종류
>
> - 정의
>
>   - 하나의 릴레이션에 하나의 의미만 존재하도록 릴레이션을 분해하는 과정
>   - **데이터의 일관성, 최소한의 데이터 중복을 위한** 방법
>   - 삽입/갱신/삭제 시 발생할 수 있는 **이상 현상(Anomaly)을 방지하기 위해** 테이블의 구성을 논리적이고 직관적으로 작성
>   - 데이터베이스 구조 **확장 시 재디자인을 최소화**하기 위한 방법
>
>   ```
>   - 삽입 이상 : 데이터를 삽입할 때 의도하지 않은 데이터까지 삽입해야 테이블에 추가가 가능한 현상
>   - 갱신 이상 : 중복된 데이터 중 일부만 수정되어 데이터 모순이 일어나는 현상
>   - 삭제 이상 : 데이터를 삭제할 때 의도하지 않은 데이터까지 삭제되는 현상 
>   ```
>
>   → 장점 : 데이터베이스 변경 시 이상 현상 제거 가능, 데이터 구조의 안정성과 무결성을 유지할 수 있음
>
>   → 단점 : join 연산 증가로 응답 시간 증가
>
>    
>
> - 종류
>
>   - **제1 정규화**
>
>     - 도메인 제약 조건 만족
>     - 테이블의 칼럼이 하나의 값을 갖도록 테이블을 분해하는 것
>
>   - **제2 정규화**
>
>     - 부분적 함수 종속 제거
>
>     - **제1 정규화를 진행한 테이블에 완전 함수 종속을 만족하도록 테이블을 분해**하는 것
>
>       → 완전 함수 종속 : 기본키의 부분집합이 다른 값을 결정하지 않는 것
>
>   - **제3 정규화**
>
>     - 이행적 함수 종속 제거 (A → B 이고 B → C일 때 A → C 성립되는 경우를 제거)
>     - **제2 정규화를 진행한 테이블에 이행적 함수 종속을 제거하도록 테이블을 분해**하는 것
>
>   - BCNF 정규화
>
>     - A → B 일때 모든 결정자 A가 후보키가 되도록 분해
>     - 제3 정규화를 진행한 테이블에 모든 결정자가 후보키가 되도록 테이블을 분해하는 것

</br>

> ## 반정규화
>
> - 정의
>
>   - 정규화된 데이터 모델에서 중복, 통합, 분리 등을 수행하는 과정
>   - 데이터 조회 시, join으로 인한 성능 저하가 예상될 때 수행
>
>   → 장점 : 빠른 데이터 조회, 조회 쿼리의 단순화
>
>   → 단점 : 데이터 갱신, 삽입 비용이 높음, 데이터의 무결성을 해침, 저장 공간 확보 필요
>
> 
>
> - 종류
>
>   - **테이블 반정규화**
>
>     - `테이블 병합`
>
>       : 1:1 관계 테이블 병합
>
>       : 1:M 관계 테이블 병합
>
>       : 슈퍼/서브타입 테이블 병합
>
>     - `테이블 분할`
>
>       : 수직 분할(하나의 테이블의 속성을 분할하여 두 개 이상의 테이블로 분할)
>
>       : 수평 분할(하나의 테이블에 있는 튜플 값을 기준으로 테이블 분할)
>
>     - `테이블 추가`
>
>       : 중복 테이블 추가(원격 join 제거)
>
>       : 통계 테이블 추가(SUM, AVG 미리 수행)
>
>       : 이력 테이블 추가(자주 조회되는 튜플을 모은 별도 테이블 추가)
>
>       : 부분 테이블 추가(자주 조회되는 속성을 모은 별도 테이블 추가)
>
>   - **속성 반정규화**
>
>     - `중복 칼럼 추가` : join 감소
>     - `파생 칼럼 추가` : 값을 미리 계산하여 보관
>     - `이력 테이블 칼럼 추가` : 대량 이력 데이터 처리 시 기능성 칼럼 추가
>     - `PK에 의한 칼럼 추가` :여러 칼럼으로 이루어진 테이블 조인 시 단순성을 위해 인공키를 PK로 지정하여 활용
>     - `응용시스템 오작동을 위한 칼럼 추가` : 이전 데이터를 임시적으로 중복하여 보관
>
>   - **관계 반정규화**
>
>     - `중복 관계 추가` : 여러 경로를 거쳐 join 시 성능 저하를 막기 위한 관계 추가

</br>

> ## JOIN과 UNION
>
> - **JOIN**
>
>   : 둘 이상의 테이블을 연결하는 연산자
>
>   : 테이블이 적어도 하나의 속성을 공유하고 있어야 하며, 공유하는 속성을 PK 또는 FK 값으로 사용
>
>   `INNER JOIN` : 서로 연관된 내용만 조인하는 방법, A와 B의 교집합
>
>   `OUTER JOIN` : 한 쪽에는 데이터가 있고 반대 쪽에는 데이터가 없는 경우, 데이터가 있는 쪽의 내용을 전부 출력하는 방법, A와 B의 합집합
>
>   `LEFT JOIN`
>
>   `RIGHT JOIN`
>
> - **UNION**
>
>   : 두 개 이상의 쿼리 결과를 단일 결과로 합치는 연산자
>
>   : 결과가 단일 결과 세트이므로 튜플의 개수와 순서가 모든 쿼리에서 동일해야 함
>
>   : 데이터 형식이 호환되어야 함
>
>   `UNION ALL` : 중복 항목 포함
>
>   `UNION` : 중복 항목 제거
>
> → 테이블의 데이터를 연결한다는 점은 동일하나, JOIN은 컬럼이 추가되는 형식으로 데이터가 옆으로 연결되지만, UNION은 데이터가 추가되는 형식으로 아래에 연결된다는 점에서 차이가 있음

</br>

> ## 트랜잭션의 격리 수준
>
> : 여러 트랜잭션이 동시에 처리될 떄, 특정 트랜잭션이 다른 트랜잭션에서 변경/조회하는 데이터를 볼 수 있게 허용할지 여부를 결정하는 것
>
> 
>
> 1. **Read Uncommitted**
>    - COMMIT 되지 않은 데이터에 다른 트랜잭션이 접근할 수 있음
>    - COMMIT이나 ROLLBACK에 상관없이 현재의 데이터를 읽어옴
>    - ROLLBACK이 될 데이터도 읽어올 수 있음
>    - **DIRTY READ** 발생
>    - **NON-REPEATABLE READ** 발생
>    - **Phantom Read** 발생
>    - LOCK이 발생하지 않음
> 2. **Read Committed**
>    - COMMIT 된 데이터에 접근할 수 있음
>    - 구현 방식의 차이로 인해 쿼리를 수행한 시점의 데이터와 정확하게 일치하지 않을 수 있음
>    - **NON-REPEATABLE READ** 발생
>    - **Phantom Read** 발생
>    - LOCK이 발생하지 않음
>    - MySQL에서 많은 양의 데이터를 복제하거나 이동할 떄 해당 레벨 사용 추천
> 3. **Repeatable Read**
>    - Default 레벨
>    - SELECT 시 현재 시점의 스냅샷을 만들고 스냅샷을 조회함
>    - 동일 트랜잭션 내에서 일관성을 보장하나 새로운 레코드가 추가되는 경우 부정합 발생 가능
>    - **Phantom Read** 발생
> 4. **Serializable**
>    - 가장 강력한 레벨
>    - 트랜잭션을 순차적으로 수행
>    - 여러 트랜잭션이 동일한 레코드에 동시 접근할 수 없으므로 부정합 문제 발생하지 않음
>    - 트랜잭션이 순차적으로 처리되어야 하므로 처리 성능이 떨어짐
>    - **가장 안전**하지만 **성능 저하가 발생**하므로 극단적으로 안전한 작업이 필요한 경우에만 사용
>
> ```text
> - Dirty Read
> : 트랜잭션 A가 실행되고 COMMIT 되기 전에 트랜잭션 B가 실행됐을 때, A가 수행한 내용을 B가 확인할 수 있음(=유효하지 않은 데이터를 읽음)
> 
> - NON-REPEATABLE READ
> : 하나의 트랜잭션 내에서 동일한 SELECT 쿼리를 실행했을 때 항상 같은 결과를 보장해야한다는 REPEATABLE READ 정합성에 어긋남
> 
> - Phantom Read
> : SELECT 쿼리로 조회할 때 다른 트랜잭션에 의해 추가되거나 삭제 레코드가 발견되는 경우
> ```
>
> 
>
> ```text
> - LOCK
> : 데이터베이스에서 데이터의 동시성과 일관성을 유지하기 위해 사용하는 메커니즘
> : 다른 트랜잭션이 동일 데이터에 동시 접근하는 것을 제어하여, 데이터의 안정성과 정확성을 보장
> 
> (1) Shared Lock(공유락, LS) : 데이터를 읽을 때 사용됨, 다른 트랜잭션이 동시에 동일 데이터를 읽을 수 있지만 수정할 수는 없음
> (2) Exclusive Lock(배타락, LX) : 데이터를 수정할 때 사용됨, 락을 건 트랜잭션만 읽거나 수정할 수 있으며 다른 트랜잭션은 락이 해제될 때까지 접근이 차단됨
> ```

</br>

> ## 샤딩(Sharding)
>
> - 정의
>
>   - 각 DB 서버에서 데이터를 분할하여 저장하는 방식
>
> - 특징
>
>   - DB 트래픽을 분산할 수 있는 중요한 수단
>
>   - 장점
>
>     → 장애가 샤드 단위로 발생하기 때문에 전면 장애로 이어지지 않음
>
>     → 데이터를 병렬로 처리함으로써 확장성과 성능 향상
>
>     →  스캔 범위를 줄여 쿼리 반응 속도가 빠름
>
>   - 단점
>
>     →  프로그래밍 복잡도 증가
>
>     →  데이터가 한 쪽 샤드로 몰릴 경우, 무의미한 방식
>
>     → 한 번 샤딩을 사용한 후, 이전 구조로 돌아가기 힘듦
>
> - 종류
>
>   - `모듈러 샤딩` : PK를 모듈러 연산한 결과로 DB를 라우팅 하는 방식
>   - `레인지 샤딩` : PK를 범위 기준으로 DB를 특정하는 방식
>   - `디렉토리 샤딩` : 별도의 조회 테이블을 사용해 샤딩하는 방식
>
> - **수평적 파티셔닝과의 차이**
>
>   - `수평적 파티셔닝` : 동일한 DB 서버 내에서 테이블을 분할
>   - `샤딩` : DB 서버를 분할

</br>

> ## 인덱스
>
> - 정의
>   - 테이블을 처음부터 끝까지 검색하는 방법인 FTS(Full Table Scan)과는 달리 인덱스를 검색하여 해당 자료의 테이블에 접근하는 방법
>
> - 특징
>
>   - 인덱스를 설정하지 않아도 기본적으로 PK값이 인덱스로 설정
>
>   - 모든 속성에 인덱스를 사용한다면, 인덱스가 차지하는 용량이 커지므로 주의 필요
>
>   - 장점
>
>     →  항상 정렬된 상태를 유지하기 때문에, 빠른 검색 가능
>
>   - 단점
>
>     →  삽입, 삭제, 수정하는 경우에는 실행 속도 저하
>
> - DBMS에서의 인덱스 자료 구조
>
>   - **B+Tree 구조**
>     - 자식 노드가 2개 이상이 B-Tree를 개선시킨 구조
>     - B-Tree 리프 노드들을 LinkedList로 연결하여 순차 검색을 용이하게 함
>     - 해시테이블보다 나쁜 O(log2N)의 시간 복잡도를 갖지만 일반적으로 사용
>   - **해시테이블**
>     - 컬럼의 값으로 생성된 해시를 기반으로 인덱스를 구현
>     - 시간 복잡도 O(1)로 매우 빠른 검색 가능
>     - 부등호와 같은 연속적인 데이터를 위한 순차 검색이 불가능

</br>

> ## RDBMS와 NoSQL
>
> - **RDBMS**
>
>   - 모든 데이터를 2차원 테이블 형태로 표현
>
>   - 데이터 구조가 명확하고, 변경될 여지가 없고, **스키마**가 중요한 경우 사용
>
>   - 데이터 변경이 용이하기 때문에 관계를 맺고 있는 데이터가 자주 변경이 이루어지는 시스템에 적합
>
>   - 장점
>
>     → 스키마에 맞춰 데이터를 관리하기 때문에 데이터의 정합성 보장 가능(ACID 성립)
>
>   - 단점
>
>     → 시스템이 커질 수록 쿼리가 복잡해지고 성능이 저하됨
>
>     → Scale-out이 어려움, Scale-up만 가능
>
>     ```
>     - Scale-out : 서버를 추가하여 처리 능력을 향상하는 방법, 수평 스케일
>     - Scale-up : 고성능의 부품, 서버로 교환하는 방법, 수직 스케일
>     ```
>
> - **NoSQL**
>
>   - 데이터 간의 관계를 정의하지 않고, **컬렉션**이라는 형태로 데이터를 관리
>
>   - 정확한 데이터 구조를 알 수 없고, 데이터가 변경되거나 확장될 수 있는 경우 사용
>
>   - 데이터 변경이 자주 이루어지지 않는 시스템에 적합
>
>   - 데이터베이스를 Scale-out 해야하는 시스템에 적합
>
>   - 장점
>
>     → 스키마 없이 Key-Value 형태로 데이터를 관리하므로 자유로운 관리가 가능함
>
>     → 데이터 분산이 용이하여 성능 향상을 위한 Scale-up, Scale-out 가능
>
>   - 단점
>
>     → 데이터 중복 발생 가능성 多
>
>     → 중복된 데이터가 변경될 경우, 수정을 모든 컬렉션에서 수행해야 함
>
>     → 스키마가 존재하지 않기 때문에 명확한 데이터 구조를 보장하지 않아 데이터 구조 결정이 어려움

</br>

> ## 데이터의 무결성
>
> - 정의
>
>   - 데이터의 정확성, 일관성, 유효성을 유지하기 위해 가져야할 조건
>
> - 종류
>
>   - **개체 무결성**
>
>     : 모든 테이블이 PK로 선택된 컬럼을 가져야 함. PK는 고유한 값을 가져야하며 NULL 값은 허용되지 않음
>
>   - **참조 무결성**
>
>     : FK는 NULL 값 또는 참조하는 테이블의 PK 값이어야 함
>
>     : 참조 관계에 있는 두 테이블의 데이터가 항상 일관된 값을 갖도록 유지되는 것
>
>     ex) 부모 테이블에서 삭제된 튜플을 자식 테이블이 참조하는 경우 참조 무결성이 깨짐
>
>   - **도메인 무결성**
>
>     : 테이블에 존재하는 속성의 타입, NULL 값의 허용 등에 대한 사항을 정의하고 올바른 데이터가 입력 되었는지를 확인
>
>     ex) 나이 속성에 숫자가 아닌 문자열이 입력되는 경우 도메인 무결성이 깨짐
>
>   - **키 무결성**
>
>     : 한 릴레이션에 최소한 하나의 키가 존재해야 함

</br>

> ## SQL Injection
>
> - 정의
>
>   - 공격자가 악의적으로 SQL 구문을 삽입하여 데이터베이스를 비정상적으로 조작하는 코드 인젝션 공격 기법
>
> - 방어 방법
>
>   - 입력값을 검증하여 사용자의 입력이 쿼리에 동적으로 영향을 주는 경우, 입력된 값이 개발자가 의도한 값(유효값)인지를 검증
>
>   - 저장 프로시저를 사용함
>
>     → 저장 프로시저 : 사용하고자 하는 쿼리에 미리 형식을 지정하는 방법, 지정된 형식의 데이터가 아니면 쿼리가 실행되지 않기 때문에 보안성 향상

</br>

> ## 뷰(View)
>
> - 정의
>   - 직접 테이블에 접근하는 것이 아니라 테이블에서 사용자가 필요로 하는 부분만 선택하여 만들어 놓은 일종의 가상 테이블
>   - 접근의 용이성과 데이터베이스의 보안성을 위해 사용
>   - 임의의 뷰를 구성하여 별도의 이름을 붙이거나 접근 가능한 사람을 지정할 수 있음
>   - 단순 뷰의 경우 INSERT, UPDATE, DELETE를 자유롭게 사용할 수 있음
>   - UNION, GROUP BY, 함수 등을 사용한 뷰인 경우 INSERT, UPDATE, DELETE 사용 불가능
>
> ```sql
> CREATE VIEW [뷰 이름] AS SELECT [칼럼] FROM [테이블 이름] WHERE [조건];
> ```

</br>

> ## DDL, DML, DCL
>
> : 데이터베이스 언어의 종류
>
> - **DDL(Data Definition Language)**
>   - 데이터베이스 구조를 정의, 수정, 삭제하는 언어
>   - `CREATE` : 데이터베이스, 테이블 생성
>   - `ALTER` : 테이블 수정
>   - `DROP` :데이터베이스, 테이블 삭제, 삭제 후 되돌릴 수 없음
>   - `TRUNCATE` : 테이블 초기화, 인덱스를 포함한 데이터 삭제(테이블은 삭제할 수 없음), 용량 감소, 삭제 후 되돌리기 불가
> - **DML(Data Manipulation Language)**
>   - 데이터베이스 내의 자료 검색, 삽입, 갱신, 삭제하는 언어
>   - `SELECT` : 데이터 조회
>   - `INSERT` : 데이터 삽입
>   - `UPDATE` : 데이터 수정
>   - `DELETE` : 데이터 삭제, 용량 변화 없음, 삭제 후 되돌리기 가능
> - **DCL(Data Control Language)**
>   - 데이터베이스에서 사용자의 권한을 관리하거나 데이터 접근 권한을 제어하는 데 사용
>   - 데이터에 대해 무결성 유지, 병행 수행 제어, 보호와 관리를 위한 언어
>   - `GRANT` : 특정 데이터베이스 사용자에게 특정 작업에 대한 수행 권한을 부여
>   - `REVOKE` : 특정 데이터베이스 사용자에게 특정 작업에 대한 수행 권한을 삭제
> - **TCL(Transaction Control Language)**
>   - 데이터베이스의 트랜잭션을 관리하기 위해 사용
>   - 트랜잭션의 무결성을 보장
>   - 데이터베이스의 일관성 유지 목적으로 사용
>   - `COMMIT` : 트랜잭션의 작업을 영구적으로 저장
>   - `ROLLBACK` : 트랜잭션 시작점 이후에 이루어진 모든 변경 사항을 취소

</br>

> ## 지연로딩(Lazy)과 즉시로딩(Eager)
>
> : JPA에서 테이블 간 연관 관계는 객체의 참조를 통해 이루어지는데, 데이터베이스에서 참조하는 객체들의 데이터를 한 번에 가져오는 것은 비효율적이므로 Fetch Type을 활용하여 참조하는 객체들의 데이터를 가져오는 시점을 명시해줌
>
> - **지연로딩**
>
>   - 지연로딩이 설정되어 있는 **엔티티는 프록시로 조회**
>
>     → 프록시 : 실제 객체 대신 조회를 지연할 수 있는 가짜 객체, 참조를 보관 
>
>   - 이후 실제 객체를 사용하는 시점에 초기화가 되어 DB에 쿼리가 실행됨
>
>     → **프록시 객체의 초기화** : 실제 엔티티 객체를 생성
>
>   - 엔티티의 필드에 접근할 때 쿼리가 실행됨
>
>   - `@OneToMany` `@ManyToMany` 의 fetch 타입의 기본값
>
> - **즉시로딩**
>
>   - **엔티티를 즉시 조회**
>
>   - 대부분의 JPA 구현체에서 즉시로딩을 최적화하기 위해 join 쿼리 사용
>
>   - 예상하지 못한 쿼리가 발생할 가능성이 높음
>
>   - JPQL에서 N + 1문제 발생 가능
>
>     : 연관 관계가 설정된 엔티티를 조회할 경우, 조회된 데이터 갯수(N) 만큼 연관관계의 조회 쿼리가 추가로 발생하여 데이터를 읽어오는 현상
>
>   -  `@ManyToOne` `@OneToOne`의 fetch 타입의 기본값

</br>

> ## DB 클러스터링과 리플리케이션
>
> - **클러스터링**
>
>   - 여러 개의 DB를 **수평적인 구조로 구축**하는 방식
>
>   - **동기 방식**으로 사용
>
>   - 장점
>
>     → DB 간의 데이터를 동기화하여 항상 **일관성 있는 데이터**를 얻을 수 있음
>
>     → 하나의 DB에서 장애가 발생하여도 다른 DB를 사용하여 시스템을 운영할 수 있음 **(높은 가용성)**
>
>     → 하나의 DB에 몰리던 **부하를 분산**시킬 수 있음 (로드밸런싱)
>
>   - 단점
>
>     → 저장소 하나를 공유하면 **병목현상**이 발생할 수 있음
>
>     ​	전체 시스템의 성능 및 용량이 하나의 구성 요소로 인해 제한을 받는 현상
>
>     → 서버를 동시에 운영하기 위한 비용 발생
>
>   - 종류
>
>     - **Active - Active 클러스터링**
>
>       : 여러 개로 구성된 DB서버에서 각 서버를 Active(동작 중) 상태로 두는 방식
>
>       → 하나의 서버에 장애가 발생해도 다른 서버가 바로 역할을 수행하여 중단되는 시간이 없음
>
>       → 여러개의 서버가 같이 사용되어 CPU와 메모리 이용률을 늘릴 수 있음
>
>       → 병목현상 발생 가능
>
>     - **Active - Standby 클러스터링**
>
>       : 여러 개로 구성된 DB서버에서 하나를 Active 상태로 운영하고 나머지 서버를 Standby 상태로 두는 방식
>
>       : 운영되는 서버에 장애가 발생한 경우 Standby 상태인 다음 서버를 Active 상태로 전환
>
>       → 액티브 클러스터링에 비해 적은 비용
>
>       → Standby 서버가 Active로 전환되는 데 시간 소요
>
> 
>
> - **리플리케이션**
>
>   - 여러 개의 DB를 **수직적인 구조로 구축**하는 방식
>
>   - **비동기 방식**으로 사용
>
>   - 장점
>
>     → DB 요청의 60~80% 정도가 읽기 작업이기 때문에 성능을 높일 수 있음
>
>     → 비동기 방식으로 운영되어 **지연 시간이 거의 없음**
>
>   - 단점
>
>     → 노드 간 동기화가 보장되지 않아 일관성있는 데이터를 얻지 못할 수 있음
>
>     → Master DB가 다운되면 복구 및 대처가 까다로움

</br>

> ## 클러스터링 테이블
>
> : 특정 컬럼 값을 기준으로 동일한 값을 가진 하나 이상의 테이블의 레코드를 같은 장소에 저장하여 **데이터베이스 성능을 최적화하는 물리적 기법**
>
> : 관련 데이터를 가능한 가깝게 저장하여 조회 성능을 향상시키는 기술
>
> - 클러스터링 팩터
>   - 접근하려는 데이터들이 얼마나 같이 모아져 있는지를 판단하는 요소
>   - 데이터에 접근하기 위해 발생하는 블록들의 물리적인 엑세스 양을 좌우함
> - 종류
>   - 단일 테이블 클러스터링
>     - 단위 클러스터에 하나의 테이블 데이터만 저장
>     - 같은 클러스터 컬럼 값을 가진 레코드는 같은 장소에 저장되므로(물리적으로 가까운 위치) 넓은 범위의 데이터를 동시에 엑세스할 때, 검색할 때 주로 사용
>   - 다중 테이블 클러스터링
>     - 단위 클러스터에 두 개 이상의 테이블 데이터를 함께 저장
>     - 같은 클러스터 키 값을 가진 레코트는 같은 장소에 저장되므로 join 속도를 향상시키고자 할 때 주로 사용(쿼리 성능 향상)
>
> - 장점
>
>   → RDBMS의 최대 약점인 넓은 범위의 처리를 해결
>
>   → join 효율성을 크게 높여주므로 데이터 엑세스 시 효율적
>
> - 단점
>
>   → 클러스터링은 SELECT 의 효율을 높여줄 뿐 입력, 수정, 삭제의 경우 추가 부하 발생

----

</br>

> ## SELECT 쿼리의 수행 순서
>
> ```sql
> FROM, ON, JOIN > WHERE, GROUP BY, HAVING > SELECT > DISTINCT > ORDER BY > LIMIT
> ```

</br>

> ## 트리거(Trigger)
>
> : 특정 테이블에 대한 이벤트에 반응해 INSERT, DELETE, UPDATE 와 같은 DML 문이 수행되었을 때, 데이터베이스에서 자동으로 동작하도록 작성된 프로그램
>
> : 사용자가 직접 호출하는 것이 아닌, 데이터베이스에서 자동적으로 호출함

</br>

> ## Elastic Search의 키워드 검색과 RDBMS의 LIKE 검색
>
> - Elastic Search는 동의어, 유의어를 활용한 검색이 가능
>
>   비정형 데이터의 색인과 검색이 가능
>
>   역색인 지원으로 매우 빠른 검색 가능
>
> - RDBMS는 단순 텍스트매칭에 대한 검색만을 제공해 동의어나 유의어 같은 검색 불가능
>
>   MySQL 최신 버전에서 n-gram 기반의 Full-Text 검색을 지원하기는 하나, 한글 검색의 경우 아직 미숙

</br>

> ## 옵티마이저(Optimizer)
>
> : SQL을 가장 빠르고 효율적으로 수행할 최적의 경로를 생성해주는 DBMS 내부의 핵심 엔진