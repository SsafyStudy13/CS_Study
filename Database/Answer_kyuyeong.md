## 1. 스택과 큐의 차이점을 설명해주세요. (김은솔)
`스택`은 LIFO(후입선출) 원칙에 따라 객체가 삽입, 제거되는 선형 자료 구조입니다.  
오직 스택의 맨 위에서만 요소를 추가하고 제거할 수 있습니다. 이를 위해 스택에서는 리스트 내 마지막 요소를 가리키는 `top` 포인터를 사용합니다.  
`큐`는 FIFO(선입선출) 원칙에 따라 객체가 삽입, 제거되는 선형 자료 구조입니다.  
큐에서는 큐의 뒤에 원소를 삽입하는 `enqueue`, 큐의 맨 앞 항목을 제거하는 `dequeue` 작업을 수행합니다. 이를 위해 리스트 내 첫 번째 원소를 가리키는 `front` 포인터와 마지막 원소를 가리키는 `rear` 포인터를 사용합니다.  
`스택`은 가장 최근에 추가된 항목을 제거하고, `큐`는 가장 오래전에 추가된 항목을 제거합니다.  
이러한 특성 때문에 스택은 백트래킹이 필요한 작업에, 큐는 순서대로 실행해야 하는 작업에 자주 사용됩니다.  
- [Stacks and Queues (cmu.edu)](https://www.andrew.cmu.edu/course/15-121/lectures/Stacks%20and%20Queues/Stacks%20and%20Queues.html)
- [Difference between Stack and Queue Data Structures - GeeksforGeeks](https://www.geeksforgeeks.org/difference-between-stack-and-queue-data-structures/)

## 2. Array와 LinkedList의 차이점을 설명해주세요. (김은솔)
`배열`은 연속된 메모리 공간에 데이터들을 저장해 특정 인덱스의 요소에 더 빠르게 접근할 수 있는 자료 형태를 말합니다.  
크기가 고정되어 있고, `컴파일 시간`에 **메모리에 할당**됩니다.  
`링크드리스트`는 요소들이 *연속적인 위치에 저장되지 않아* 조금 더 **유연한 형태**고, 다음 요소를 참조할 수 있는 추가적인 포인터와 함께 데이터가 저장되어 배열보다 더 많은 메모리 공간이 필요합니다.  
리스트 크기는 동적으로 늘어나거나 줄어들 수 있고 `런타임 시간`에 **메모리에 할당**됩니다.  
**요소를 접근**하는데 있어 `배열`은 연속적으로 저장되므로 기본 주소만 알면 모든 요소의 주소를 쉽게 계산할 수 있어 $O(1)$의 시간이 소요됩니다. 반면 `링크드리스트`는 원하는 요소를 찾기 위해 헤드 노드부터 순회해야 하기 때문에 최악의 경우 모든 노드를 순회하게 되고, 따라서 평균적으로 $O(n)$의 시간이 소요됩니다.  
배열의 경우 요소가 연속적으로 저장되기 때문에 더 우수한 `캐시 지역성(Cache Locality)` 을 가져 캐시를 이용해 더 빠른 접근이 가능합니다.  
또한 요소를 삽입/삭제할 때, 맨 앞에 있는 경우 `링크드리스트`가 $O(1)$로 더 빠르고, 마지막에 있는 경우 보통 배열이 $O(1)$로 더 빠르고, 중간에 있는 경우 둘 다 $O(n)$의 시간이 소요됩니다.  
- [https://www.geeksforgeeks.org/linked-list-vs-array/amp/](https://www.geeksforgeeks.org/linked-list-vs-array/amp/)
- [Array vs linked list | What's the difference? - javatpoint](https://www.javatpoint.com/ds-array-vs-linked-list)
- [Why Arrays have better cache locality than Linked list? - GeeksforGeeks](https://www.geeksforgeeks.org/why-arrays-have-better-cache-locality-than-linked-list/)

## 3. Array와 ArrayList의 차이점을 설명해주세요. (김은솔)
`배열`은 Java에서 기본적으로 제공되는 자료형인 반면, `어레이리스트`는 `Java Collections Framework`에서 제공되는 클래스입니다.  
`배열`은 한 번 생성되면 크기를 변경할 수 없는 반면, `어레이리스트`는 동적으로 크기가 조절됩니다. 또한, `배열`은 선언시 **사이즈를 지정**해야하고, `어레이리스트`는 지정하지 않아도 됩니다.  
`어레이리스트`는 **내부적으로 `배열`을 사용**하기 때문에, 배열이 거의 다 사용되었을 때 확장하는 *`크기 조정 작업`을 제외*하고는 삽입/삭제와 같은 **주요 연산 속도가 비슷**합니다.  
또한 `배열`은 ***객체** 뿐만 아니라* **`원시 타입`** 을 **저장**할 수 있지만, `어레이리스트`의 경우 **`제네릭`** 을 사용해 *내부 배열의 원소 타입을 지정*하기 때문에 **원시 타입을 저장할 수 없습니다**. 대신 원시 타입의 **래퍼 클래스**를 제네릭으로 설정해 저장할 수는 있습니다. 이후 Java의 `오토박싱`을 활용해 코드상으로는 원시 타입을 저장하는 것 처럼 할 수 있습니다.  
그리고 `배열`은 **직접** 배열의 요소에 접근할 수 있지만, `어레이리스트`의 경우 클래스 내 **함수를 호출**해야 리스트의 요소에 접근하거나 요소를 추가할 수 있습니다.  
또한, `배열`은 `java.util.Arrays` 클래스의 정적 메서드를 이용해 정렬, 채우기 등의 작업을 할 수 있고, `어레이리스트`는 `java.util.Collections` 클래스의 정적 메서드를 이용해 정렬과 같은 작업을 수행할 수 있습니다.  
- [Array vs ArrayList in Java - GeeksforGeeks](https://www.geeksforgeeks.org/array-vs-arraylist-in-java/)
- [Difference between Array and ArrayList - Javatpoint](https://www.javatpoint.com/difference-between-array-and-arraylist)

## 4. Heap에 대해 설명해주세요. (박규영)
알고리즘에서 `힙`이란, 모든 노드에 대해 `부모 노드가 자식 노드보다 크거나 같다(또는 작거나 같다)` 라는 `힙 속성`을 만족하는 `완전 이진 트리` 자료구조를 말합니다.  
힙은 주로 *부모 노드가 자식보다 크거나 같은* `최대 힙`, *자식보다 작거나 같은* `최소 힙` 두 종류로 나뉩니다.  
힙은 **가장 큰 원소**를 찾는데 $O(1)$의 시간이 들며, 원소의 **삽입/삭제**에 $O(logN)$ 의 짧은 시간이 소요된다는 특징이 있습니다.  
이러한 힙의 특성을 활용해, 가장 작은(또는 가장 큰) 요소가 항상 맨 앞에 존재하는 `우선순위 큐`를 구현하는데 자주 사용됩니다.  
뿐만 아니라 힙의 가장 큰 원소를 계속해서 꺼내어 $O(nlogn)$ 만에 정렬하는 `힙소트 알고리즘`이나, `프림`, `다익스트라`와 같은 **최단경로 알고리즘**에서도 중요하게 사용됩니다.  
힙은 이러한 힙 구조를 유지하기 위해 주로 `Heapify`라는 연산을 구현해 사용하는데, 이는 **현재 노드와 두 자식 노드의 값을 비교**하여 부모보다 더 나은 값이 있다면 **바꾸고** 해당 노드 위치로 **재귀적으로 호출**되는 연산입니다.  

## 5. 버블소트와 퀵소트에 대해 간단히 설명해주시고, 비교해주세요. (박규영)
`버블 소트`는 배열 내 원소를 반복적으로 탐색하면서, 인접한 원소 쌍을 비교하고 순서를 바꿔야 한다면 교체하는 작업을 배열이 완전히 정렬될 때 까지 반복하는 정렬을 말합니다.  
`버블 소트`는 배열 내 가장 작은 원소가 마지막에 있는 최악의 경우이거나 평균인 경우 $O(n)^2$ 의 시간 복잡도를 갖고, 배열이 이미 정렬 되어있는 최상의 경우 $O(n)$ 의 시간 복잡도를 갖습니다.  
`퀵 소트`는 배열에서 `한 요소(pivot)`를 **선택**해 해당 요소보다 **작은 원소를 왼쪽**에, **큰 원소를 오른쪽**으로 옮긴 뒤, 피벗을 제외한 왼쪽 / 오른쪽 **서브 리스트들을 다시 반복해 정렬**하는 방식을 말합니다.  
`퀵 소트`는 평균적으로 $O(nlogn)$ 의 시간 복잡도를 갖지만, 모든 원소가 같아 pivot이 배열을 분할할 수 없거나, 이미 정렬된 배열에서 pivot을 최솟값으로 선택하는 최악의 경우(역정렬의 경우 가장 큰 요소 선택) $O(n^2)$ 의 시간 복잡도를 갖게 됩니다.  

## 6. 최소 신장 트리(MST)에 대해 설명해주세요. (박규영)
`최소 신장 트리(MST, Minimum Spanning Tree)` 란, 무향 가중치 그래프에서 (*n개의 정점과 n-1개의 간선으로 이루어진*) `신장 트리`를 구성하는 간선들의 **가중치의 합이 최소**가 되는 `신장 트리`를 말합니다.  
가중치의 합이 최소가 되어야하기 때문에 사이클이 발생하지 않습니다.  
최소 신장 트리를 생성하는데에는 그리디 기법을 사용하며, 주로 `크루스칼 알고리즘`과 `프림 알고리즘`을 사용합니다.  
**`크루스칼 알고리즘`** 의 경우, 간선들을 ***가중치**에 따라* **오름차순으로 정렬**한 뒤 가중치가 낮은 간선부터 **n-1개의 간선**을 **선택**해 `최소 신장 트리`를 만드는 방법을 말합니다. 시간복잡도는 $O(ElogE)$ 인데, 이는 우선순위 큐를 사용하기 때문입니다.  
**`프림 알고리즘`** 의 경우, 하나의 정점에서 연결된 간선 중 가중치가 최소인 간선을 하나씩 선택하며 `최소 신장 트리`를 만드는 방법을 말합니다. 시간 복잡도는 인접 리스트를 사용할 경우 $O(V^2)$ , 이진 힙을 사용하는 경우 $O(E * logV)$까지 줄일 수 있습니다.  

## 7. Java의 Arrays.sort와 Collections.sort에서 사용되는 정렬 알고리즘에 대해 설명해주세요. (전재우)
**`Arrays.sort`** 의 경우 배열이 `원시타입 배열`인지, `객체 배열`인지에 따라 다른 알고리즘을 사용합니다.  
`원시타입 배열`의 경우 두개의 피벗을 사용하는 **`이중-피벗 퀵소트`** 를 사용해 정렬합니다. 따라서 평균 시간 복잡도는 $O(nlog(n))$ 입니다.  
`객체 배열`의 경우 **`팀 소트(TimSort)`** 라는 `머지 소트`와 `삽입 정렬`을 활용한 정렬을 사용해 정렬합니다. 평균 시간 복잡도는 $O(nlog(n))$ 로 `퀵소트`와 동일하지만 퀵소트가 최악의 경우 $O(n^2)$ 인것과 달리, `팀 소트`는 최악의 경우에도 $O(nlog(n))$ 입니다.  
**`Collection.sort`** 의 경우, `Arrays.sort`로 객체 배열을 정렬하는 것과 마찬가지로, `머지 소트`나 `팀 소트`를 사용합니다. 이는 `퀵 소트`는 **non-stable**하고, `팀 소트` 또는 `머지 소트`는 **`stable`** 하기 때문입니다. `non-stable`한 정렬은 `동일하지만 구분 가능한 요소`에 대해 기존과 다르게 순서를 바꿀 수 있습니다. 하지만 `Collections.sort()`는 stable한 정렬을 사용해 정렬의 결과로 동일한 요소의 순서를 바꾸지 않습니다.  
- [Arrays (Java Platform SE 8 ) (oracle.com)](https://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#sort-java.lang.Object:A-)
- [Difference Between Arrays.sort() and Collections.sort() | Baeldung](https://www.baeldung.com/java-arrays-collections-sort-methods)
- [Time Comparison of Arrays.sort(Object[]) and Arrays.sort(int[]) | Baeldung](https://www.baeldung.com/arrays-sortobject-vs-sortint)
- [Collections (Java Platform SE 8 ) (oracle.com)](https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#sort-java.util.List-)
- [List (Java Platform SE 8 ) (oracle.com)](https://docs.oracle.com/javase/8/docs/api/java/util/List.html#sort-java.util.Comparator-)
- [Quicksort vs. Timsort | Baeldung on Computer Science](https://www.baeldung.com/cs/quicksort-vs-timsort)

## 8. 그래프와 트리의 차이점에 대해 설명해주세요. (전재우)
`그래프`는 노드와 노드들을 연결하는 간선으로 이루어진 자료구조를 말합니다. 그래프는 계층구조가 아니기 때문에 별도로 부모-자식 개념이 없고, 다른 노드와 연결되지 않거나 한 개 이상의 노드와 연결될 수 있습니다.  
`트리`는 노드와 간선으로 이루어진 계층적 자료구조를 말합니다. 각 노드는 하나 이상의 자식을 가질 수 있으나, 부모 노드는 하나여야 합니다.  
`그래프`는 사이클을 가질 수 있지만, `트리`는 사이클이 존재하지 않습니다.  
`그래프`는 연결되지 않은 노드가 있을 수 있지만, `트리`는 언제나 모두 연결되어 있어야 합니다.  
따라서 `그래프`의 경우 간선의 개수가 자유롭지만, `트리`의 노드가 N개라면 간선은 N-1개 존재해야 합니다.  
`그래프`는 간선의 방향성이 있거나 없을 수 있지만, `트리`의 간선은 방향성이 존재해야 합니다.  
- https://www.geeksforgeeks.org/difference-between-graph-and-tree/amp/

## 9. 해시테이블에 대해서 설명해주세요. (전재우)
`해시 테이블`은 `키-값` 쌍을 빠르게 삽입/조회/제거하는데 사용되는 자료구조 입니다.  
키는 해시 함수를 거쳐 배열의 인덱스로 변환되며, 해당 인덱스 위치에 값을 저장하게 됩니다.  
해시 테이블에는 `적재율(Load Factor)`이라는 개념이 존재하는데, 테이블 크기 대비 얼마나 많은 요소들이 저장되어있는지를 나타내는 값입니다. 적재율이 높으면 테이블이 복잡해지고, 해시 함수가 *둘 이상의 키에 대해 동일 인덱스를 생성*하는 `해시 충돌`이 발생할 수 있습니다. 충돌이 발생하는 경우 탐색과 삭제 연산이 최악의 경우 $O(K)$(K = 키의 개수) 만큼 걸리게 됩니다.  
충돌이 발생하지 않는다면, 해시 테이블의 탐색/삽입/삭제 연산은 $O(1)$에 수행됩니다.  
해싱 함수로는 키를 테이블 크기 N으로 나눈 나머지 값을 쓰거나, 곱셈을 통해 해싱 할 수 있습니다.  
충돌이 발생할 경우 테이블의 다음 빈 공간을 찾아 처리하는 `오픈 어드레싱`, 테이블의 각 슬롯에 링크드리스트를 사용하는 `분리 체인`, 슬롯 사이의 거리를 비교해 이상적인 슬롯에 더 가깝게 하는 `로빈 후드 해싱` 과 같은 기법을 사용합니다.                                                                                                                                             
## 10. HashMap과 Hashtable의 차이점에 대해 설명해주세요. (유지연)
`해시 맵(HashMap)`과 `해시 테이블(HashTable)` 모두 키-값 쌍을 해시 테이블에 저장하는 `Map` 구현체입니다. 이후 키로 사용되는 값을 해시 함수를 통해 인덱스로 변환하고, 해당 인덱스를 통해 테이블 내 값에 접근합니다.  
`해시 맵`은 모든 메서드가 **`동기화`되지 않아** thread-safe하지 않고, 따라서 멀티 스레드 환경에서 추가적인 동기화 코드 없이는 **여러 스레드 간에 안전하게 공유할 수 없습니다**. 하지만 그 때문에 `해시 테이블` 보다 **더 빠르고**, **메모리를 적게** 사용합니다.  
thread-safe한 해시 맵을 만들기 위해선 `Collections.synchronizedMap()` 를 사용해야 합니다.  
반면, `해시 테이블`은 모든 메서드가 `동기화`되어있고, 따라서 thread-safe하며, 다른 **여러 스레드들과 공유할 수 있습니다**. 즉, 한 번에 **한 스레드만** `해시 테이블`에 **접근 가능**합니다. 이 때문에 `해시 맵` 보다 느릴 수 있습니다.  
`해시 맵`은 하나의 `null 키`와, 여러 `null 값`들을 **`허용`** 하는 반면, `해시 테이블`은 `null 키`나 `null 값`을 **허용하지 않습니다**.  
이는 `해시 테이블`에서 키로 사용되는 객체들이 `hashCode`와 `equals` 함수를 구현해야 하는데, null 값 은 그럴 수 없기 때문입니다.  
`해시 맵`은 `Iterator`를 활용해 값을 순회하고, `해시 테이블`은 `Enumerator`를 활용해 값을 순회합니다.  
- [Differences between HashMap and HashTable in Java - GeeksforGeeks](https://www.geeksforgeeks.org/differences-between-hashmap-and-hashtable-in-java/)
- [Differences Between HashMap and Hashtable in Java | Baeldung](https://www.baeldung.com/hashmap-hashtable-differences)

## 11. Priority Queue에 대해 설명해주세요. (유지연)
`우선순위 큐`란, 우선순위 값에 따라 요소를 정렬하는 큐의 일종을 말합니다.  
우선순위 큐의 각 요소에는 연결된 우선순위 값이 있고, 우선순위가 높을 수록 큐의 앞에 위치하게 됩니다. 큐에 요소를 삽입 시 우선순위 값에 따라 적절한 위치에 삽입됩니다.  
`우선순위 큐`는 `배열`, `링크드리스트`, `힙` 등을 사용해 구현할 수 있고, 주로 `힙`을 활용해 구현합니다.  
`우선순위 큐`는 `다익스트라 알고리즘`에서 현재 노드에서 갈 수 있는 가장 가까운 노드를 찾는데 $O(ElogV)$ 가 들도록 단축하고, `A* 검색 알고리즘`에서 $f(x)=g(x) + h(x)$가 작은 값부터 탐색하는데 시간을 단축해 알고리즘의 효율성을 개선하는데 사용됩니다.  
- [What is Priority Queue | Introduction to Priority Queue - GeeksforGeeks](https://www.geeksforgeeks.org/priority-queue-set-1-introduction/)

## 12. 이진트리의 전위, 중위, 후위 순회에 대해 설명해주세요. (유지연)
이진트리의 `전위(Pre-order) 순회`의 경우, 트리를 (1) 루트 노드 - (2) 왼쪽 노드 - (3) 오른쪽 노드 순서대로 탐색하는 순회를 말합니다.  
`중위(In-order) 순회`는 트리를 (1) 왼쪽 노드 - (2) 루트 노드 - (3) 오른쪽 노드 순서대로 탐색하는 순회를 말합니다.  
`후위(Post-order) 순회`는 트리를 (1) 왼쪽 노드 - (2) 오른쪽 노드 - (3) 루트 노드 순서대로 탐색하는 순회를 말합니다.  

## 13. List와 Set의 차이점에 대해 설명해주세요. (송채은)
`List`는 삽입 순서가 유지되고, 중복이 허용되며, 위치, 즉 인덱스를 통해 요소를 접근하고 삽입하는게 가능한 `Collection` 의 하위 인터페이스 입니다. 구현체로는 `ArrayList`, `LinkedList`, `Vector` 등이 있습니다.  
`Set`은 삽입 순서가 유지되지 않고, 중복이 허용되지 않으며, 요소에 대한 위치 액세스가 허용되지 않는 `Collection` 의 하위 인터페이스 입니다. 구현체로는 `HashSet`, `LinkedHashSet` 이 있습니다. *다만* `LinkedHashSet`의 경우 링크드리스트를 활용해 **순서가 유지**됩니다.  
- [Difference Between List and Set in Java - GeeksforGeeks](https://www.geeksforgeeks.org/difference-between-list-and-set-in-java/)
- [Set vs List in Java | Baeldung](https://www.baeldung.com/java-set-vs-list)
- [LinkedHashSet (Java Platform SE 8 ) (oracle.com)](https://docs.oracle.com/javase/8/docs/api/java/util/LinkedHashSet.html)

## 14. B-Tree에 대해 설명해주세요. (송채은)
이진 트리를 확장해 한 노드가 가질 수 있는 자식 노드의 갯수가 2개 이상인 `자가 균형 이진 검색 트리(Self Balancing Binary Search Tree)`의 일종이며, 각 노드가 갖고있는 키 들이 정렬되어 있는 자료구조 입니다.  
다른 `자체 균형 이진 검색 트리`와 달리, B 트리는 DB, File System과 같이 큰 데이터 블록을 읽고 써야하는 스토리지 시스템에 적합합니다.  
모든 노드는 최대 m개의 자식이 존재하는 m-ary tree이며, `내부 노드`, `루트 노드`, `리프 노드`로 구성됩니다.  
`내부 노드`는 적어도 하나의 자식을 갖는 노드로, *리프 노드와 루트 노드를 제외한* **모든 노드**입니다. 하위 포인터, 데이터 포인터, 검색 키의 순서 집합으로 표현됩니다.  
각 내부 노드의 키는 해당 노드의 서브트리를 나누는 기준값으로 사용됩니다.  
각 내부 노드는 최소 절반 이상 채워져있기 때문에, 두 절반이 가득 찬 내부 노드를 하나로 병합하거나, 하나의 완전한 노드를 두개의 노드로 나눌 수 있어 추후 B 트리 속성을 유지하기 위해 트리를 조절할 수 있습니다.  
`루트 노드`는 내부 노드와 동일하게 자식 수에 상한은 있지만 하한은 없어, 자식이 없을 수도 있습니다.  
`리프 노드`는 모두 같은 레벨에 존재하며, 값을 갖고 있습니다.  
키들이 정렬되어 있어 순차적 순회에 유용하고, 한 노드에 여러 키를 저장할 수 있어 더 얉은 높이를 가질 수 있기 때문에 동일한 삽입/삭제/검색 시간 복잡도를 갖습니다.  
또한 `자체 균형 이진 검색 트리`의 일종이기 때문에 항상 최적의 높이를 유지해 최악의 경우에도 $O(logN)$을 유지하도록 보장합니다.  
다만 균형 유지를 위해 더 많은 정보를 저장해야 해 공간 복잡도가 올라가고, 삽입/삭제 연산 이후 균형 유지를 위한 작업을 수행해 오버헤드가 발생할 수 있습니다.  

## 15. 트라이 자료구조에 대해 설명해주세요. (송채은)
`트라이(Trie)`는 k-ary(각 노드의 자식이 k개 이하인) **`검색 트리` 의 일종**으로, 집합에서 특정 키를 저장하고 검색하는데 사용됩니다.  
대량의 문자열을 저장하는데 사용되며, 패턴 매칭을 효율적으로 수행할 수 있는 자료구조 입니다.  
문자열들을 저장할 때, 접두사를 공유하는 모든 문자열들이 그 접두사에 해당하는 공통 노드에서 비롯되어야한다는 개념으로 데이터들을 저장합니다.  
만약 `이진 검색 트리`를 사용했다면 키를 검색하는데 $O(M * log N)$ (M = 최대 문자열 길이, N = 트리의 키의 수)의 시간 복잡도를 갖지만, `트라이`를 사용하면 $O(M)$ 시간 내에 키를 검색할 수 있습니다.  
`트라이`는 전화번호, 사전 단어 자동 완성, 또는 맞춤법 검사 등의 기능을 구현하는데 주로 사용됩니다.  
- [Trie | (Insert and Search) - GeeksforGeeks](https://www.geeksforgeeks.org/trie-insert-and-search/)