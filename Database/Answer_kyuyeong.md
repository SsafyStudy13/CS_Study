## 1. 키의 종류 5가지와 각각 특징을 설명하세요. (전재우)
DB 키로는 후보키, 슈퍼키, 기본키, 대체키, 외래키 총 5개가 존재합니다.  
`후보키`는 릴레이션에 있는 속성 중 유일성과 최소성을 만족하는 속성 부분집합을 의미합니다.  
여기서 `유일성`이란 릴레이션 내 모든 튜플에 대해 해당 키가 유일하고 식별가능해야하다는 것이고, `최소성`은 유일성을 지닌, 둘 이상의 속성으로 이뤄진 부분집합에서 어느 한 속성이 제외되면 튜플이 유일성이 깨져야한다는 것입니다. 모든 릴레이션은 하나 이상의 후보키를 반드시 가져야하며, 튜플이 삽입,변경되어도 후보키의 성질은 유지되어야 합니다.  
`슈퍼키`는 유일성은 만족하고, 최소성은 만족하지 못하는 속성의 집합입니다.  
`기본키`는 후보 키 중 설계자가 지정한 키를 말하며, 개체 식별자의 역할을 담당해 해당 속성은 Null값을 가질 수 없습니다.  
`대체키`는 기본키로 지정되지 않은 후보키를 말합니다.  
`외래키`는 다른 릴레이션의 기본키를 참조하는, 즉 해당 기본키 값과 대응되는 키를 말합니다.  
#### 참고
- [Types of Keys in Relational Model (Candidate, Super, Primary, Alternate and Foreign) - GeeksforGeeks](https://www.geeksforgeeks.org/types-of-keys-in-relational-model-candidate-super-primary-alternate-and-foreign/)
- [키 (Key) (ktword.co.kr)](http://www.ktword.co.kr/test/view/view.php?m_temp1=5422)

## 2. 트랜잭션의 특징 4가지를 설명하세요. (전재우)
트랜잭션의 특징으로는 원자성, 일관성, 격리성, 영속성으로 총 4가지가 있습니다.  
**`원자성`** 은 트랜잭션이 부분적으로 실행되거나 중단되지 않아야하고, 완료되어 모두 반영되거나 전혀 반영되지 않아야 함(All or Nothing)을 뜻합니다.  
**`일관성`** 은 트랜잭션이 성공적으로 완료되면 DB는 항상 일관된 상태를 유지해야함을 뜻합니다. 즉, 트랜잭션 전/후 모두 데이터 제약 조건을 만족해야 합니다.  
**`격리성`** 은 실행중인 트랜잭션의 중간 결과에 다른 트랜잭션이 접근할 수 없어야 함을 뜻합니다. 즉 한 트랜잭션이 다른 트랜잭션의 작업에 끼어들어서는 안되어야 합니다.  
**`영속성`** 은 트랜잭션이 성공적으로 완료되면, 그 결과는 영속적입니다. 시스템은 어떠한 경우에도 완료된 결과를 DB에 영원히 반영해 영속성을 보장해야 합니다.  
#### 참고
- [[DB] 트랜잭션(transaction)이란? (tistory.com)](https://dkswnkk.tistory.com/555)

## 3. 반정규화에 대해 설명하세요. (전재우)
`반정규화` 또는 역정규화는 정규화된 엔티티, 속성, 관계에 대해 성능 향상이나 개발 운영의 단순화를 목적으로 중복, 통합, 분리 등을 수행하는 기법을 말합니다.  
정규화로 데이터가 분산되어 디스크 I/O량이 많아지고, 데이터 처리 경로가 길어져 조인시 성능저하가 발생하는 경우 반정규화를 고려하게 됩니다.  
반정규화를 통해 성능 향상, 관리 효율성 증대의 이점을 얻을 수 있지만, 데이터의 일관성과 정합성이 떨어지고 이로인해 시스템의 안정성을 해칠 수 있습니다.  
반정규화 기법으로는 `테이블 병합`, `테이블 분할`, `중복 테이블 추가`, `컬럼 중복화`, `중복관계 추가` 가 있습니다.  
#### 참고
- [반정규화개요 | 지식덤프 (jidum.com)](http://www.jidum.com/jidums/view.do?jidumKindCd=Da&jidumId=144)

## 4. Join과 Union의 차이에 대해 설명해주세요.
`Join`은 두 개 이상의 테이블을 연결해 모든 가능한 행의 조합(카테시안 곱)을 구한 뒤 그 중 조인 조건을 만족하는 행을 추출합니다.  
`Union`은 두 쿼리 결과를 연결한 뒤 중복 행을 제거해 하나의 결과로 결합합니다.  
Join은 기준이 되는 속성(조인 조건)을 기준으로 새로운 열로 결합되지만, Union은 새로운 행으로 결합됩니다.  
따라서 Union을 수행할 경우 각 쿼리의 **열의 수와 순서**가 동일해야 하며, 각 열은 **호환되는 데이터 형식**을 가져야 합니다.
#### 참고
- [MySQL : JOIN (vs UNION) (velog.io)](https://velog.io/@msung99/MySQL-JOIN)
- [UNION(Transact-SQL) - SQL Server | Microsoft Learn](https://learn.microsoft.com/ko-kr/sql/t-sql/language-elements/set-operators-union-transact-sql?view=sql-server-ver16)

## 5. 커밋되지 않은 읽기(read uncommitted)와 커밋된 읽기(read committed)에서 발생할 수 있는 문제점에 대해 설명해주세요.
'커밋되지 않은 읽기' 격리 수준의 경우 다른 트랜잭션이 갱신중인 커밋하지 않은 데이터를 읽을 수 있는 격리 수준입니다.  
따라서 한 트랜잭션이 다른 트랜잭션으로부터 커밋되지 않은 값을 읽는 `더티 리드` 문제, 같은 데이터를 한 트랜잭션 내에서 여러 번 읽었을 때 값이 다른 `반복 불가능한 조회`문제, 같은 조건에 대한 조회를 한 트랜잭션 내에서 여러 번 수행 했을때 이전에 존재하던 값이 없어지거나 새로 생겨나는 `팬텀 리드`문제가 발생할 수 있습니다.  
'커밋된 읽기' 격리 수준의 경우 다른 트랜잭션이 커밋 완료된 트랜잭션의 변경사항만 읽을 수 있는 격리 수준입니다. 이 역시 병행 트랜잭션에서 발생할 수 있는 `반복 불가능한 조회`, `팬텀 리드` 문제가 발생할 수 있습니다.  
### 문제 해결 방법
`더티 리드` 문제를 해결하기 위해서는 'Read Committed' 이상의 격리 수준을 사용하거나, MVCC와 같은 병행 제어 기법을 통해 직렬가능성이 보장되는 버전의 데이터를 트랜잭션에게 보여주므로써 해결할 수 있습니다.  
`반복 불가능한 조회` 문제를 해결하기 위해서는 'Repeatable Read' 이상의 격리 수준을 사용해 트랜잭션의 읽기가 끝날 때 까지 해당 데이터에 대한 갱신, 삭제를 제한하여 해결할 수 있습니다.  
`팬텀 리드` 문제를 해결하기 위해서는 'Serializable Read' 격리 수준을 사용하거나, InnoDB의 경우 index-row lock과 gap lock을 결합한 next key lock을 사용해 이를 해결합니다.  
#### 참고
- [database - Non-Repeatable Read vs Phantom Read? - Stack Overflow](https://stackoverflow.com/questions/11043712/non-repeatable-read-vs-phantom-read)
- [MySQL :: MySQL 8.0 Reference Manual :: 17.7.4 Phantom Rows](https://dev.mysql.com/doc/refman/8.0/en/innodb-next-key-locking.html)
- [Transaction Isolation Levels in DBMS - GeeksforGeeks](https://www.geeksforgeeks.org/transaction-isolation-levels-dbms/)
- [트랜잭션 격리 수준 (techcourse.co.kr)](https://tecoble.techcourse.co.kr/post/2022-11-07-mysql-isolation/)
- [MySQL :: MySQL 8.3 Reference Manual :: 17.7.2.3 Consistent Nonlocking Reads](https://dev.mysql.com/doc/refman/8.3/en/innodb-consistent-read.html)

## 6. 데이터베이스 샤딩에 대해 설명해주세요.
데이터베이스에 저장된 데이터를 샤드라고 하는 더 작은 청크로 분할해 여러 데이터베이스에 분산 저장하는 수평적 확장 방식을 말합니다.  
서비스가 확장되면서 데이터베이스도 함께 확장되며, 일정 크기에 다다르면 더 이상 확장하기 힘들어지고, 병목 현상이 일어나는 문제가 발생하게 됩니다.  
이때 데이터베이스를 샤딩하므로써 데이터 처리 성능 향상은 물론 분산 저장되므로 특정 DB의 장애가 DB 전체의 장애로 이어지지 않게 되는 이점이 있습니다. 하지만 그만큼 데이터를 찾을때 여러 샤드에서 조합 해야하는 경우 과정이 복잡해지고, 데이터가 특정 샤드에 집중될 경우 해당 샤드의 과부하로 성능이 떨어질 수 있습니다.  
샤딩 기법으로는 샤드 키(보통 PK)에 모듈러 연산을 거친 결과를 토대로 DB를 특정하는 `모듈러 샤딩`과 샤드 키의 범위를 기준으로 DB를 특정하는 `레인지 샤딩` 이 있습니다.  
#### 참고
- [Sharded MySQL Cluster 도입 배경과 개발기 (부제: 우당탕탕 좌충우돌 개발기) (gmarket.com)](https://dev.gmarket.com/61#%EC%83%A4%EB%94%A9%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80)
- [데이터베이스 샤딩이란 무엇인가요? - DB 샤딩 설명 - AWS (amazon.com)](https://aws.amazon.com/ko/what-is/database-sharding/)
- [DB분산처리를 위한 sharding | 우아한형제들 기술블로그 (woowahan.com)](https://techblog.woowahan.com/2687/)
- [글로벌 칼럼 | DB 분산 처리 기법 '샤딩', "웬만하면 하지 마라" - ITWorld Korea](https://www.itworld.co.kr/news/200134)

## 7. 인덱스가 뭔가요? 사용해 본 적 있나요? (유지연)
`데이터베이스 인덱스`는 테이블 내 데이터 조회 속도를 향상시키기 위해 사용하는 자료구조 입니다. 테이블 내 특정 레코드의 주소값을 알려주는 용도로 사용되며, 이를 통해 기존의 경우 선형시간이 소요되던 탐색을 더 빠르게 수행할 수 있습니다. 하나 이상의 열을 사용해 만들 수 있으며, 기본 키 컬럼의 경우 자동으로 인덱스가 생성됩니다.  
인덱스를 구현하는데 사용하는 자료구조로는 `Hash Table`, `B Tree`, `B+ Tree`가 주로 사용됩니다.   
`Hash Table`의 경우 해시 함수의 특성 때문에 비교 연산시에는 좋지만, 정렬되지 못해 순서와 관련해 비교할때 효율적이지 못하다는 단점이 있습니다.  
`B Tree`의 경우 B+ Tree와 달리 리프 노드끼리 연결되어 있지 않고, 내부 노드에도 값이 존재해 범위 쿼리나 정렬과 같은 작업에 있어 성능적 열위에 있어 `B+ Tree`가 주로 사용됩니다.  
프로젝트에서 기본 키를 지정해 기본 인덱스를 암시적으로 쓴 적은 있지만, 직접적으로 지정해 사용한 경험은 없습니다.  
#### 참고
- [[Database] 인덱스(index)란? - MangKyu's Diary (tistory.com)](https://mangkyu.tistory.com/96)
- [DB Index 입문 (techcourse.co.kr)](https://tecoble.techcourse.co.kr/post/2021-09-18-db-index/)
- [Database index - Wikipedia](https://en.wikipedia.org/wiki/Database_index#Primary_index)
- [[DataBase] DB 성능을 위한 Index (brunch.co.kr)](https://brunch.co.kr/@skeks463/25)

## 8. RDBMS vs NoSQL에 대해서 설명해 주세요. (유지연)
`RDBMS`는 테이블이라는 열과 행으로 구성된 관계형 데이터로 정보를 관리하는 DBMS를 의미합니다.  
데이터에 대한 스키마를 사전에 정의해야 데이터를 작성할 수 있으며, 키를 사용해 여러 테이블들을 연결해 관계를 형성하여 정보를 저장할 수 있습니다.  
테이블이라는 직관적이고 단순한 구조를 사용해 편리하고, 트랜잭션의 ACID를 준수해 데이터의 유효성을 보장하고, 기존 시스템에 영향 없이 필요할 때 테이블이나 관계를 추가,삭제하는 등 유연성이 좋습니다.  
그러나 고정된 스키마를 사용해 추후 구조 수정이 힘들고, 시스템 규모가 커지면 Join 문이 복잡한 쿼리가 만들어 질 수 있습니다.  
`NoSQL`은 별도로 고정된 스키마가 존재하지 않는 비 관계형 DBMS를 의미합니다. NoSQL은 데이터 모델에 따라 `키-값`, 테이블, 열 등의 형태로 저장하는 `와이드-컬럼`, `키-문서`, 노드와 노드 간 관계로 저장하는 `그래프` 저장소 등의 유형이 있습니다.  
고정된 스키마가 존재하지 않으므로 비정형 데이터를 빠르게 저장할 수 있고, 분산 시스템이기 때문에 데이터가 다양한 서버에 복제, 저장되어 가용성과 신뢰성이 유지되며 수평적 확장이 용이합니다.  
다만 관계를 사용하지 않아 조인 연산을 사용할 수 없고, 트랜잭션의 완결성, 즉 ACID를 보장하지 않는다는 단점이 있습니다.  
#### 참고
- [관계형 데이터베이스(RDBMS)란 무엇인가요?  |  Google Cloud](https://cloud.google.com/learn/what-is-a-relational-database?hl=ko)
- [NoSQL 데이터베이스란? | IBM](https://www.ibm.com/kr-ko/topics/nosql-databases)
- [NoSQL이란 무엇인가? 대량데이터 동시처리위한 DBMS 종류와 특징 | 인사이트리포트 | 삼성SDS (samsungsds.com)](https://www.samsungsds.com/kr/insights/1232564_4627.html)
- [NoSQL이란 무엇인가? | Oracle 대한민국](https://www.oracle.com/kr/database/nosql/what-is-nosql/)

## 9. 정규화에 대해 아시는 만큼 설명해 주세요. (개념과 장단점 정도) (유지연)
`정규화`란 관계형 데이터 모델에서 데이터의 중복성을 제거해 이상 현상을 막고, 데이터의 일관성, 정확성을 유지하기 위해 손실없이 분해하는 과정을 말합니다. 정규화 과정을 통해 릴레이션 조작 시 발생할 수 있는 이상 현상을 막고, 데이터 구조의 일관성, 정확성을 유지할 수 있지만 데이터가 분산되어 여러 데이터를 써야 할 경우 Join 연산이 발생해 성능이 저하될 수 있습니다.  
정규화 단계에는 원자화를 거치는 `1정규형`, 부분 함수 종속 제거를 거치는 `제2정규형`, 이행함수 종속 제거를 거치는 `제3정규형`, 결정자 후보 키가 아닌 함수 종속을 제거하는 `보이스-코드 정규형`, 다중 값 종속 제거를 거치는 `4정규형`, 조인 종속 제거를 거치는 `5정규형`이 있습니다.

## 10. 데이터 무결성에 대해 설명해주세요. (김은솔)
`데이터 무결성`이란 데이터가 전송, 저장, 처리되는 모든 생애주기에서 변경이나 손상 없이 완전성, 정확성, 일관성을 보장하는 특성을 말합니다.  
데이터베이스에서는 무결성 제약 조건을 부여해 데이터에 대한 결점과 부정합이 없음을 보증합니다.  
관계형 데이터베이스의 경우 키를 기반으로 하는 개체 무결성 제약과 참조 무결성 제약, 그리고 도메인 무결성 제약이 존재합니다.  
`개체 무결성`은 기본 키에 속하는 속성의 값은 언제나 고유해야 하며, Null 값을 가질 수 없다는 제약입니다. 이를 만족하지 못하면 tuple을 식별할 수 없게됩니다.  
`참조 무결성`은 외래 키는 참조할 수 없는 값을 가질수 없다는 제약입니다. 즉, 다른 테이블과 연관된 데이터에 변경이 생겨도 참조 관계가 유지되어야 한다는 것 입니다. 따라서 외래 키의 값은 피참조 관계에 존재하는 값이거나 Null 이어야 합니다.  
`도메인 무결성`은 열의 값이 일관성을 가져야 하며, 규칙에 부합해야 한다는 조건입니다. 즉, 자료형이나 값의 범위가 정해진 제한을 만족해야 한다는 것입니다.  
#### 참고
- [데이터 무결성 | TTA정보통신용어사전](https://terms.tta.or.kr/dictionary/dictionaryView.do?subject=%EB%8D%B0%EC%9D%B4%ED%84%B0+%EB%AC%B4%EA%B2%B0%EC%84%B1)
- [무결성 제약조건 (ktword.co.kr)](http://www.ktword.co.kr/test/view/view.php?no=610)

## 11. SQL 인젝션에 대한 설명 또는 대응했던 경험을 말해주세요. (김은솔)
`SQL 인젝션`은 응용 프로그램의 보안 취약점을 이용해 악의적인 SQL 구문을 삽입, 실행시켜 서버의 데이터베이스에 접근해 정보 탈취, 조작 등의 행위를 하는 공격을 말합니다.  
Form을 이용한 인증의 취약점을 노려 인증을 우회하는 `Form SQL 인젝션`, Union 연산자를 이용해 쿼리의 결과를 다른 쿼리 결과에 결합시키는 `Union SQL 인젝션`, 쿼리에 대한 참/거짓을 파악할 수 있는 취약점이 존재할 경우 이를 활용해 의도치 않은 SQL 문을 실행하도록 하는 `Blind SQL 인젝션` 등이 있습니다.  
이러한 SQL 인젝션 공격을 막기 위해선 바인딩 매개 변수 방식, 즉 PreparedStatement를 사용하거나, 사용자로 입력받는 값들을 체크하고 필터링하거나, Java의 경우 Servlet Filter를 적용해 방어할 수 있습니다.  
#### 참고
- [SQL 삽입 - 위키백과, 우리 모두의 백과사전 (wikipedia.org)](https://ko.wikipedia.org/wiki/SQL_%EC%82%BD%EC%9E%85)
- [SQL 인젝션 (SQL Injection) - MDN Web Docs 용어 사전: 웹 용어 정의 | MDN (mozilla.org)](https://developer.mozilla.org/ko/docs/Glossary/SQL_Injection#%EC%98%88%EB%B0%A9_%EB%B0%A9%EB%B2%95)

## 12. 데이터베이스 뷰에 대해 설명해주세요. (김은솔)
`데이터베이스 뷰`는 물리 테이블 또는 다른 뷰를 이용해 만들 수 있는 논리 테이블을 말합니다.  
논리적 데이터이므로 데이터베이스에 영향 없이, 원하는 행이나 컬럼을 선택해 만들 수 있습니다.  
선택된 데이터만 접근할 수 있어 **보안성**이 좋고, 복수 테이블에 존재하는 원하는 데이터를 Join을 이용해 미리 만들어 놓으면 **실제 질의시 단순한 질의를 사용할 수 있다**는 장점이 있습니다.  
다만, 뷰를 한 번 만들면 **구조를 변경할 수 없으며**, 논리적 데이터이기 때문에 **인덱싱이 불가능**합니다. 또한, 뷰의 내용에 대해 **삽입, 삭제, 변경에 여러 제약**이 존재합니다.  
#### 참고
- [데이터베이스 뷰 - IBM Documentation](https://www.ibm.com/docs/ko/mfci/7.6.2?topic=structure-views)

## 13. DDL, DML, DCL에 대해 설명해주세요. (송채은)
`DDL`은 `데이터 정의어`를 뜻하며, 이는 테이블과 같은 **데이터 구조를 생성, 변경, 삭제**하는 등의 작업에 사용하는 명령어 집합입니다.  
DDL의 대상으로는 **도메인, 스키마, 테이블, 뷰, 인덱스**가 있으며, 이들에 대해 CREATE를 통해 생성, ALTER를 통해 수정, DROP을 통해 삭제하거나, TRUNCATE를 통해 내용을 삭제할 수 있습니다.  
`DML`은 `데이터 조작어`를 뜻하며, 데이터베이스에 저장된 **자료들을 입력, 수정, 삭제, 조회**하는 언어입니다.  
SELECT, INSERT, UPDATE, DELETE 문을 통해, 테이블 내 칼럼에 데이터를 조회, 추가, 갱신, 삭제 할 수 있습니다.  
`DCL`은 `데이터 제어어`를 뜻하며, 데이터베이스 관리자가 **사용자에게** 데이터베이스에 접근하거나 수정하는 등의 작업에 대해 **권한을 부여하거나 회수**하는 제어용 언어입니다.  
GRANT를 이용해 사용자에게 특정 작업에 대한 권한을 부여할 수 있고, REVOKE를 이용해 부여한 권한을 회수할 수 있습니다.  

## 14. 지연로딩(Lazy)과 즉시로딩(Eager)에 대해 설명해주세요. (송채은)
즉시 로딩의 경우, 데이터 초기화가 즉시 수행되는 디자인 패턴이며, 지연 로딩의 경우 가능한 동안 객체의 초기화를 지연시킬 때 사용하는 디자인 패턴입니다.  
`즉시 로딩` 방식을 사용할 경우, 데이터를 로드하면 그와 관련된 모든 객체들도 로드해 메모리에 저장합니다. 이 때문에 초기 로딩 시간이 길어지지만, 초기화 지연으로 인한 성능 이슈가 없습니다.  
다만 객체와 관련된 엔티티들이 즉시로딩으로 설정된 경우, 그러한 엔티티 수 만큼 조인이 발생하고, 연관된 엔티티들을 불러오기 위해 추가적으로 쿼리가 나가는 N+1 문제가 발생하게 됩니다.  
`지연 로딩` 방식을 사용할 경우, 접근자나 다른 메서드를 사용해 명시적으로 호출할 때만 초기화되고 이전에는 프록시 객체로 존재하게 됩니다. 이 때문에 초기 로딩 시간이 더 빠르고, 메모리 사용량이 적지만 초기화가 일어나는 원치 않는 순간에 성능에 영향이 있을 수 있습니다.  
JPA에서 기본적으로 `OneToMany`,` ManyToMany`은 지연 로딩, `OneToOne`, `ManyToOne`은 즉시 로딩을 사용합니다.  
#### 참고
- [[JPA] 즉시 로딩과 지연 로딩(FetchType.LAZY or EAGER) (tistory.com)](https://ict-nroo.tistory.com/132)
- [Eager/Lazy Loading in Hibernate Baeldung](https://www.baeldung.com/hibernate-lazy-eager-loading)
  
## 15. 데이터베이스 클러스터링에 대해 설명해주세요. (송채은)
`데이터베이스 클러스트링`이란 데이터 접근 성능을 향상시키기 위해 저장공간에 레코드가 집중 저장되도록 할당하는 물리적 설계 기법을 말합니다.  
자주 사용되거나, 빈번하게 조인이 일으키는 테이블 내 데이터를 같은 공간에 저장되도록해 검색 효율을 높일 수 있습니다.  
다만 입력, 수정, 삭제에 대해서는 부하가 증가합니다.  
클러스터링 방법으로는 하나의 클러스터에 한 테이블만 저장해 처리 범위가 넓을 경우 효과적인 `단일 테이블 클러스터링`, 하나의 클러스터에 여러 테이블을 저장해 조인이 많을 경우 효과적인 `다중 테이블 클러스터링` 방법이 존재합니다.  
#### 참고
- [데이터베이스 DB 파티셔닝과 클러스터링 - ChoiLog (choimon.github.io)](https://choimon.github.io/database/clustering-partitioning/#%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0%EB%A7%81-clustering)
- [클러스터링 테이블 | 지식덤프 (jidum.com)](http://jidum.com/jidums/view.do?jidumId=10)
