# Spring

### 스프링

- java 기반의 웹 어플리케이션을 개발할 때 사용하는 프레임워크

### 1. 스프링에서 빈을 등록하는 방법에 대해 설명해주세요. (유지연)

- **빈(Bean)**
    - **스프링에서 관리하는 자바 POJO 객체**
    - POJO : 순수한 자바 객체. 어떠한 기술 규약이나 환경에 종속적이지 않은 객체
        - 장점 : 의존성 관리가 용이 / 빈으로 등록된 객체는 기본적으로 스코프가 싱글톤 / 라이프사이클 인터페이스 지원
- **스프링 컨테이너**
    - **POJO 객체를 관리함**
    - Bean 객체를 key-value 형식으로 저장
- 왜?
    - 객체 간 의존관계를 관리하기 위해
- Bean을 수동으로 등록하는 방법
    - 설정 **클래스** 파일에 **@Configuration** 적용 (빈 객체가 **싱글톤**으로 등록됨을 보장)
    - 내부에서 스프링 빈으로 등록할 **메서드**에 대해 **@Bean** 어노테이션 적용
    - 스프링 컨테이너는 @Configuration이 붙어있는 클래스를 찾아 파싱 후 @Bean이 붙은 오브젝트를 빈 객체로 등록
- Bean을 자동으로 등록하는 방법
    - 스프링에서는 **컴포넌트 스캔**을 이용해서 **@Component**가 붙은 모든 오브젝트를 빈으로 자동 등록함
    - @Controller, @Service, @Repository는 모두 Component를 포함하고 있음
- @Bean의 경우 메서드에 적용. **개발자가 직접 변경이 어려운 대상**에 사용하는 걸 권장 (외부 라이브러리)
- @Component의 경우 클래스에만 사용. **개발자가 직접 변경이 가능한 대상**에 사용

<aside>
📢 빈을 등록하는 방법 2가지
1. 설정 클래스 파일에 @Configuration 어노테이션을 적용하고 스프링 빈으로 등록할 메서드에 @Bean 어노테이션을 적용하는 방법
2. @Component 어노테이션을 적용하여 컴포넌트 스캔을 통해 빈을 자동으로 등록하는 방법

</aside>

### 2. DI에 대해 설명해주세요. (유지연)

- DI : 의존성 주입
    - 스프링 컨테이너에서 **객체 빈을 먼저 생성**해두고 생성한 객체를 **지정한 객체에 주입**하는 방식
    - 객체 자체가 코드 상에서 객체 생성에 관여하지 않아도 되기에 **객체 사이의 의존도를 낮출 수 있음**
    - **스프링 컨테이너**에서 객체의 생명주기를 관리하며 객체의 **의존관계 관리**
    - 의존성 주입을 사용하면 **유연하고 확장성**이 뛰어난 코드 작성 가능
- 의존성 주입 방식
    - **필드 주입**
        - **클래스에 선언된 필드에 생성된 객체를 주입**
        - @Autowired 어노테이션을 주입할 필드 위에 명시
        - 코드가 간결하지만 외부에서 변경하기 힘듦
        - 프레임워크에 의존적
    - **수정자 주입**
        - **클래스의 수정자를 통해서 의존성을 주입**
        - setter
        - set메서드를 public으로 열어둬야 하기에 언제 어디서든 변경이 가능한 단점
    - **생성자 주입**
        - **클래스의 생성자를 통해서 의존성을 주입**
        - 인스턴스가 생성될 때 1회 호출되는 것이 보장됨 (불변 객체 보장)
        - final 키워드 사용
        - 클래스 내 생성자가 한 개, 주입받을 객체가 Bean 등록 → @Autowired 생략 가능
        - lombok 라이브러리를 통해 더 간편하게 작성 가능
        - @RequiredArgsConstructor로 필드를 포함한 생성자를 포함시켜주고 @Autowired 키워드를 생략해서 가독성이 좋은 코드로 사용 가능
        - 스프링에서 권장하는 방식
            - 객체가 생성되는 시점에 생성자를 호출하여 최초 1회만 주입
            - **불변 객체 보장**
                - final로 선언 → 객체가 변할 일 없음
                - 클래스가 생성되는 시점에 포함된 객체들도 반드시 생성되기 때문에 객체가 비어있을 가능성 배제
            - **순환 참조 문제 방지**
                - 순환 참조 : 두 객체가 각각 서로를 필드에 포함하여 참조하고 있는 상태
                - 필드, 수정자주입은 실제 메소드가 호출되었을 때 런타임에러와 함께 문제 발생. 미리 예측 어려움
                - 생성자 주입은 스프링 어플리케이션이 구동되는 순간 에러 발생. 컴파일 때 에러 발생하여 쉽게 추적 가능. 미리 예방 가능
            - **테스트 용이**
                - 단위 테스트를 진행할 때 순수 자바 코드로 테스트 가능. 필드 주입을 사용하는 경우에 순수 자바 코드에서는 DI가 이루이지지 않기 때문에 필드가 null 상태가 되어 에러가 발생
        
        <aside>
        📢 의존성 주입은 필요한 객체를 직접 생성하는 것이 아닌 외부로부터 객체를 받아 사용하는 것이다. 의존성 주입을 이용해서 객체의 의존성을 낮추어 **유연**하고 **확장성**있는 코드 개발이 가능하다. 의존성 주입에는 **필드 주입, 수정자 주입, 생성자 주입** 세 가지 방식이 있다. **객체의 불변성 보장**, **순환 참조 에러 방지**, **테스트 용이** 와 같은 이유 때문에 생성자 주입이 가장 권장된다.
        
        </aside>
        
    

### 3. Spring Filter와 Interceptor에 대해 설명하고, 사용 예시를 설명해주세요. (유지연)

- 필터
    - 디스패처 서블릿에 요청이 전달되기 전/후에 url 패턴에 맞는 모든 여청에 대해 부가 작업을 처리할 수 있는 기능을 제공
    - 스프링 컨테이너가 아닌 톰캣과 같은 웹 컨테이너에 의해 관리. 스프링 범위 밖에서 처리
    - 서블릿 컨테이너에서 관리
    - 메서드
        - javax.servlet의 Filter 인터페이스 구현(init, doFilter, destroy)
- 인터셉터
    - 디스페처 서블릿이 컨트롤러를 호출하기 전/후에 인터셉터가 가로채는 요청과 응답을 참조하거나 가공할 수 있는 기능을 제공
    - 스프링 컨테이너에서 관리
    - org.springframework.web.servlet의 HandlerInterceptor 구현 (preHandel, postHandle, afterCompletion)
- 필터와 인터셉터의 차이
    - 필터는 Request와 Response를 조작할 수 있지만 인터셉터는 조작할 수 없다
    - **필터**는 기본적으로 Spring과 무관하게 **전역적으로 처리해야 하는 작업**들을 처리할 수 있다. 인터셉터보다 앞단에서 동작하기 때문에 보안 검사를 하여 올바른 요청이 아닐 경우 차단할 수 있다. (ex. 보안 및 인증/인가, 모든 요청에 대한 로깅 또는 검사, 이미지/데이터 압축 및 문자열 인코딩, Spring과 분리되어야 하는 기능)
    - 인터셉터에서는 **클라이언트의 요청과 관련되어 전역적으로 처리해야 하는 작업**들을 처리할 수 있다. 컨트롤러로 넘겨주기 위한 정보를 가공하기에 용이하다. (AccessToken 정보 파싱, API 호출에 대한 정보들을 로깅 또는 검사)
    
    <aside>
    📢 필터는 특정 요청과 컨트롤러에 관계없이 전역적으로 처리해야 하는 작업이나 웹 어플리케이션에 전반적으로 사용되는 기능을 구현할 때 적용하고, 인터셉터는 클라이언트의 요청과 관련되어 전역적으로 처리해야 하는 작업을 처리할 때 사용합니다. 필터는 Request, Response를 조작할 수 있지만 인터셉터는 조작할 수 없다는 차이가 있습니다.
    
    </aside>
    

### 4. PSA에 대해 설명해주세요. (박규영)

- Portable Service Abstraction
- **환경의 변화와 관계없이 일관된 방식의 기술로의 접근 환경을 제공하는 추상화 구조**
- 특정 클래스가 추상화된 상위 클래스를 일관되게 바라보며 하위 클래스의 기능을 사용하는 것
- Spring에서 동작할 수 있는 라이브러리들은 POJO 원칙을 지키기 위해 PSA 형태의 추상화가 되어있다.
- 왜?
    - 어떤 서비스를 이용하기 위한 접근 방식을 일관된 방식으로 유지하여 애플리케이션에서 사용하는 기술이 변경되더라도 최소한의 변경만으로 변경된 요구사항을 반영하기 위해 사용
    - **요구사항 변경에 유연하게 대처 가능**
- **Spring Web MVC, Spring Transaction, Spring Cache, Spring Data, 메일 서비스** 등

### 5. 빈의 스코프에 대해 설명해주세요. (박규영)

- **빈이 사용되어지는 범위**
- **앱이 구동되는 동안 한 개만 만들어서 쓸 건지, HTTP 요청마다 생성해서 쓸 건지 등을 결정하는 것**
- 종류
    - **싱글톤**
        - 기본 스코프. **스프링 컨테이너 시작과 종료까지 유지되는 가장 넓은 범위의 스코프**
        - **항상 같은 인스턴스의 빈을 반환**
    - **프로토타입**
        - 스프링 컨테이너는 **프로토타입 빈 생성과 의존관계 주입까지만 관여**하고 더는 관리하지 않는 매우 짧은 범위의 스코프
        - **항상 새로운 인스턴스를 생성해서 반환**
        - **스프링 컨테이너에서 빈을 조회할 때 생성**
    - **request**
        - **웹 요청이 들어오고 나갈 때**까지 유지되는 스코프
    - **session**
        - **웹 세션이 생성되고 종료될 때**까지 유지되는 스코프
    - **application**
        - **웹의 서블릿 컨텍스트와 같은 범위**로 유지되는 스코프

### 6. Spring Framework를 왜 사용해야 할까요? 이유에 대해 설명해주세요. (박규영)

- 프레임워크를 사용하는 이유
    - **검증된 코드를 이용해서 최소한의 부분만 바꾸어 빠르게 개발**하기 위해
- 스프링 프레임워크를 사용하는 이유
    - **POJO 기반의 구성**
        - 특정 라이브러리나 컨테이너 기술에 종속적이지 않음
        - **객체지향적 설계 구현**
    - **DI를 통한 객체 관계 구성**
    - **AOP (관점지향 프로그래밍) 지원**
        - AOP를 통해 **반복적인 코드를 줄이고 개발자가 핵심 비즈니스 로직에 집중**할 수 있도록 함
        - AOP: 한 로직을 핵심 관점과 부가 관점으로 나누어 보고 관점을 기준으로 각각 모듈화
    - **편리한 MVC 구조**
    - **WAS에 독립적인 개발환경**

### 7. Spring MVC의 동작방식에 대해 설명해주세요. (김은솔)

- Model, View, Controller. 어플리케이션을 구성하는 요소를 역할에 따라 세 가지 모듈로 나누어 구분한 패턴
- 동작방식
    1. 클라이언트가 서버에 요청을 하면 **디스패처 서블릿 클래스**가 요청을 받음
    2. 디스패처 서블릿은 프로젝트 파일 내의 **컨트롤러를 찾아** 매핑된 컨트롤러가 존재하면 리퀘스트 매핑을 통해 **요청을 처리할 메서드로 이동**
    3. 컨트롤러는 해당 요청을 처리한 서비스를 받아 **비즈니스 로직을 서비스에** 위임
    4. 서비스는 요청에 **필요한 작업을 수행**하고 DB에 접근해야 하면 **DAO에 요청**
    5. DAO는 DB정보를 **DTO를 통해 받고 서비스에 전달**
    6. 서비스는 전달받은 데이터를 **컨트롤러에 전달**
    7. 컨트롤러는 **모델 객체에게 요청에 맞는 뷰 정보를 담아 디스패처 서블릿에 전송**
    8. 디스패처 서블릿은 **뷰리졸버에게 전달받은 뷰 정보 전달**
    9. 뷰리졸버는 **응답할 뷰에 대한 jsp를 찾아** **디스패처 서블릿에 전달**
    10. 디스패처 서블릿은 응답할 **뷰의 렌더를 지시**하고 **뷰는 로직을 처리**
    11. 디스패처 서블릿은 **클라이언트에게 렌딩된 뷰를 응답**하며 요청을 마침

### 8. DispatcherServlet에 대해 설명해주세요. (김은솔)

- 디스패처 서블릿
    - **서블릿 컨테이너 가장 앞단**에서 HTTP 프로토콜로 들어오는 **모든 요청을 먼저 받아** 적합한 **컨트롤러에 위임**해주는 프론트 컨트롤러
- 흐름
    1. 클라이언트 요청이 오면 **디스패처 서블릿이 해당 요청을 받음**
    2. **핸들러 매핑**을 통해 **알맞은 컨트롤러를 찾아냄**
    3. 찾아낸 컨트롤러를 **핸들러 어댑터**를 통해 해당 **컨트롤러의 메서드를 실행**
    4. 컨트롤러는 요청을 처리한 뒤 **처리한 결과와 해당 뷰 정보**를 다시 **디스패처 서블릿에게 전달**
    5. 받은 정보로 디스패처 서블릿은 **뷰 리졸버를 통해 뷰 파일을 찾음**
- 장점
    - 모든 요청을 핸들링, **공통 작업 처리**
    - 컨트롤러를 구현해두면 디스패처 서블릿이 **알아서 적합한 컨트롤러로 위임**

### 9. DTO를 사용한 이유를 말해주세요. (김은솔)

- DTO
    - Data Transfer Object
    - **데이터 전송 객체**
    - 계층 간 데이터 전송을 위해 도메인 모델 대신 사용되는 객체
- 왜?
    - 관심사의 분리
        - 도메인 모델은 초기 설계 후 최대한 수정되지 않는 것이 좋음
        - 계층 간 **관심사에 맞게 데이터를 담는 객체를 구분**해줘야 함
        - 도메인과 DTO를 분리함으로써 **의도치 않은 데이터 변경, 노출 및 오류를 방지**

### 10. HTTP API와 REST API에 대해서 설명해주세요. (송채은)

- API
    - 애플리케이션이 어떤 프로그램이 제공하는 기능을 사용할 수 있게 만든 매개체
    - 어플리케이션 소프트웨어를 구축하고 통합하는 정의 및 프로토콜 세트
- **HTTP API**
    - HTTP : 웹 환경에서 정보를 주고 받기 위한 프로토콜
    - HTTP API : **HTTP라는 통신 규칙으로 소통하는 API**. HTTP를 사용해서 서로 정해둔 스펙으로 데이터를 주고 받으며 통신하는 것
- **REST API**
    - **자원의 표현으로 상태를 전달**하는 아키텍쳐로 만든 API
    - 자원 : **URI로 자원을 표현**
    - 행위 : **HTTP Method로 표현 (GET, POST, PUT, DELETE)**
    - 표현 : **응답 자원의 상태를 JSON, XML 등의 형태로 나타냄**
- REST API는 HTTP 프로토콜을 따르면서 4가지 원칙을 지켜야 함 (인터페이스의 일관성)
    - 자원의 식별
        - 요청 내에 기술된 개별 자원을 식별할 수 있어야 함
        - 웹 기반의 REST에서는 리소스에 접근할 때 URI 사용
    - 메세지를 통한 리소스 조작
        - 클라이언트가 어떤 자원을 지칭하는 메시지와 특정 메타데이터만 가지고 있다면 이걸로 서버 상의 해당 자원을 변경 삭제할 수 있어야 함
        - HTTP 헤더에 content-type으로 데이터 타입 지정
    - 자기서술적 메세지
        - 각 메시지는 자신을 어떻게 처리해야 하는지에 대한 충분한 정보를 포함해야 함
    - 애플리케이션의 상태에 대한 엔진으로서 하이퍼미디어
        - 클라이언트가 관련된 리소스에 접근하기를 원한다면 리턴되는 지시자에서 구별될 수 있어야 함….?
        - 어플리케이션의 상태는 하이퍼링크를 이용하여 전이되어야 함
        - REST API를 개발할 때 단순히 클라 요청에 대한 데이터만 응답해주는 것이 아닌 관련된 리소스에 대한 링크 정보까지 함께 포함되어야 함
- **REST API 장점**
    - **확장성 유연성 독립성**
- REST API 제약 조건
    - 클라이언트와 서버가 서로 독립적으로 분리되어 있어야 함
    - 요청에 대한 클라이언트의 상태를 서버에 저장하지 않음
    - 클라이언트는 서버의 응답을 임시저장 할 수 있어야 함 (캐시를 통해 응답 재사용)
    - 서버와 클라이언트 사이에 방화벽, 게이트웨이, 프록시 등 다양한 계층 형태로 구성이 가능해야 함
    - 인터페이스의 일관성을 지키고 아키텍처를 단순화 시켜 클라이언트와 서버가 독립적으로 개선될 수 있어야 함

### 11. annotation 이란 무엇인지, 어떤 것들이 있는지 설명해주세요. (송채은)

- 어노테이션
    - 다른 프로그램에게 **유용한 정보를 제공하기 위해 사용**되는 것
- 역할
    - **컴파일러에게 문법 에러를 체크**하도록 정보를 제공한다
    - 프로그램을 **빌드할 때 코드를 자동으로 생성**할 수 있도록 정보를 제공한다
    - **런타임에 특정 기능을 실행**하도록 정보를 제공한다
- 종류
    
    @SpringBootApplication : 스프링 부트를 자동으로 실행시켜줌
    
    @Configuration : 스프링 IoC 컨테이너에게 해당 클래스가 빈 구성 클래스임을 알려줌
    
    @Component : 개발자가 직접 작성한 클래스를 빈으로 등록
    
    @Autowired : 타입에 따라 알아서 빈을 주입해주는 역할. 객체에 대한 의존성 주입
    
    @Controller : API, View를 동시에 사용하는 경우 사용. view return이 주목적
    
    @RestController : View가 필요없는 API만 지원하는 서비스에서 사용. data return이 주목적
    
- 스프링, 롬복, JPA, Java 등

### 12. singleton pattern 에 대해 설명해주세요. (송채은)

- 싱글턴
    - **생성자가 여러 차례 호출되더라도 실제로 생성되는 객체는 하나**. 최초 생성 이후에 호출된 생성자는 최초의 생성자가 생성한 객체를 리턴.
    - **객체의 인스턴스를 한 개만 생성하는 패턴**
- 언제?
    - 프로그램 내에서 **하나로 공유를 해야** 하는 객체가 존재할 때
    - 프로그램 내에서 **하나의 객체만 존재해야** 할 때
    - 프로그램 내 여러 부분에서 **해당 객체를 공유하여 사용**해야 할 때
- 왜?
    - **메모리**
        - 한 개의 인스턴스만을 고정 메모리 영역에 생성. 추후 객체를 접근할 때 메모리 낭비 방지
    - **속도**
        - 생성된 인스턴스를 사용할 때는 이미 생성된 인스턴스를 활용하여 속도가 빠름
    - **데이터 공유**
        - 전역으로 사용하는 인스턴스. 다른 여러 클래스에서 데이터를 공유하며 사용할 수 있음. but 동시성 문제 가 발생할 수 있음…
- **멀티 쓰레드 환경에서의 문제**
    - 여러 개의 인스턴스 생성
        - **멀티 스레드 환경에서 인스턴스가 없을 때 동시에 생성 가능**
    - 변수 값의 일관성 실패
        - 여러 스레드에서 동시에 실행했을 때 **일관되지 않은 값들이 생길 수 있음**
    - 해결
        - **static 변수로 인스턴스 생성하기**
        - **synchronzied를 적용하여 동시성 문제 해결.** 스레드 세이프를 보장하기 위해 성능 저하가 발생할 수 있음