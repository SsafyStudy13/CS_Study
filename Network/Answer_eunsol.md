# 네트워크

### HTTP Method와 각각 사용되는 경우를 설명해주세요. (김은솔)

- HTTP Method란?
    - 클라이언트-서버 구조에서 요청과 응답이 이루어지는 방식
    - **서버가 수행해야 할 동작을 지정하여 요청을 보내는 방법**
- 왜?
    - 리소스와 동작을 분리하기 위해
    - 서버가 수행해야 할 동작을 지정하여 URI가 리소스만 식별하도록 함
- 종류
    - **Get**
        - 리소스를 **조회, 검색**하는 메서드
        - **멱등성**(Idempotent) : 여러 번 조회 요청을 해도 리소스는 변하지 않음
        - 데이터 전달을 **쿼리스트링**으로 하기 때문에 정보가 무방비 상태로 노출됨
        - 성공 200(Ok), 에러 404(Not Found), 400(Bad Request)
        - **캐싱** 가능 → 같은 데이터를 한번 더 조회할 경우 저장한 값을 사용하여 조회 속도가 빨라짐
    - **Post**
        - 새로운 리소스를 **생성**할 때 사용
        - 데이터 전달을 메세지 **Body**의 쿼리 파라미터 형식으로 전달
            - 쿼리 파라미터는 key-value 형식
            - 데이터가 외부로 노출되지 않으므로 보안상의 이점이 있음
        - Body, content-type 작성해야 함
        - 성공 201(Created)
        - Post도 조회가 되는데 Get을 사용하는 이유
            - Post는 멱등성을 지니지 않으므로 여러 번 수행할 경우 같은 결과값을 보장하지는 않음
            - Get 메서드는 캐싱을 이용하므로 Post 메서드에 비해 조회 속도 면에서 우수
    - **Put**
        - 리소스를 **완전히 대체**하는 개념 (덮어쓰기)
        - 클라이언트가 리소스를 식별할 수 있음
            - 클라이언트가 구체적인 리소스 위치를 아는 상태에서 URI 지정
        - 부분 수정 불가능. 기존에 존재한 데이터는 삭제되고 새로운 데이터로 대체됨
        - 멱등성을 지님
    - **Delete**
        - 리소스를 **제거**하는 메서드
        - 멱등성을 지님
    - **Patch**
        - 리소스를 수정하는 메서드
        - 리소스를 **부분 변경**
        - 멱등성을 지니지 않음
    - Head, Options, Connect

### 세션 기반 인증과 토큰 기반 인증에 대해 설명해주세요. (김은솔)

- 인증과 인가
    - 시스템의 자원을 적절하고 유효한 사용자에게 전달하고 공개하는 방법
    - **인증**(Authentication)
        - 로그인
        - **사용자가 맞는지 검증**
    - **인가**(Authorization)
        - 인증 이후의 작업
        - 인증된 사용자가 자원에 대한 **접근이 가능한지 확인**하는 절차
- HTTP의 비연결성과 비상태성
    - **비연결성** : HTTP는 요청과 응답을 **한 번 주고 받으면 바로 연결을 끊어버림**
    - **비상태성** : HTTP는 요청과 응답을 교환하는 동안 **상태를 저장하지 않음**. 이전에 보냈던 요청, 응답을 기억하지 못함
- **세션 기반 인증**
    - 사용자의 인증 정보가 **서버의 세션 저장소에 저장**됨
    - 로그인 → 인증정보를 서버의 세션 저장소에 저장 → 사용자에게는 저장된 세션 정보의 식별자인 **세션ID** 발급 → 발급된 세션ID는 **브라우저에 쿠키 형태로 저장** (실제 인증 정보는 서버에 저장)
    - 브라우저는 인증 절차를 마친 이후의 요청마다 HTTP Cookie 헤더에 세션ID를 함께 서버로 전송 → 서버는 요청을 전달받고 세션ID에 해당하는 **세션 정보가 세션 저장소에 존재한다면** 해당 사용자를 인증된 사용자로 판단
- **토큰 기반 인증** (JWT)
    - 유저 정보를 서버에 저장하지 않음. **인증 정보를 클라이언트가 직접** 들고 있는 방식
    - 로그인 → 서버는 클라이언트에게 토큰 발급 → 클라는 토큰을 받아 저장하고 서버에 **요청할 때 HTTP Header에 실어** 함께 전송 → 서버는 이를 검증하고 유저를 인가 → **서버는 발급, 검증의 역할을 할 뿐 직접 정보를 갖고 있지 않음**.
    - 유저 상태의 저장 책임이 서버에서 클라로 이동
    - JWT의 경우 디지털 서명이 존재해 토큰의 내용이 위변조 되었는지 서버측에서 확인 가능
- 차이
    - 사이즈
        - **세션**의 경우 쿠키 헤더에 세션ID만 실어 보내면 되므로 **트래픽을 적게 사용**
        - **JWT**는 사용자 인증 정보와 토큰의 발급 시각, 만료 시각, 토큰ID 등 정보가 세션ID에 비해 비대하므로 **훨씬 더 많은 네트워크 트래픽 사용**
    - 안전성과 보안
        - **세션**의 경우 모든 인증 정보를 서버에서 관리 → **보안 측면에서 조금 더 유리**
        - 토큰은 서버가 아닌 클라이언트가 모든 인증 정보를 가지고 있어 탈취되면 토큰이 만료될 때까지 속수무책
        - JWT 특성상 토큰에 실린 페이로드가 별도로 암호화 되어있지 않으므로 누구나 내용을 확인할 수 있다. 따라서 페이로드에는 민감한 데이터 실기 ㄴㄴ
    - 확장성
        - 일반적으로 서버 확장 방식은 수평 확장 사용. 한 대가 아닌 **여러 대의 서버**가 요청을 처리. 이때 별도의 작업을 해주지 않으면 세션 기반 인증 방식은 **세션 불일치 문제**를 겪게됨. 이를 해결하기 위해 Sticky Session, Session Clustering, 세션 스토리지 외부 분리 등의 작업 필요.
        - **토큰 기반 인증**은 서버가 직접 인증 방식을 저장하지 않고 클라이언트가 저장하는 방식으로 이런 세션 불일치 문제로부터 자유로움. 토큰 기반 인증 방식은 HTTP의 비상태성을 그대로 활용할 수 있고 **높은 확장성**을 가짐
    - 서버의 부담
        - 세션 기반 인증 방식은 서비스가 세션 데이터를 직접 저장하고 관리하므로 **세션 데이터의 양이 많아지면 서버의 부담이 증가**
        - 토큰 기반 인증 방식은 클라이언트가 가지고 있으므로 유저의 수가 얼마나 되든 서버의 부담이 증가하지 않음

### 쿠키와 세션의 차이를 설명해주세요. (김은솔)

[https://hudi.blog/cookie-and-session/](https://hudi.blog/cookie-and-session/)

- 등장배경
    - HTTP는 비연결성, 비상태성을 가지며 이전 요청에 대한 정보를 기억하지 못함 → 웹을 사용하며 요청 간의 상태가 유지되어야 할 필요가 생김
- **쿠키**
    - 특징
        - HTTP의 비상태성을 보완하기 위해 등장
        - HTTP 요청과 응답에 함께 실려 전송
        - **클라이언트(브라우저)에 저장**
        - 웹 **서버가** 클라이언트로 보내는 응답 헤더 중 **Set-Cookie라는 헤더에 키와 값을 함께** 실어 보냄 → 응답을 받은 **브라우저가 해당 쿠키를 저장** → 다음 요청부터 자동으로 **쿠키를 헤더에 넣어 송신**
    - 문제점
        - 성능이슈
            - 한번 생성되면 **매 요청마다 헤더에 실려 서버로 전송**됨
            - 쿠키에 저장된 정보가 많으면 요청마다 **오버헤드 발생**
            - 쿠키 데이터는 4kb로 제한, 사이트 당 쿠키 개수도 20개로 제한
        - 보안이슈
            - 쿠키는 클라이언트 측에 저장
            - 만료시각을 명시하지 않으면 쿠키는 메모리에 저장되어 브라우저를 종료하면 휘발
            - **만료시각을 명시하면 파일로 저장**되어 브라우저가 종료되더라도 휘발ㄴㄴ
            - 민감한 정보를 가지고 있는 쿠키가 파일 형태로 저장되어 있다면 **탈취 가능성**
- **세션**
    - 특징
        - 정보를 **서버 측에 저장**하는 방식
        - 브라우저로 **웹 서버에 접속한 시점부터** 브라우저를 **종료하여 연결을 끝내는 시점까지**의 일련의 요청을 **하나의 상태로 간주**하고 그 상태를 **일정하게 유지**하는 기술
    - 생성 과정
        - 사용자가 HTTP 요청의 **Body에 인증정보를 실어 서버에 보냄** → 서버에서는 해당 인증정보가 유효하면 **사용자와 데이터를 식별하는 세션ID 생성** → 세션ID는 응답의 **Set-Cookie 헤더에 실려 보내짐** → 클라이언트는 해당 **세션ID를 쿠키에 저장**하고 **매 요청마다 세션ID를 쿠키 헤더에 실어 전송** → 서버는 **세션ID를 통해 해당 요청의 송신자가 누구인지 식별**
        - 톰캣: JSESSIONID, node.js: connect.sid라는 이름으로 저장
    - 문제점
        - 세션 데이터는 서버의 메모리에 저장
        - 서버를 **수평 확장**하는 경우, 최초 세션이 생성된 서버와 그 이후 요청을 받은 서버가 다른 경우 **세션 불일치 문제 발생**
    - 해결 방안
        - **Sticky Session** : 유저의 요청이 **무조건 세션을 생성한 서버로** 향하도록 함
        - **Session Clustering** : 여러 웹 서버가 **모두 동일한 세션 정보를 가짐**
        - **Session Storage** : **세션 정보를 관리하는 서버**를 별개로 둠 (가장 많이 사용)
        - Key-Value로 값을 저장하는 세션 특성상 **Redis와 같은 인메모리 스토어**를 사용하는 것이 일반적

### TCP/UDP 차이점은? TCP/UDP를 개발 단계에서 직접 사용해 본 적 있는지? (유지연)

- 공통
    - 네트워크 **전송 계층**에서 **데이터를 보내기 위해** 사용하는 프로토콜
- **TCP**
    - 정의
        - 전송을 제어하는 프로토콜
        - 인터넷상에서 **데이터를 메세지 형태**로 보내기 위해 **IP와 함께 사용**하는 프로토콜
    - 특징
        - IP가 데이터의 배달을 처리, TCP가 패킷 추적 및 관리
        - TCP는 연결형 서비스를 지원하는 프로토콜
        - **연결 지향 방식**으로 **패킷 교환 방식**을 사용 (가상 회선 방식이 아님)
        - **3-way handshaking** 과정을 통해 **연결**을 설정하고 **4-way handshaking**을 통해 **해제**
        - **흐름 제어 및 혼잡 제어**
        - **높은 신뢰성**
        - UDP보다 **느린 속도**
        - 전이중(Full-Duplex), 점대점(Point to Point) 방식
        - 연속성보다 **신뢰성있는 전송이 더 중요할 때** 사용
    - TCP 서버의 특징
        - 서버 소켓은 연결만 담당
        - 연결과정에서 반환된 클라이언트 소켓은 데이터의 송수신에 사용
        - 서버와 클라이언트는 **1:1로 연결**
        - 스트림 전송으로 **전송 데이터의 크기가 무제한**
        - 패킷에 대한 응답을 해야 하기 때문에 시간 지연, CPU 소모로 인한 성능이 낮다
        - **Streaming 서비스에 불리** (손실된 경우 **재전송을 요청하므로**)
    - 패킷 : 인터넷 내에서 데이터를 보내기 위한 경로배정(라우팅)을 효율적으로 하기 위해 **데이터를 여러 개의 조각(패킷)들로 나누어** 전송.
    - TCP가 패킷을 추적, 관리하는 방법
        - 데이터는 패킷 단위로 나뉘어 **같은 목적지(IP계층)에 전송**
        - 패킷에 번호를 매겨 **분실 확인** → 목적지에서 **재조립**
- UDP
    - 정의
        - 사용자 데이터그램 프로토콜
        - 데이터를 **데이터그램 단위로 처리**하는 프로토콜
    - 데이터그램
        - 독립적인 관계를 지니는 패킷
    - 동작방식
        - UDP는 비연결형 프로토콜로 연결을 위해 할당되는 논리적인 경로가 없음
        - 각각의 패킷은 다른 경로로 전송되며 독립적인 관계를 지님
        - 데이터를 다른 경로로 독립적으로 처리하는 프로토콜을 UDP라고 함
    - 특징
        - **비연결형 서비스**로 **데이터그램 방식**을 제공
        - 정보를 주고 받을 때 정보를 보내거나 받는다는 **신호 절차를 거치지 않음**
        - UDP헤더의 **CheckSum 필드**를 통해 **최소한의 오류만 검출**
        - **낮은 신뢰성**
        - TCP보다 **빠른 속도**
        - 신뢰성보다는 **연속성이 중요한 서비스**(ex. 스트리밍)에 자주 사용
    - UDP 서버의 특징
        - UDP에는 연결 자체가 없어서 **서버 소켓과 클라이언트 소켓의 구분이 없다**
        - **소켓을 활용해 IP와 PORT를 기반으로 데이터를 전송**한다
        - 서버와 클라이언트는 **1:1, 1:N, N:M 등으로 연결**될 수 있다
        - **데이터그램(메세지) 단위로 전송**되며 그 크기는 65535바이트로 **크기가 초과하면 잘라서 보낸다**
        - **흐름제어가 없어서** 패킷이 제대로 전송되었는지 오류가 없는지 **확인할 수 없다**
        - 파일 전송과 같은 신뢰성이 필요한 서비스보다 **성능이 중요시되는 경우**에 사용한다
    - 흐름제어와 혼잡제어
        - **흐름제어** : 데이터를 송신하는 곳과 수신하는 곳, 양**쪽의 데이터 처리 속도를 조절**하여 수신자의 **버퍼 오버플로우**를 방지. 송신하는 곳에서 감당이 안 되게 데이터를 빠르게 많이 보내면 수신자에서 문제가 발생할 수도 있기 때문
        - **혼잡제어** : 네트워크 내의 **패킷 수가 넘치게 증가하지 않도록** 방지. 정보의 소통량이 과다하면 패킷을 조금만 전송하여 **혼잡 붕괴 현상**이 일어나는 것을 막음
- 비교

|  | TCP | UDP |
| --- | --- | --- |
| 연결 방식 | 연결형 서비스
(패킷 교환 방식) | 비연결형 서비스
(데이터그램 방식) |
| 전송 순서 | 전송 순서 보장 | 순서가 바뀔 수 있음 |
| 수신 여부 확인 | O | X |
| 통신 방식 | 1:1 | 1:1, 1:N, N:M |
| 신뢰성 | 높음 | 낮음 |
| 속도 | 느림 | 빠름 |
| 사용 예시 | HTTP 웹 브라우저
FTP 파일 전송
Telnet 원격 로그인
SMTP email 서비스 | 스트리밍
teleconferencing
DNS
Internet telephony 음성전화 |

### CORS가 무엇인가요? (유지연)

[https://inpa.tistory.com/entry/WEB-📚-CORS-💯-정리-해결-방법-👏](https://inpa.tistory.com/entry/WEB-%F0%9F%93%9A-CORS-%F0%9F%92%AF-%EC%A0%95%EB%A6%AC-%ED%95%B4%EA%B2%B0-%EB%B0%A9%EB%B2%95-%F0%9F%91%8F)

- CORS
    - **도메인이 다른 2개의 사이트가 데이터를 주고 받을 때 발생하는 문제**
- 발생 이유
    - **서버 내에서 요청이 허락된 도메인에만 데이터를 주기 위해**
- 설정 방법(WebConfig.java)
    - Access-Control-Allow-**Origin** : 요청을 보내는 **페이지의 출처** (*, 도메인)
    - Access-Control-Allow-**Methods** : 요청을 허용하는 **메서드**. Default : Get, Post
    - Access-Control-**Max-Age** : 클라이언트에서 preflight 요청 (서버의 응답 가능 여부에 대한 확인, 예비 요청, Options 메서드) **결과를 저장할 시간**
    - Access-Control-Allow-**Headers** : 요청을 허용하는 **헤더**
- 기본 동작
    - **클라이언트**에서 **HTTP 요청의 헤더에 Origin을 담아 전달**
    - 서버는 **응답 헤더**에 **Access-Control-Allow-Origin을 담아 클라이언트로 전달**
    - **클라이언트**에서 **Origin**과 서버가 보내준 **Access-Control-Allow-Origin을 비교**

### 소켓과 웹소켓의 차이점에 대해 설명해주세요. (유지연)

[https://velog.io/@codingbotpark/Web-Socket-이란](https://velog.io/@codingbotpark/Web-Socket-%EC%9D%B4%EB%9E%80)

- **소켓**
    - 등장 배경
        - OSI 7계층으로 나누어 네트워크를 관리
        - 계층 별 각 프로토콜은 일종의 통신 규약일 뿐, 프로토콜 구현을 위해 안에 들어갈 구체적인 **구현부 함수가 필요**
        - **소켓**에서 이러한 함수의 **body를 제공** → **별도의 구현없이 소켓을 사용**
        - 프로토콜의 세부적인 명세를 **일일이 정의할 필요없이 소켓을 활용**하면 됨
    - 정의
        - 프로그램이 **네트워크에서 데이터를 주고 받을 수 있도록** 네트워크 **환경에 연결**할 수 있게 만들어진 **연결부**
        - 일반적으로 **TCP/IP 프로토콜**을 이용함
        - TCP/IP 4계층에서 전송 계층 위에 놓임 (응용/전송/인터넷/물리)
        - 전송 계층 위에서 전송 계층의 프로토콜 제어를 위한 코드를 제공
        - 소켓은 **통신의 양 끝단**
    - 하는 일
        - 소프트웨어 간 **연결**
            - IP와 서비스 포트를 통해 찾아서 연결
        - 소프트웨어 간 **데이터 통신**
            - 인터넷에서 소켓을 찾아 연결하고 데이터 송수신
    - 클라이언트 흐름
        1. 클라이언트 소켓 생성
            - 연결 대상에 대한 정보가 들어있지 않은 소켓을 생성
            - 소켓 종류
                - TCP : stream 타입
                - UDP : 데이터그램 타입
        2. 연결 요청
            - IP주소와 서비스 포트 번호로 연결하고 싶은 대상 특정
        3. 데이터 송수신
            - 요청에 대한 결과가 들어와야 실행이 끝남
        4. 소켓 닫기
    - 서버의 흐름
        1. 서버 소켓 생성
        2. 바인딩
            - 서버 소켓이 받은 데이터를 다시 보내줘야 할 때 프로세스들의 포트번호가 동일하다면 혼란이 생길 수 있음. 고유한 포트 번호를 만들 수 있도록 소켓과 포트 번호를 결합하는 작업이 필요
            - 하나의 프로세스는 동일한 포트 번호를 가진 여러 개의 소켓을 결합할 수 있음. 호스트가 하나의 포트로 여러 개의 소켓을 만들어 다른 호스트들과 데이터를 주고 받을 수 있음 (ex. 동시에 많은 사람들과 채팅)
        3. 클라이언트 연결 요청 대기
        4. 클라이언트 연결 수립
            - 연결 요청을 받아들임과 동시에 새로운 소켓 생성
            - 클라이언트의 연결 요청을 기다렸다가 클라이언트 소켓으로부터 요청을 받으면 새로운 소켓을 열고 클라이언트 소켓을 맵핑하여 넘겨줌
        5. 데이터 송수신
        6. 소켓 닫기
- **웹 소켓**
    - 등장 배경
        - **HTTP에서 실시간 통신을 할 수 없다는 문제를 해결하기 위해 나온 기술**
        - HTTP는 단방향적 구조로 통신하기 때문에 TCP/IP 프로토콜을 사용하는 소켓처럼 연결이 유지되는 실시간 통신을 할 수 없음
    - 정의
        - **두 프로그램 간의 메시지 교환을 위한 통신 방법 중 하나**
    - 특징
        - **연결지향 (양방향)**
        - **한 번 연결 맺은 뒤 유지**
        - handshake 과정에서 헤더의 비중이 크지만 한 번 연결이 되면 간단한 메시지들만 오고 가기 때문에 경제적
        - **웹에서 실시간 통신**을 해야 하는 상황에서 쓰이는 프로토콜 (ex. 게임, 채팅, 실시간 주식 거래 등)
    - 동작 방법
        1. Handshaking
            - 통신이 시작되기 전에 두 개의 실체 간에 확립된 통신 채널의 변수를 동적으로 설정하는 자동화된 협상 과정
        2. Frame 구성
            - 최초 접속에서만 HTTP 프로토콜 위에서 핸드쉐이킹을 하기 때문에 http 헤더를 사용
            - 웹소켓을 위한 별도의 포트는 없으며 기존 포트를 사용
            - 프레임으로 구성된 메시지라는 논리적 단위로 송수신
            - 메시지에 포함될 수 있는 교환 가능한 메시지는 텍스트와 바이너리 뿐
- **차이**
    - 동작 계층
        - **소켓**은 인터넷 프로토콜에 기반하므로 **TCP/UDP가 속한 4계층**에 위치
        - **웹 소켓**은 TCP에 의존하지만 **HTTP에 기반하므로 7계층**에 위치
    - 데이터 형식
        - TCP에 기반한 **소켓** 통신은 단순히 바이트 스트림을 통한 데이터 전송이므로 **바이트로 이루어진 데이터를 다뤄야 함**
        - **웹 소켓** 통신은 어플리케이션 계층에 기반하므로 **메시지 형식의 데이터를 다룸**

### TCP에서의 3-way handshake 에 대해서 설명해주세요. (송채은)

- 3-way handshake
    - 정의
        - **TCP 통신을 이용하여 데이터를 전송하기 위해 네트워크 연결을 설정하는 과정**
        - 양쪽 모두 데이터를 전송할 준비가 되었다는 것을 보장하고 실제로 데이터 전달이 시작하기 전에 한 쪽이 다른 쪽이 준비되었다는 것을 알 수 있도록 함
        - TCP/IP 프로토콜을 이용해서 통신을 하는 응용프로그램이 데이터를 전송하기 전에 먼저 정확한 전송을 보장하기 위해 상대방 컴퓨터와 사전에 세션을 수립하는 과정
    - 작동 방식
        - 클라이언트는 서버와 연결하기 위해 연결 요청
        - SYN(Synchronization) : 연결 요청. 세션을 설정하는데 사용하며 초기에 시퀀스 번호를 보냄
        - ACK(Acknowledgement) : 보낸 시퀀스 번호에 TCP 계층에서의 길이 또는 양을 더한 것과 같은 값을 ACK에 포함하여 전송
            - 동기화 요청에 대한 답변 : 클라이언트의 시퀀스 넘버 + 1을 하여 ACK로 돌려줌
        1. SYN
            - 클라이언트는 서버와 커넥션을 연결하기 위해 **SYN을 보냄 (seq: x)**
            - 송신자가 최초로 데이터를 전송할 때 시퀀스 넘버를 임의의 랜덤 숫자로 지정
            - SYN 플래그 비트를 1로 설정한 세그먼트를 전송
        2. SYN + ACK
            - 서버가 SYN(x)를 받고, 클라이언트로 받았다는 신호인 **ACK와 SYN 패킷을 보냄 (seq : y, ACK: x + 1)**
            - 접속 요청을 수락했으며 접속 요청 프로세스인 포트를 열어달라는 메시지 전송
            - ACK 넘버 필드를 시퀀스 넘버 +1 로 지정하고 SYN과 ACK 플래그 비트를 1ㄹ로 설정한 세그먼트 전송
        3. ACK
            - 클라이언트는 서버의 응답인 ACK(x+1)와 SYN(y) 패킷을 받고 **ACK(y+1)을 서버로 보냄**
            - 마지막으로 접속 요청 프로세스가 수락 확인을 보내 연결을 맺음
            - 이때 전송할 데이터가 있으면 데이터 전송

### OSI 7계층은 어떻게 구성되어 있으며, 각 계층 별 데이터 전송 단위는 무엇인가요? (송채은)

- OSI 7계층
    - **네트워크 통신이 일어나는 과정을 7단계로 나눈** **국제 표준화 기구(ISO)에서 정의**한 **네트워크 표준 모델**
    - 각 계층을 지날 때마다 각 계층에서 Header가 붙게되고 수신측은 역순으로 헤더를 분석함
    - 모든 시스템들의 상호 연결에 있어 문제가 없도록 표준을 정한 것
- 1계층 - 물리
    - 통신 케이블로 **데이터를 전송하는 물리적인 장비**
    - 통신 단위 : **비트**
    - 장비 : **통신 케이블, 리피터, 허브 등**
- 2계층 - 데이터 링크
    - 물리계층을 통해 송수신되는 정보의 오류와 흐름을 관리하여 안전한 **통신의 흐름을 관리**
    - 두 장치 간의 **신뢰성 있는 정보 전송을 담당**
    - 프레임에 물리적 주소 (MAC)를 부여하고 에러 검출, 재전송 수행
    - 브리지나 스위치를 통해 맥 주소를 가지고 물리 계층에서 받은 정보를 전달
    - 전송 단위 : **프레임**
    - 장비 : **브리지, 스위치, 이더넷**
- 3계층 - 네트워크
    - 데이터를 목적지까지 **가장 안전하고 빠르게 전달**
    - 라우터를 통해 경로를 선택 → 주소를 정하고 (IP) → 경로에 따라 패킷을 전달
    - 전송 단위 : **패킷**
    - 장비 : **라우터, L3 스위치**
- 4계층 - 전송
    - 포트 번호, 전송방식 결정
    - **두 지점 간의 신뢰성 있는 데이터를 주고 받게 해주는 역할**
    - 전송 단위 : **세그먼트**
    - 프로토콜 : TCP, UDP
- 5계층 - 세션
    - 주 지점 간의 프로세스 및 통신하는 호스트 간의 연결을 유지
    - **데이터가 통신하기 위한 논리적인 연결**
    - 양 끝단의 응용 프로세스가 통신을 관리하기 위한 방법을 제공
- 6계층 - 표현
    - 전송하는 데이터의 표현방식을 결정
    - 파일 인코딩, 명령어를 포장, 압축, 암호화
- 7계층 - 응용
    - 응용 프로세스와 직접 관계하여 일반적인 응용서비스를 수행
    - 응용 프로세스 간의 정보 교환을 담당

### JWT란 무엇인지, 장단점에 대해서 설명해주세요 (송채은)

- **Json Web Token**
    - 국제 표준. **통신 양자 간의 정보를 JSON 형식으로 안전하게 전송하기 위한 방법**
    - **정보가** **토큰 자체에 포함된** (Self-Contained) **클레임** (Claim: 사용자에 대한 속성) **기반 토큰**
- 인증(Authentication), 인가(권한부여, Authorization)에 사용
    - 인증 절차를 거쳐 **서버에서 JWT 발급** → **클라이언트는** 이를 잘 보관하고 있다가 **API 등을 사용할 때** **서버에 JWT를 함께 제출**
- 구조 (각 구성요소는 점(.)으로 분리, JSON 형태로 표현, 개행을 포함할 수 있어 한 줄로 나타내기 위해 각 구성요소를 Base64로 인코딩)
    - **헤더**
        - **토큰의 유형**과 **암호화 알고리즘 정보**를 담음
        - ex) { “alg”: “HS256”, “typ”: “JWT” }
    - **페이로드**
        - **사용자의 정보**, 데이터 속성 등을 나타내는 클레임이라는 정보 단위로 구성
        - **누구나 읽을 수 있는 정보**로 **민감한 정보를 담으면 안 됨**
        - 등록된 클레임(Registered Claim)
            - 토큰 자체의 정보를 담기 위해 이름이 미리 정의된 클레임
            - JWT 사양에 이미 정의된 클레임
            - 모든 클레임은 선택적
            - 토큰 사이즈를 작게 유지하기 위해 이름이 3글자로 축약됨
        - 공개 클레임(Public Claim)
            - JWT를 사용하는 사람들에 의해 정의되는 클레임
            - 충돌 방지를 위해 URI형태로 이름을 짓거나 직접 클레임을 등록
        - 비공개 클레임(Private Claim)
            - 서버와 클라이언트 사이에서만 협의된 클레임
            - 이름이 중복될 수 있으므로 주의
    - **서명**
        - **토큰의 유효성을 검증할 때** 사용하는 **고유한 암호화 코드**
        - 생성 과정
        1. **헤더와 페이로드 값을 각각 Base64로 인코딩** 하고 점(.)을 중간자로 합친다.
        2. 인코딩한 값을 **헤더에 정의된 암호화 알고리즘으로 해싱**한다. (이 때, **시크릿 키** 사용)
        3. **해싱된 값을 다시 Base64로 인코딩**
        - 서명을 통해 서버는 헤더 혹은 페이로드가 누군가에 의해 변조되었는지 그 무결성을 검증하고 보장할 수 있다.
        - 유효성 검사
            - 암호화된 시그니처를 Base64UrlEncode(header).Base64UrlEncode(payload)와 비교해 같으면 유효한 토큰으로 판단하여 인증을 허용
- 특징
    - **해시, 비대칭키 방식을 사용**하여 서명(Signature)하기 때문에 **무결성을 검증**할 수 있음
    - **토큰 자신이 정보를 직접 포함** → 통신 양자 간 정보를 안전하게 전송
    - URL에 대한 안전한(URL-Safe) 문자열로 구성되어 있어 어떤 경로든 전송할 수 있음
- 장점
    - **수평 확장의 환경에서** **여러 대의** **서버가 모두 유저 정보를 기억할 필요가 없음**
    - 데이터를 직접 갖고 있는 **클레임 기반 토큰으로 토큰의 만료를 구현할 수 있음**
- 단점
    - 토큰 자체에 정보가 저장되는 형태는 세션과 달리 **클라이언트에 유저 정보가 저장**되므로 **노출되기 쉬움**
    - **민감한 정보를 담아서는 안 됨**
    - **토큰 사이즈**가 세션ID에 비해 **비대함**. 발생하는 오버헤드를 감안해야 함
    - **이미 발행된 토큰**에 대해 서버는 아무런 **제어도 할 수 없음** → 엑세스 토큰과 리프레시 토큰을 함께 사용

### 주소창에 `https://www.google.com/` 을 입력한 경우, 어떤 일이 발생하는지 순서대로 설명해주세요. (송채은)

1. 사용자가 웹 브라우저를 통해 **주소를 입력**하면 URL 주소 중 **도메인 네임 부분을 DNS 서버에서 검색**
2. 가장 가까운 DNS 서버에서 해당 **도메인 이름에 해당하는 IP 주소를 찾아** 사용자가 입력한 **URL 정보와 함께 전달**
3. 전달 받은 **IP 주소를 이용**하여 웹 브라우저는 웹 **서버에게** 해당 웹 **사이트에 맞는 html 문서를 요청**
4. **WAS와 데이터베이스**에서 **웹 페이지 작업을 처리**
5. **WAS**에서 **작업 처리 결과들을 웹 서버로 전송**하고 웹 **서버**는 웹 **브라우저에게 html 문서 결과 전달**
6. **브라우저 렌더링 과정**을 통해 **웹 페이지 내용 출력**

### 공인 IP와 사설 IP의 차이를 설명해주세요. (김은솔)

- **공인 IP**
    - 정의
        - 인터넷 사용자의 **로컬 네트워크를 식별하기 위해 ISP가 제공하는 IP주소**
        - 공용 IP라고도 하며 **외부에 공개**되어 있는 IP주소
    - 특징
        - 공인 IP는 **전세계에서 유일한 IP주소**를 가짐
        - 외부에 공개되어 있기에 인터넷에 연결된 **다른 PC로부터의 접근이 가능**
        - 공인 IP 주소를 사용하는 경우에는 방화벽 등의 보안 프로그램을 설치해야 함
- **사설 IP**
    - 정의
        - **일반 가정이나 회사 내에 할당된 네트워크**
        - 로컬 IP, 가상 IP라고도 불림
    - 특징
        - IPv4의 주소 부족으로 인해 서브넷팅된 IP
        - **라우터에 의해** 로컬 네트워크 상의 PC나 장치에 할당
- 차이
    
    
    |  | 공인 IP | 사설 IP |
    | --- | --- | --- |
    | 할당 주체 | ISP (인터넷 서비스 공급자) | 라우터 (공유기) |
    | 할당 대상 | 개인 또는 회사의 서버(라우터) | 개인 또는 회사의 기기 |
    | 고유성 | 인터넷 상에서 유일한 주소 | 하나의 네트워크 안에서 유일 |
    | 공개 여부 | 내/외부 접근 가능 | 외부 접근 불가능 |
- **사설 IP 주소만으로는 인터넷에 직접 연결할 수 없다**. **라우터를 통해 1개의 공인 IP만 할당**하고 라우터에 연결된 개인 PC는 **사설 IP를 할당**받아 인터넷에 접속할 수 있게 된다.

### DNS에 대해 설명해주세요. (유지연)

- 정의
    - Domain Name System
    - 인터넷의 전화번호부
    - 사용자가 도메인 이름을 웹 브라우저에 입력하는 경우 DNS는 해당 사이트의 올바른 IP 주소를 찾음
- **웹사이트에 접속할 때 복잡한 IP 주소 대신 도메인을 사용하는데 입력한 도메인을 네트워크 상에서 사용하는 IP 주소로 바꾸고 접속하는 과정이 필요 → DNS**
- 분산 데이터 베이스 구조
    - 한 대의 서버에서 돌리면 느리고 비효율적이기 때문
    - **계층적으로 구분**, 정보를 분산하는 구조
- 구성 요소
    - **도메인 네임 스페이스** : DNS가 저장 관리하는 계층적 구조
        - 도메인 네임 스페이스라는 규칙으로 **도메인 이름 저장을 분산**
    - **네임 서버** : 권한 있는 DNS 서버
        - 네임 서버가 해당 **도메인 이름의 IP 주소를 찾음**
    - **리졸버** : 권한 없는 DNS 서버
        - DNS 클라이언트 요청을 네임 서버로 전달하고 찾은 **정보**를 클라이언트에게 **제공**하는 기능을 수행
- 동작 방식
    1. 브라우저 → DNS 리졸버
        - 사용자가 웹 브라우저에 도메인 이름을 입력하면 리졸버는 자신의 **캐시에 해당 도메인 이름에 대한 IP 주소가 있는지 확인**
        - 있으면 반환하고 없으면 **DNS 서버에 요청**
    2. DNS 리졸버 → Root DNS 서버 → DNS 리졸버
        - **루트 DNS 서버**에게 요청. 모든 도메인 이름에 대한 IP 주소를 가지고 있진 않음
        - 대신 **TLD DNS** 서버에 대한 정보를 가지고 있으며 **해당 IP 주소를 리졸버에게 전달**
    3. DNS 리졸버 → **TLD DNS 서버** → DNS 리졸버
        - TLD에게 요청. **해당 도메인 이름의 Authoritative DNS 서버의 IP 주소**를 **리졸버에게 반환**
    4. DNS 리졸버 → **Authoritative DNS 서버** → 리졸버 → 브라우저
        - Authoritative DNS 서버에서 **해당하는 IP 주소를 리졸버에게 반환**
        - **IP주소를 캐시에 저장**하고 동일한 도메인 이름에 대한 요청이 들어오면 이 주소 사용

참고

[https://baebalja.tistory.com/443](https://baebalja.tistory.com/443)

[https://dev-coco.tistory.com/161](https://dev-coco.tistory.com/161)

[https://lealea.tistory.com/235](https://lealea.tistory.com/235)