# 네트워크

</br>

## :memo: HTTP (HyperText Transfer Protocol)

: 웹 브라우저 - 웹 서버 간 데이터를 주고 받기 위한 텍스트 기반 프로토콜

: 요청(request)과 응답(response)으로 이루어짐



### HTTP Methods

: 클라이언트가 서버에게 요청의 종류 알리기 위해 사용

- 종류

  1. `GET`

     : 데이터 조회 시 사용

     : URL에 **쿼리스트링**을 사용하여 서버에 데이터를 전달하기도 함

     : 웹 페이지 로드, 검색 결과 조회 등의 경우

  2. `POST`

     : 서버에 데이터를 전송하여 새 리소스를 생성하거나 처리 시 사용

     : 성공적으로 리소스 생성했다면, 201 응답

     : body에 데이터를 포함하여 서버로 전송

     : 폼 제출, 사용자 등록 등의 경우

  3. `PUT`

     : 서버에 데이터를 생성하거나 업데이트 시 사용

     : 부분 업데이트는 불가

     : body에 데이터를 포함하여 서버로 전송, 해당 리소스가 없으면 새로 생성

     : 파일 업로드, 데이터 갱신 등의 경우

  4. `DELETE`

     : 데이터 삭제 시 사용

     : 사용자 계정 삭제, 게시글 삭제 등의 경우

  5. `PATCH`

     : 리소스의 **일부를 업데이트**할 때 사용

     : body에 변경할 부분만 포함하여 전송

     : 사용자 프로필의 특정 정보 수정 등의 경우

  6. `HEAD`

     : GET 요청과 동일하나, header 만 응답으로 받을 시 사용

     : 응답 body는 반환하지 않고, 주로 리소스의 메타데이터를 확인할 때 사용

     : 리소스 존재 여부, 응답 시간 확인 등의 경우

  7. `OPTIONS`

     : 서버에서 지원하는 method 확인 시 사용

     : 서버가 지원하는 HTTP method를 응답 header에 포함하여 반환

     : 서버의 기능 확인, CORS 요청 전에 사전 요청 등의 경우

  8. `CONNECT`

     : 클라이언트 - 서버 간 HTTP 프록시 서버를 통해 연결 설정 시 사용

     : 클라이언트는 프록시 서버를 통해 목적 서버와 직접적인 TCP 연결 설정 가능

     : 주로 SSL(Secure Sockets Layer) 또는 TLS(Transport Layer Security) 등의 보안 연결 설정의 경우



</br>

## :memo: 인증과 인가

: HTTP의 stateless 특성때문에 인증, 인가를 통해 클라이언트의 상태를 보존함



### 인증

: 사용자의 신원을 확인하는 과정

: 사용자를 구별하기 위해 아이디, 비밀번호를 활용하거나 생체 인식, 인증서 등을 통해 신원을 확인

: 회원가입, 로그인이 해당



### 인가

: **인증된 사용자가** 특정 자원에 접근할 수 있는 권한을 가지고 있는지 확인하는 과정

: 사용자가 어떤 작업을 수행할 수 있는지 결정

- 인증 방식

  - **세션 기반 인증**

    : 사용자 로그인 후, 서버는 사용자의 세션을 생성하고 세션 ID를 쿠키로 클라이언트에게 전달하는 방식

    : 사용자 요청에 세션 ID를 포함하여 서버에 전송하고, 서버는 세션 ID로 사용자를 식별

    - 장점

      : 서버에서 세션 데이터를 관리하므로, 사용자 상태를 쉽게 추적 가능

      : 쿠키를 통해 세션 ID를 자동으로 관리하므로 비교적 간단한 구현

    - 단점

      : 서버 메모리에 세션 정보를 저장하므로, 많은 사용자 접속 시 서버 리소스 사용량 증가

      : 서버 확장 시, 세션 상태를 공유하기 위해 서버 간 데이터를 동기화해야 하므로 한계점 존재

      : CSRF(Cross-Site Request Forgery) 공격에 취약

  - **토큰 기반 인증**

    : 사용자 로그인 후, 서버가 JWT(JSON Web Token) 같은 토큰을 생성하여 클라이언트에게 전달하는 방식

    : 사용자 요청에 토큰을 포함하여 서버에 전송하고, 서버는 토큰을 검증하여 사용자 식별

    : 토큰은 `헤더(header)`, `내용(payload)`, `서명(signature)`으로 구성

    - 장점

      : 토큰은 자체적으로 정보를 포함하고 있으므로 서버에 세션을 저장할 필요가 없음

      : Stateless 방식이므로 서버 확장 용이

      : CORS(Cross-Origin Resource Sharing)를 쉽게 처리 가능

      : JWT는 서명이 포함되어 있어 클라이언트에서 쉽게 변조할 수 없음

    - 단점

      : 토큰이 클라이언트에게 저장되므로, 토큰 탈취 시 보안에 취약

      : 토큰의 유효 기간이 길다면, 그 동안 탈취된 토큰으로 악용될 수 있음

      : 토큰을 무효화하거나 갱신하는 매커니즘 추가 필요



</br>

## :memo: 쿠키와 세션

### 쿠키 (Cookie)

: HTTP의 일종으로 사용자가 특정 웹 사이트를 방문할 경우, 사이트가 사용하고 있는 서버에서 사용자의 브라우저에 저장되는 데이터

: 서버는 쿠키를 생성하여 클라이언트에게 전송하고, 이후 클라이언트는 요청에 쿠키를 포함

: **지속 쿠키**(설정된 만료 시간까지 유지) 와 **세션 쿠키**(브라우저 종료 시 삭제)로 나뉨

- 특징

  : `이름`, `값`, `만료일`, `경로` 정보로 구성

  : 서버의 자원을 사용하지 않고, 클라이언트에 총 300개의 쿠키 저장 가능

  : 하나의 도메인 당 20개의 쿠키를 가질 수 있음

  : 하나의 쿠키는 4kb(=4096byte) 까지 저장 가능

  : 쿠키는 텍스트 형식으로 저장되므로 `HttpOnly`와 `Secure` 플래그를 사용하여 보안 강화 가능

  : 파일로 저장되기 때문에 브라우저가 종료되어도 정보 유지 가능 + 만료 기간을 설정하여 쿠키 유지 기간 설정 가능

- 예시

  : 로그인 시, 아이디와 비밀번호 정보 저장

  : 팝업 창의 다시 보지 않기 기능



### 세션 (Session)

: 일정 시간(서버 접속 시점 ~ 연결 종료 시점) 동안 서버 측에서 관리되는 사용자 상태 정보

: 서버는 세션 ID를 생성하여 클라이언트에게 전송하고, 이후 클라이언트는 요청에 세션 ID를 포함

= 세션 쿠키

- 특징

  : 브라우저를 닫거나, 서버에서 세션을 삭제했을 때만 세션이 삭제되므로, 쿠키보다 보안이 좋음

  : 저장 데이터에 제한이 없음

  : 각 클라이언트 별 고유 세션 ID를 부여

  : 세션 정보가 서버에 저장되므로 처리하는 데 쿠키보다 시간이 더 소요됨

- 예시

  : 페이지를 이동해도 로그인이 풀리지 않는 기능



</br>

## :memo: ​TCP와 UDP

: TCP/IP의 `전송 계층`에서 사용되는 프로토콜



### TCP (Transmission Control Protocol)

: **연결 지향적 프로토콜**, 클라이언트와 서버를 연결 한 후 데이터를 주고 받음

: 신뢰성이 보장되어 있으며 일련의 옥텟(데이터, 메시지, 세그먼트)를 안정적, 순차적으로 에러 없이 교환할 수 있음

- 특징
  - **연결형 서비스**로 **가상 회선 방식** 제공
  - **흐름 제어 (Flow control)** : 데이터 처리 속도를 조절하여 수신단의 버퍼 overflow 방지
  - **혼잡 제어 (Congestion control)** : 네트워크 내 패킷 수가 과도하게 증가하지 않도록 방지
  - **높은 신뢰성** : 신뢰성이 높은 대신 UDP 보다 느린 속도
  - **전이중 방식 (Full-Duplex)** : 양방향 전송 가능
  - **점대점 방식 (Point to Point)** : 각 연결이 정확히 2개의 종단점을 가지고 있음



#### 3-way handshake : 연결 설정

![image](https://github.com/SsafyStudy13/CS_Study/assets/122426072/9b46b799-c0bd-4bfb-a7b4-d6fe573d9347)

1. **client : server에게 TCP SYN segment 전송**
   - data 없음
   - 초기 sequence number 전송
2. **server : SYN을 수신하고 SYNACK segment 전송**
   - buffer 할당
   - 서버의 초기 sequence number 전송
3. **client : SYNNACK 수신**
   - ACK segment 송신
   - data 포함 가능



#### 4-way handshake : 연결 해제

1. client : server에게 TCP FIN control segment 전송
2. server : FIN 수신, ACK 응답 / FIN 전송
3. client : FIN 수신, ACK 응답
   - **Timed wait** : ACK가 확실히 전달되도록 기다리기
4. server : ACK 수신, connection close



### UDP (User Datagram Protocol)

: **비연결형 프로토콜**, 논리적인 경로 없이 각 패킷은 다른 경로로 전송되며 독립적인 관계를 지님 

- 특징
  - **비연결형 서비스**로 **데이터그램 방식** 제공 → 순차적이지 않음
  - **데이터 수신 여부를 확인하지 않음**
  - 흐름 제어가 없으므로 **낮은 신뢰성**
  - TCP보다 **빠른 속도**
  - 일대일, 일대다, 다대다 통신 가능
  - 신뢰성보다는 빠르고 연속성 있는 전송이 필요할 때 사용 (ex. 전화, 영상 스트리밍)



</br>

## :memo: ​CORS (Cross-Origin Resource Sharing)

: 다른 출처의 자원을 공유

: 추가 HTTP 헤더를 사용하고, 한 출처에서 실행 중인 웹 애플리케이션이 다른 출처의 선택 자원에 접근할 수 있도록 허용하는 메커니즘

: SOP(Same Origin Policy) 를 우회하여 안전하게 리소스를 공유할 수 있도록 함

- SOP

  ![image](https://github.com/SsafyStudy13/CS_Study/assets/122426072/5b10f53b-5805-4d74-b505-a88fe8712a38)

  : url의 protocol, host, port를 통해 출처 동일 여부 판단 가능

  : (1) 프로토콜, (2) 도메인, (3) 포트번호 → 세가지가 모두 같아야 같은 출처



- 필요성
  - 무분별하게 모든 곳에서 데이터를 요청할 수 있게 되면, 데이터 보안 문제가 발생함
  - CORS를 사용하여 브라우저에서 데이터를 보호하고, 필요한 경우에만 요청할 수 있도록 허용하기 위함



- 동작 원리

  : 서버가 클라이언트에게 어떤 출처에서 리소스를 요청할 수 있는지 명시적으로 알려줌

  1. **단순 요청 (Simple Requests)**

     : HTTP 메서드가 `GET`, `POST`, `HEAD` 중 하나인 경우

     : 특정 헤더만 포함되는 경우

     `Accept`, `Accept-Language`, `Content-Language`, `Content-Type` (단, `Content-Type`의 값은 `application/x-www-form-urlencoded`, `multipart/form-data`, `text/plain` 중 하나여야 함)

     : 브라우저는 서버에 접근할 때 자동으로 CORS 헤더를 추가함

     : 서버는 응답 헤더에 `Access-Control-Allow-Origin`을 포함하여 요청을 허용할 출처를 명시함

  2. **예비 요청 (Preflight Requests)**

     : 클라이언트가 실제 요청을 보내기 전에 서버의 CORS 정책을 확인하기 위해 보내는 요청

     : 주로 `PUT`, `DELETE` 메서드나 커스텀 헤더를 사용을 요청에 대해 수행

     : 예비 요청은 `OPTIONS` 메서드를 사용하여 서버에 전송



- 헤더
  - **Access-Control-Allow-Origin**: 요청을 허용할 출처를 명시, `*`는 모든 출처 허용
  - **Access-Control-Allow-Methods**: 허용할 HTTP 메서드를 명시, (`GET`, `POST`, `PUT`)
  - **Access-Control-Allow-Headers**: 클라이언트가 요청할 때 사용할 수 있는 헤더 명시
  - **Access-Control-Allow-Credentials**: 자격 증명(쿠키, HTTP 인증 등)을 사용할 수 있는지 여부를 명시
  - **Access-Control-Expose-Headers**: 클라이언트가 접근할 수 있는 응답 헤더 명시
  - **Access-Control-Max-Age**: 예비 요청의 응답을 캐시할 수 있는 시간을 초 단위로 명시



</br>

## :memo: ​소켓과 웹소켓

### 소켓

: 네트워크를 통해 두 노드 간에 데이터를 전송하기 위한 양방향 통신 채널

: 주로 TCP/IP와 같은 프로토콜 위에서 작동

- 특징
  - **양방향 통신**: 클라이언트와 서버 간에 데이터를 주고받을 수 있음
  - **연결 지향**: TCP 소켓은 연결 지향적이므로, 안정적이고 신뢰할 수 있는 데이터 전송 보장
  - **스트림 기반**: TCP 소켓은 데이터 스트림을 통해 전송
  - **포트 사용**: 네트워크 주소(아이피 주소)와 포트 번호를 사용하여 통신 상대방 식별



### 웹소켓

: 웹 브라우저와 웹 서버 간에 양방향으로 **실시간 통신**을 가능하게 하는 기술

: HTTP의 단방향 통신과 실시간 통신이 불가능한 한계점을 해결

: HTML5에서 도입된 프로토콜

- 특징
  - **양방향 통신**: 클라이언트와 서버가 모두 데이터를 보낼 수 있음
  - **전이중 통신**: 동시에 양방향 데이터 전송 가능
  - **상태 유지**: 연결이 유지되는 동안 클라이언트와 서버 간의 상태 유지
  - **저지연**: 실시간 애플리케이션에 적합한 저지연 통신 제공
  - **HTTP 업그레이드**: 초기 연결은 HTTP를 통해 설정, 이후 웹소켓 프로토콜로 업그레이드



### 소켓과 웹소켓의 차이점

| 특징             | 소켓 (Socket)                                      | 웹소켓 (WebSocket)                                     |
| ---------------- | -------------------------------------------------- | ------------------------------------------------------ |
| 프로토콜         | TCP, UDP 등 다양한 프로토콜                        | 전용 웹소켓 프로토콜 (`ws://`, `wss://`)               |
| 통신 방식        | 양방향, 주로 TCP의 경우 연결 지향                  | 양방향, 전이중 통신 가능                               |
| 초기 연결        | 소켓 API를 통해 직접 연결 설정                     | HTTP 업그레이드를 통해 연결 설정                       |
| 사용 사례        | 일반적인 네트워크 통신, 시스템 간 통신             | 실시간 웹 애플리케이션, 브라우저와 서버 간 실시간 통신 |
| 데이터 전송 방식 | 스트림 기반(TCP), 패킷 기반(UDP)                   | 메시지 기반                                            |
| 연결 유지        | TCP의 경우 연결이 지속되며, UDP의 경우 비연결 지향 | 연결이 유지되며 상태를 지속적으로 유지                 |
| 저지연 통신      | TCP는 비교적 저지연, UDP는 매우 저지연             | 매우 저지연                                            |



</br>

## :memo: ​OSI 7 계층

![image](https://github.com/SsafyStudy13/CS_Study/assets/122426072/bf115ddd-b5f6-48b8-ba21-31522b5ec237)

![image](https://github.com/SsafyStudy13/CS_Study/assets/122426072/12a7070b-fe2f-4845-863b-d09976bc02fd)

1. **물리 계층**

   : 물리적인 매체(LAN, 케이블 등)를 통해 비트 스트림 전송

   : 장비 - 허브, 리피터

   : 전송 단위 - **비트(Bits)**

   ![image](https://github.com/SsafyStudy13/CS_Study/assets/122426072/99efd622-8f03-4c6c-b15b-2fa725452c3b)

   

2. **데이터 링크 계층**

   : 물리 계층에서의 오류 없는 데이터 전송, 프레임 관리

   : 데이터 시작과 끝 부분에 제어 정보를 추가하여 에러를 확인하고 제어

   : MAC주소를 할당하여 네트워크 장비 식별

   : 장비 - 브릿지, 스위치

   : 전송 단위 - **프레임 (Frames)**

   

3. **네트워크 계층**

   : 네트워크 간의 데이터 패킷 라우팅 및 전달

   : IP 주소를 사용하여 데이터 **라우팅**, 패킷의 전달 경로 결정(**스위칭**)

   : 장비 - 라우터

   : 전송 단위 - **패킷 (Packets)**

   

4. **전송 계층**

   : 데이터 전송을 관리, 신뢰성 있는 전송 보장

   : TCP와 UDP 프로토콜을 사용하여 데이터 세그먼트 전달, 흐름 제어, 오류 검출 및 수정, 재전송

   : 장비 - 게이트웨이

   : 전송 단위 - **세그먼트 (Segments, TCP) / 데이터그램 (Datagrams, UDP)**

   

5. **세션 계층**

   : 통신 세션을 설정, 유지, 종료하고 데이터 교환의 순서를 조정

   : 전송 단위 - **데이터 (Data)**

   

6. **표현 계층**

   : 인코딩, 디코딩, 암호화, 압축 과정을 진행하여 데이터를 표준 형식으로 변환

   : 응용 계층과의 호환성 보장

   

7. **응용 계층**

   : 사용자와 직접 상호작용하는 애플리케이션과 관련된 서비스를 제공

   : 이메일, 웹 브라우저, 파일 전송 프로토콜(FTP) 등이 포함



</br>

## :memo: ​JWT (JSON Web Token)

: 사용자 인증하고 식별하기 위한 토큰 기반 인증 방식

: 인증에 필요한 정보들을 JSON 형식으로 암호화

- 구조
  - 헤더(header) : JWT에서 사용할 타입과 해시 알고리즘 종류
  - 페이로드(payload) : 서버에서 첨부한 사용자 권한 정보와 사용자 데이터, key-value 쌍으로 존재
  - 서명(Signature) : 헤더와 페이로드를 인코딩한 후, 헤더에 명시된 해시 함수를 적용하여 개인키로 서명한 전자 서명

![image](https://github.com/SsafyStudy13/CS_Study/assets/122426072/a739524c-980e-4e3d-8b3f-6a49e2d7fb79)



- 장점

  - **자체 포함(Self-contained)**

    : JWT는 필요한 모든 정보를 자체적으로 포함하고 있어, 별도의 데이터베이스 조회 없이 클라이언트의 상태 파악 가능

  - **확장성(Scalability)**

    : 서버는 JWT를 별도로 저장할 필요가 없으므로, 상태를 저장하는 데 따른 서버 부하가 줄어들고 확장성이 높아짐

  - **보안(Security)**

    : 서명된 JWT는 데이터의 무결성을 보장하며, 변조를 방지할 수 있음

  - **상호 운용성(Interoperability)**

    : JSON 형식의 클레임을 사용하여 다양한 시스템 간에 쉽게 전송하고 해석할 수 있음



- 단점

  - **토큰 크기(Token size)**

    : JWT는 정보가 인코딩된 형태로 저장되므로, 페이로드의 크기에 따라 토큰 크기가 커질 수 있음 → 네트워크 대역폭과 저장 공간이 더 많이 소모될 수 있음

  - **보안 취약점(Security vulnerabilities)**

    : 클라이언트에 저장된 JWT가 탈취되면, 유효 기간 동안 공격자가 토큰을 사용할 수 있음

  - **토큰 무효화(Token revocation)**

    : JWT는 상태가 유지되지 않으므로, 한 번 발급된 토큰을 서버에서 무효화하기 어려움

    : 유효 기간을 짧게 설정하여 refresh token을 자주 갱신해야함



</br>

## :memo: ​웹 요청 과정

- `https://www.google.com/` 을 입력했을 때, 발생하는 일?
  1. 브라우저가 URL을 해석하여 프로토콜, 호스트, 경로, 포트를 식별
  2. 브라우저는 DNS 서버에 URL에 해당하는 IP 주소를 요청, DNS는 IP 주소 반환
  3. 반환된 IP 주소를 바탕으로 접속하고자 하는 서버로 요청을 보냄
     1. 라우터의 라우팅을 통해 경로를 지정
     2. ARP를 통해 논리 주소인 IP주소를 물리 주소인 MAC 주소로 변환
     3. IP 주소와 HTTPS의 기본 포트(443)을 사용하여 TCP 연결 설정 (3-way handshake)
  4. 서버는 요청을 수신하고 요청된 리소스를 처리한 후, HTTP 응답으로 브라우저에 반환
  5. 브라우저는 응답을 수신하고, 받은 리소스를 이용해 DOM(Document Object Model)을 구성, CSSOM(CSS Object Model)과 결합하여 렌더 트리 생성 → 웹 페이지 화면 렌더링



</br>

## :memo: ​IP

### 공인 IP (Public IP)

: ISP(인터넷 서비스 공급자)가 할당하는 IP 주소

- 특징

  - **고유성**

    : 공인 IP 주소는 전 세계에서 유일, 중복되지 않음

  - **인터넷 접근성**

    : 공인 IP 주소는 인터넷에 직접 연결되어 있어, 전 세계 어디서나 접근 가능

  - **할당 및 관리**

    : 공인 IP 주소는 ISP 또는 인터넷 할당 번호 기관(IANA, ICANN)에 의해 할당되고 관리됨

- 예시

  - 웹 서버
  - 메일 서버



### 사설 IP (Private IP)

: 일반 가정이나 회사 내 등에 할당된 네트워크의 IP 주소

: IPv4의 주소 부족으로 인해 서브넷팅된 IP이기 때문에 라우터에 의해 로컬 네트워크상의 PC 나 장치에 할당

: NAT(Network Address Translation)을 통해 공인 IP 주소로 변환되어 인터넷과 통신할 수 있음

: 로컬 IP, 가상 IP 라고도 함

- 특징

  - **중복 허용**

    : 사설 IP 주소는 여러 내부 네트워크에서 중복되어 사용될 수 있음

  - **인터넷 접근 불가**

    : 사설 IP 주소는 직접적으로 인터넷에 접근할 수 없으며, NAT를 통해서만 인터넷에 접근할 수 있음

  - **범위 지정**

    : 사설 IP 주소는 RFC 1918에 따라 지정된 IP 범위를 사용

    : IPv4 주소 범위

    	- 10.0.0.0 ~ 10.255.255.255 (10.0.0.0/8)

    - 172.16.0.0 ~ 172.31.255.255 (172.16.0.0/12)
    - 192.168.0.0 ~ 192.168.255.255 (192.168.0.0/16)



</br>

## :memo: DNS (Domain Name System)

: 도메인 이름을 IP 주소로 변환하는 시스템

: 최상위 도메인(TLD)부터 하위 도메인까지 계층적으로 구성됨

: 전 세계 여러 DNS 서버에 의해 유지되는 분산 데이터베이스를 기반으로 동작

​	→ 하나가 고장나도 다른 서버에서 주소 정보를 제공할 수 있음

: 이전에 해석한 도메인 이름과 IP 주소의 매핑 정보를 **캐싱**하여, 이후 동일 요청에 대해 빠르게 응답 가능



