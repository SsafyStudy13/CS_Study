블로그 링크 : https://no-delay.tistory.com/91

## 1. 프로세스와 스레드에 대해 설명해주세요.

프로세스는 운영체제에서 실행되는 독립적인 프로그램 단위로, 각 프로세스는 자체 메모리 공간을 가지고 자원을 할당받아 실행됩니다.

스레드는 프로세스 내에서 실행되는 더 작은 실행 단위로, 동일한 메모리 공간을 공유하며 병렬 처리를 통해 성능을 향상시킬 수 있습니다. 하지만, 동기화 문제를 신경써야 합니다.

### 프로세스

실행 중인 프로그램의 인스턴스로, 운영체제에서 자원을 할당받아 실행되는 독립적인 작업 단위입니다.

### 스레드

스레드는 프로세스 내에서 실행되는 작은 실행 단위로, 하나의 프로세스는 여러 개의 스레드를 가질 수 있습니다.

동기화 문제는, 스레드가 동일한 자원을 공유하기 때문에 발생하는 문제로, 뮤텍스와 세마포어 등의 동기화 기법이 사용됩니다.

이에 대한 예시로, 크롬 웹 브라우저의 각각의 탭은 프로세스이며, 멀티 스레드 환경입니다.

| 항목 | 프로세스 | 스레드 |
| --- | --- | --- |
| 메모리 사용 | 독립적인 메모리 공간 사용 | 동일한 프로세스 내에서 메모리 공유 |
| 자원 할당 | 각 프로세스는 자원을 독립적으로 할당받음 | 프로세스 내 자원 공유 |
| 문맥 교환 오버헤드 | 상대적으로 큼 | 상대적으로 작음 |
| 독립성 | 높음 | 낮음 |
| 안정성 | 한 프로세스의 문제는 다른 프로세스에 영향을 주지 않음 | 한 스레드의 문제는 다른 스레드에 영향을 줄 수 있음 |
| 동기화 문제 | 없음 | 있음 |

## 2. 데드락이란 무엇인지, 방지할 수 있는 방법에는 어떤 것들이 있는지 설명해주세요.

![image](https://github.com/SsafyStudy13/CS_Study/assets/57094856/00dec57f-76b4-4409-ab4b-38ef544bd920)

### **DeadLock이란?**

두 개이상의 프로세스 혹은 스레드가 서로가 가진 리소스를 기다리는 상태  
교착 상태 → 무한 대기

교착 상태는 아래의 사진을 보면 이해가 쉬울거다. 일을 하고 싶은데 할 수 없는 것이다...

![image](https://github.com/SsafyStudy13/CS_Study/assets/57094856/ca579080-4781-4b07-a5f2-2aa87aac7925)

### **Deadlock을 발생시키는 4가지 조건**

-   Mutual exclusion(상호 배제)  
    \- 리소스(critial session or lock ,cpu, 메모리, ssd 등)를 공유해서 사용할 수 없음
-   Hold and wait(점유와 대기)  
    \- 프로세스가 이미 하나 이상의 리소스를 취득한(hold)한 상태에서 다른 프로세스가 사용하고 있는 리소스를 추가로 기다림(wait)
-   No preemption(비선점)  
    \- 리소스 반환은 오직 그 리소스를 취득한 프로세스만 할 수 있음  
    \- 지난 발표에서 다른 사람이 lock을 해제하는 경우는 안됨
-   Circular wait(환형 대기)  
    \- 프로세스들이 순환 형태로 서로의 리소스를 기다림

**💡그러면 이걸 해결하는 방법은 뭐가 있을까?**

### **해결 방법**

#### 1\. Deadlock prevention(데드락 방지)

시스템 레벨에서 4가지 조건 중 하나가 충족되지 않게 디자인  
  
**Mutual exclusion** → 불가능  
**Hold and wait**  
\- 사용할 리소스들을 모두 획득한 뒤에 시작  
\- 리소스를 전혀 가지지 않은 상태에서만 리소스 요청  
\- but 리소스 사용 효율이 떨어질 수 있음 → 놀고있는 리소스가 있을 수 있기 때문  
\- but 사용할 리소스가 수요가 많다면 계속 기다려야됨 → stravation(기아 상태)  
**No preemption**  
\- 추가적인 리소스를 기다려야 한다면 이미 획득한 리소스를 다른 프로세스가 선점 가능하도록 함 → 양보  
**Circular wait**  
\- 모든 리소스에 순서 체계를 부여해서 오름차순으로 리소스를 요청(가장 많이 사용됨)

#### 2\. Deadlock avoidance(데드락 회피)

실행 환경에서 추가적인 정보를 활용해서 데드락이 발생할 것 같은 상황을 회피하는 것

**Banker algorithm**  
리소스 요청을 허락해줬을 때 데드락이 발생할 가능성이 있으면 리소스를 할당해도 안전할 때까지 계속 요청을 거절하는 알고리즘

참고 : [https://wpaud16.tistory.com/271](https://wpaud16.tistory.com/271)

![image](https://github.com/SsafyStudy13/CS_Study/assets/57094856/157530ae-fb61-47a0-b631-62dc7881dfad)

#### 3\. Deadlock detection & recovery(데드락 감지와 복구)

**감지 방법**

-   일정 시간(가벼운 데드락 검출)
    -   일정 시간동안 프로세스의 작업이 진행되지 않으면 데드락에 빠진걸로 간주
-   자원 할당 그래프 사용(무거운 데드락 검출)
    -   프로세스가 어떤 자원을 사용 중이고, 어떤 자원을 "기다리는지" 방향성 있는 그래프로 표시한 것
    -   프로세스는 원, 자원을 사각형 으로 표시

**복구 전략**

-   프로세스 종료(진행 작업을 잃을 수 있으므로 리스크 큼)
    -   모든 프로세스 종료
    -   순차적으로(우선 순위기준) 프로세스 종료 → 복구될 때까지
-   리소스의 일시적인 선점을 허용

### 4. Deadlock Ignorance(데드락 무시)

deadlock이 일어나지 않는다고 생각하고 아무런 조치도 취하지 않음  
  
\- 데드락이 매우 드물게 발생하므로 조치를 취하지 않음  
\- 데드락이 발생한 경우 사용자가 직접 다루도록 함  
\- Unix, window등 현재 대부분의 시스템이 이러한 방식을 채택하고 있음 → 데드락을 처리하는 오버헤드가 크기 때문

노션 링크

[https://spurious-astronomy-3a1.notion.site/Deadlock-beb69b2e314b4bc1a8e180715044a150?pvs=4](https://spurious-astronomy-3a1.notion.site/Deadlock-beb69b2e314b4bc1a8e180715044a150?pvs=4)

## 5. 멀티 스레드의 장단점에 대해 설명해주세요.
하나의 프로세스 내에서 여러 스레드를 생성하여 병렬로 작업을 수행하는 기술입니다.
성능 향상(병렬 작업)과 자원 효율성(자원 공유)을 높이는 데 유용하지만,
여러 스레드가 동일한 자원에 접근하면서 동기화 문제가 발생한다는 점이 있습니다.

동기화 문제에는 2가지가 있습니다.
1. 데이터 경쟁: 여러 스레드가 동일한 자원에 접근할 때, 데이터 일관성이 깨질 수 있는 상황
→ 해결을 위해 동기화 메커니즘(뮤텍스, 세마포어)를 사용해야 함
2. 교착 상태: 두 개 이상의 스레드가 서로 자원을 점유한 상태에서 상대방의 자원을 기다리며 무한 대기에 빠지는 상태

## 6. 선점형 스케줄링과 비선점형 스케줄링에 대해 설명해주세요.
운영체제에서 프로세스 스케쥴링은 CPU 시간을 여러 프로세스에게 어떻게 할당할지 결정하는 과정을 의미하며
이러한 과정은 선점형과 비선점형 스케쥴링 방식으로 나누어 집니다.

선점형 스케쥴링 방식은 실행 중인 프로세스가 있더라도 운영체제가 필요하다고 판단하면 운영체제가 프로세스를 강제로 중단시키고 다른 프로세스에게 CPU를 할당할 수 있는 방식입니다. 이는 응답성을 높이고 중요한 작업을 빠르게 처리할 수 있지만, 컨텍스트 스위칭(문맥 교환) 오버헤드와 동기화 문제를 발생 시킬 수 있습니다.

비선점형 스케쥴링 방식은 프로세스가 스스로 CPU를 반환할 때까지 실행되는 방식으로(선점형처럼 운영체제가 강제로 회수하지 않습니다), 컨텍스트 스위칭(문맥 교환) 오버헤드가 적고 구현이 단순하지만, 작업이 긴 프로세스가 CPU를 오랜시간 점유하고 있다면, 다른 프로세스의 대기시간이 길어질 수 있습니다.

| 항목 | 선점형 스케줄링 | 비선점형 스케줄링 |
| --- | --- | --- |
| 제어권 회수 | 언제든지 강제로 회수 가능 | 프로세스가 스스로 반환할 때까지 기다림 |
| 응답성 | 높음 | 낮음 |
| 문맥 교환 오버헤드 | 있음 | 없음 |
| 구현 복잡성 | 높음 | 낮음 |
| 우선순위 관리 | 유연함 | 제한적 |
| 예 | 라운드 로빈, 우선순위 스케줄링 | FCFS, SJF, 우선순위 스케줄링 |

## 7. 동기와 비동기에 대해 설명해주세요.
동기와 비동기는 작업의 수행 방식에 따라 구분됩니다.

동기는 작업이 순차적으로 수행되기 때문에 흐름이 단순하고 예측 가능하다는 특징(동기화 문제가 줄어듦)과
현재 작업이 완료되기 전까지 다음 작업이 실행되지 않는 블로킹 특징이 있습니다.

비동기는 작업이 병렬적으로 수행될 수 있으며, 현재 작업이 완료되지 않아도 다음 작업을 시작할 수 있는 논블로킹 특징이 있습니다. 이러한 특징으로 효율성, 속도가 빠른점을 갖지만, 프로그램 흐름이 복잡하고 동기화 문제를 처리해주어야 합니다.

## 9. 크롬 탭 하나는 프로세스인가요? 스레드인가요?
**크롬의 각 탭은 별도의 프로세스**로 실행됩니다. 이를 통해 한 탭이 충돌하거나 문제가 발생해도 다른 탭에 영향을 끼치지 않도록 하여 안정성을 높이고 있습니다. 하지만 각 탭이 독립적으로 메모리를 사용하다보니 많은 탭을 열 경우 메모리 사용량이 증가할 수 있습니다.

이러한 각 탭(프로세스)에는 여러 스레드가 존재하며 이러한 스레드들을 병렬로 처리합니다. 

여러 스레드에는 렌더링 스레드(HTML, CSS, JS)를 해석하고 페이지를 렌더링하는 스레드, 네트워킹 스레드, js 실행 스레드 등이 존재합니다.

## 10. 세마포어와 뮤텍스의 차이에 대해 설명해주세요.
**뮤텍스(mutex)**

임계 구역에 1개의 스레드만 들어갈 수 있는 동기화 기법

**세마포어(semaphore)**

임계 구역에 여러 스레드가 들어갈 수 있고, counter를 두어서 허용 가능한 스레드를 제한하는 기법

|  | Semaphore | Mutex |
| --- | --- | --- |
| 개수 | N개 | 하나 |
| 변화 | Mutex로 변경 가능 | Semaphore로 변경 불가능 |
| 소유 | X | O |
| 해제 | Semaphore를 가지지 않은 스레드도 해제 가능 | Mutex를 소유한 스레드만 해제 가능 |
| 함수 | wait | lock |
|  | signal | unlock |

## 11. 메모리 계층구조에 대해 설명해주세요.
![image](https://github.com/SsafyStudy13/CS_Study/assets/57094856/608be22b-a491-450d-ab9a-18b5641efde7)
메모리 계층 구조는 레지스터, 캐시, 메모리, 디스크로 구성되어있습니다.

CPU가 메모리에 더 빨리 접근 가능하게 필요에 의해서 분리 -> 디코딩(명령어 해독 단계) 속도를 높여줌, 자주 쓰는 데이터는 계속 자주 쓰임(참조의 지역성), 경제성(메모리 구조 상층일수록 비쌈)

각 계층 별 특징은 이렇습니다.

**레지스터**: CPU 내부 위치, [기억, 해석, 연산, 제어]를 관할, 특정 주소를 가리키거나 값 읽을 수 있음

CPU는 자체적으로 데이터를 저장할 방법이 없어 연산을 위해 레지스터를 거쳐야 함

**캐시**: CPU 내부 위치, 데이터나 값을 미리 복사해 놓는 임시 장소, L3와 디스크캐시는 CPU안에 위치X

**메모리**: CPU 외부 위치, 주기억장치

- RAM: 휘발성 기억 장치, 데이터를 단기간 저장하는 구성 요소
- ROM: 고정 기억 장치(비휘발성), 초기 부팅, 펌웨어 명령등 변경 가능성이 희박한 기능에 사용

**디스트**: CPU 직접 접근 불가, 비휘발성 보조 기억 장치, SSD, HDD

## 12. 컨텍스트 스위칭에 대해서 설명하고, 왜 컨텍스트 스위칭이 필요한지 설명해주세요.
컨텍스트 스위칭(문맥 교환)은 CPU가 현재 실행 중인 프로세스나 스레드의 상태를 저장하고, 다른 프로세스나 스레드의 상태를 복원하여 실행하는 작업을 의미합니다. 이를 통해 멀티태스킹 운영체제에서 여러 프로세스나 스레드가 CPU를 공유하여 실행될 수 있게 합니다.

컨텍스트 스위칭은 멀티태스킹 운영체제에서 여러 프로세스나 스레드를 효율적으로 관리하기 위해 필수적인 기능입니다. 이를 통해 시스템은 공정성을 유지하고 자원을 효율적으로 사용하며, 사용자에게 여러 작업이 동시에 수행되는 환경을 제공합니다. 그러나 컨텍스트 스위칭에는 오버헤드가 수반되므로, 이를 최소화하는 것이 시스템 성능을 높이는 데 중요합니다.
