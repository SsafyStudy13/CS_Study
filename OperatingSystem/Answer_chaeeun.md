# 운영체제 (Operating System)

~~~text
사용자 → 응용 프로그램 → 운영 체제 → 하드웨어 → 운영 체제 → 응용 프로그램 → 사용자
~~~

: 사용자가 응용 프로그램을 통해 사용할 자원들을 요청하고, 운영체제는 이를 확인하여 필요한 하드웨어에 접근하여 작업을 처리하고 응답

: **커널(Kernel)을 활용**해서 사용자의 요구에 맞는 응답을 제공하는 시스템 환경을 관리

: `(1) 연산처리 장치 → CPU`  `(2) 주기억 장치 → 메모리`  `(3) 데이터 영속 저장장치 → 디스크`

​	총 3가지 자원을 안전하고 효율적으로 다루는 기능 수행

: `사용자 인터페이스` + `시스템 호출` + `커널` + `하드웨어 드라이버`로 구성



## 프로세스와 스레드

### 프로세스

: 실행 중인 프로그램의 인스턴스

: 운영체제에서 독립적으로 실행되며, 실행 시 필요한 자원(메모리, 파일 핸들 등)을 할당 받음

- 특징

  - **독립적 메모리 공간** : 각 프로세스는 자체의 메모리 공간(주소 공간)을 가짐

  - **고립성** : 한 프로세스는 다른 프로세스에 영향을 미치지 않음

  - **자원 할당 단위** : 운영체제는 각 프로세스에 CPU 시간, 메모리 등을 할당

  - **오버헤드** : 전체 메모리 맵, 파일 디스크립터 등을 저장하고 복원해야하기 때문에 프로세스 간 컨텍스트 스위칭은 스레드에 비해 무거움

- 예시
  - 웹 브라우저
  - 텍스트 편집기
  - 계산기



### 스레드

: 프로세스를 구성하는 독립적인 실행 단위

: 하나의 프로세스는 여러 개의 스레드를 가질 수 있으며, 각 스레드는 프로세스의 메모리 공간을 공유

- 특징

  - **공유 메모리 공간** : 동일한 프로세스 내의 스레드는 프로세스의 전역 변수, 힙 메모리 등을 공유
  - **경량성** : 스레드는 레지스터, 프로그램 카운터 등만 저장하여 복원하거나 캐시 메모리를 비우지 않아도 되기 때문에 프로세스보다 컨텍스트 스위칭 오버헤드가 적음

  - **병렬 실행** : 멀티 스레딩을 통해 프로세스 내 여러 작업을 병렬로 처리할 수 있음 → CPU 성능 극대화
  - **동기화 필요** : 여러 스레드가 같은 자원에 접근할 때 동기화 문제(데드락, 레이스 컨디션)가 발생할 수 있기 때문에 이를 방지하기 위한 동기화 메커니즘(뮤텍스, 세마포어)이 필요



#### 멀티 스레드

: 하나의 프로세스 내에서 여러 스레드를 생성하여 동시에 실행하는 기법

- 장점
  - 병렬 실행으로 CPU 성능을 높일 수 있고, 응답성을 높일 수 있음
  - 프로세스보다 적은 메모리와 자원을 사용하므로, 효율적인 자원 사용이 가능
  - 스레드 간 컨텍스트 스위칭은 프로세스 간 컨텍스트 스위칭보다 빠름
  - 동일한 메모리 공간을 공유하므로, 프로세스 간 통신(IPC)에 비해 통신이 더 쉽고 빠름



- 단점
  - 여러 스레드가 동시에 자원에 접근할 수 있으므로 동기화 문제를 해결해야함
  - 수시로 상태가 변하기 때문에 디버깅과 테스트가 어려움
  - 스레드가 공유 자원을 경쟁적으로 사용할 때, 시스템 성능이 저하될 수 있음





> ### 크롬의 탭은 프로세스일까? 스레드일까?
>
> **"프로세스" 를 기반으로 함**
>
> 별도의 프로세스로 실행하여, 탭 간의 고립성을 유지 → 사이트 간 격리를 통한 보안 강화
>
> 한 탭에서 충돌이나 오류가 발생한 경우, 해당 프로세스만 종료되고 다른 탭에는 영향을 주지 않기 때문에 브라우저 전체의 안정성 향상
>
> 각 프로세스에 자원을 독립적으로 할당하고 관리할 수 있어, 효율적인 자원 관리 가능
>
> 각 탭 내에서 페이지 렌더링, 자바스크립트 실행 등은 여러 스레드를 사용하여 병렬 처리





## 데드락 (Deadlock)

: 두 개 이상의 프로세스나 스레드가 서로 상대방이 점유하고 있는 자원을 기다리며 무한정 대기하는 상태

: 자원 할당의 순환 대기 상태로 인해 아무것도 진행되지 않는 교착 상태

- 발생 조건 (Coffman 조건)
  - **상호 배제 (Mutual Exclusion)** : 자원은 한번에 하나의 프로세스만 사용할 수 있어야 함
  - **점유 및 대기 (Hold and Wait)** : 최소한 하나의 자원을 점유한 상태에서 다른 자원을 추가로 기다리는 프로세스가 있어야 함
  - **비선점 (No Preemption)** : 할당된 자원은 강제로 빼앗을 수 없고, 자원을 점유한 프로세스만 자원을 해제할 수 있어야 함
  - **순환 대기 (Circular Wait)**: 두 개 이상의 프로세스가 순환 형태로 자원을 기다려야 함



- 방지 방법
  - **상호 배제 조건 제거**
    - 일부 자원(읽기 전용 파일 등)에 대해 상호 배제를 제거할 수 있음
    - 대부분의 자원은 상호 배제가 필요하기 때문에 현실적으로 이 조건을 완전히 제거하기 어려움
  - **점유 및 대기 조건 방지**
    - 프로세스가 자원을 요청할 때, 다른 자원을 점유하고 있지 않도록 함
    - 자원을 요청할 때 필요한 모든 자원을 한꺼번에 요청하고, 자원을 모두 확보할 때까지 기다림
    - 자원을 요청하지 않는 프로세스만 자원을 요청할 수 있도록 함
  - **비선점 조건 방지**
    - 이미 할당된 자원을 강제로 회수하는 방법을 사용
    - 자원을 점유한 프로세스가 다른 자원을 요청할 때, 점유한 자원을 모두 반납하게 하고 다시 요청하게 함
    - 높은 우선순위를 가진 프로세스가 자원을 요청하면, 자원을 선점하여 우선순위가 낮은 프로세스로부터 회수
  - **순환 대기 조건 방지**
    - 자원에 순서를 부여하고, 프로세스가 자원을 할당받을 때 반드시 순서대로 할당받도록 함
    - 자원 할당 그래프를 이용하여 순환 대기를 방지할 수 있고, 자원 할당 그래프에서 사이클이 생기지 않도록 자원을 할당



- 회피 방법
  - **은행가 알고리즘 (Banker's Algorithm)**
    - 프로세스가 자원을 요청할 때, 시스템은 가용 자원을 확인하여 요청을 수락하면 안전 상태가 유지되는지 검사
    - 모든 프로세스가 안전하게 자원을 할당받을 수 있는 경우에만 자원을 할당
    - 자원의 최대 수요를 미리 알고 있어야 하고, 시스템의 부하가 증가하면 복잡도가 증가할 수 있음



## 캐시 메모리

: 데이터 접근 속도를 높이기 위해 자주 사용되는 데이터나 계산 결과를 저장해두는 임시 저장소

: CPU와 메모리 간의 속도 차이를 줄이기 위해 주로 사용

- 주요 개념
  - **캐시 히트 (Cache Hit)** : 요청한 데이터가 캐시에 존재하여 빠르게 접근할 수 있는 경우
  - **캐시 미스 (Cache Miss)** : 요청한 데이터가 캐시에 존재하지 않아 원본 저장소(메인 메모리 등)에서 데이터를 가져와야 하는 경우
  - **캐시 라인 (Cache Line)**:  캐시가 데이터를 저장하는 단위, 일반적으로 연속된 메모리 블록으로 구성



### 캐시의 지역성 (Locality)

: 캐시의 효율성을 극대화하기 위해 활용되는 개념

: 프로그램이 데이터를 접근하는 패턴



1. **시간 지역성(Temporal Locality)**

   - 최근에 접근한 데이터에 다시 접근할 가능성이 높은 특성
   - 최근에 사용된 데이터를 캐시에 보관하여, 이후 접근 시 빠르게 제공함으로써 성능을 향상
   - 예시 : 반복문 내에서 같은 변수에 여러 번 접근하는 경우

   

2. **공간 지역성(Spatial Locality)**

   - 특정 메모리 위치에 접근한 후, 그 근처에 있는 데이터에 접근할 가능성이 높은 특성
   - 데이터가 연속적으로 저장된 경우, 한 번에 더 큰 블록을 캐시에 로드하여 근처 데이터 접근 시 빠르게 제공
   - 예시 : 배열에 순차적으로 접근하는 경우, 구조체의 여러 멤버를 연속적으로 접근하는 경우



## 커널 (Kernel)

: 운영체제의 핵심적인 부분으로,  모든 프로그램을 제어하는 시스템 프로그램

: 하드웨어 - 소프트웨어 간 상호 작용 관리

: 시스템 자원의 효율적 관리



- 관리하는 자원

  1. 프로세스 : CPU 시간을 효율적으로 분배하기 위해 프로세스를 스케줄링
  2. 메모리 : 가상 메모리를 사용하여 물리적 메모리보다 더 큰 주소 공간을 사용할 수 있도록 함
  3. 저장장치 : 디스크 스케줄링 알고리즘을 사용하여 디스크 I/O 요청을 최적화

  → 운영체제의 성능과 안전이 달려 있는 영역



- **커널 모드**

  : 커널이 실행되는 특권 모드, 모든 시스템 자원에 접근 가능



- **사용자 모드**

  : 사용자 프로그램이 실행되는 제한된 모드, 커널이 허용한 자원만 접근할 수 있음 → 시스템의 안정성과 보안 유지



- **시스템 호출(System Calls)**

  : 사용자 프로그램이 커널 기능을 요청할 때 사용하는 인터페이스

  : 사용자 모드에서 커널 모드로 전환되어 커널 함수가 실행되고, 결과가 사용자 모드로 반환

  예시 : 파일 읽기/쓰기, 프로세스 생성/종료, 메모리 할당 등



## 스케줄링 (Scheduling)

: 운영 체제가 CPU 시간을 여러 프로세스에 할당하는 방식

: 다양한 프로세스가 시스템 자원을 효율적으로 사용하도록 관리

→ 시스템 성능을 최적화, 사용자 응답성 향상, 공정성 보장



- 특징
  - **공정성 (Fairness)** : 모든 프로세스가 CPU 시간을 공평하게 받을 수 있도록 함
  - **효율성 (Efficiency)** : 시스템 자원을 최대한 활용하여 높은 처리량을 유지
  - **응답 시간 (Response Time)** : 사용자 인터랙션이 필요한 프로세스의 응답 시간을 최소화
  - **처리량 (Throughput)** : 단위 시간당 처리되는 프로세스의 수를 최대화
  - **대기 시간 (Waiting Time)** : 프로세스가 대기 큐에서 기다리는 시간을 최소화
  - **턴어라운드 시간 (Turnaround Time)** : 프로세스가 제출된 시점부터 완료되는 시점까지의 시간을 최소화



### 선점형 스케줄링 (Preemptive Scheduling)

: 운영 체제가 현재 실행 중인 프로세스를 중단하고, 다른 프로세스에게 CPU를 할당할 수 있는 방식



- 특징
  - 짧은 작업이나 높은 우선순위 작업이 먼저 실행되므로 응답 시간 빠름
  - 사용자 응답성을 높이기 때문에 대화형 시스템에 적합
  - 프로세스 전환이 빈번하게 발생하여 컨텍스트 스위칭 오버헤드가 증가, 복잡성 증가



- 예시

  - **라운드 로빈 (Round Robin)**

    : 각 프로세스는 동일한 시간 할당량(Time Quantum)을 가지고 순서대로 CPU를 사용

    : Time Quantum이 짧을수록 응답성이 좋아지지만, 컨텍스트 스위칭 오버헤드가 증가

  - **최소 잔여 시간 우선 (Shortest Remaining Time First)**

    : 남은 실행 시간이 가장 짧은 프로세스가 우선적으로 실행

    : 프로세스의 남은 실행 시간을 예측할 수 있는 경우에 유용

  - **선점형 우선순위 스케줄링 (Preemptive Priority Scheduling)**

    : 우선순위가 높은 프로세스가 먼저 실행

    : 현재 실행 중인 프로세스보다 우선순위가 높은 새로운 프로세스가 도착하면, 현재 실행 중인 프로세스를 중단하고 우선순위가 높은 프로세스에게 CPU를 할당함. 중단된 프로세스는 대기 상태로 전환되고, 이후 다시 스케줄링

    : 우선순위가 낮은 프로세스가 무한히 대기할 수 있는 기아 상태를 방지하기 위해 에이징 기법을 사용



### 비선점형 스케줄링 (Non-preemptive Scheduling)

: 한 번 CPU를 할당받은 프로세스가 자발적으로 CPU를 반납할 때까지 실행을 계속하는 방식

: 프로세스가 완료되거나, 입출력 작업을 위해 대기 상태로 전환될 때 프로세스 전환 발생



- 특징
  - 선점형 스케줄링에 비해 간단한 구현, 보다 적은 컨텍스트 스위칭 오버헤드
  - 프로세스의 실행 순서가 예측 가능하여 실시간 시스템에 유리
  - 긴 작업이 실행 중일 때 다른 프로세스는 대기해야 하므로, 응답 시간이 길어질 수 있음



- 예시

  - **FCFS (First-Come, First-Served)**

    : 도착한 순서대로 프로세스를 실행

    : 단순하지만, 긴 작업이 먼저 도착하면 이후 작업의 대기 시간이 길어질 수 있음

  - **SJF (Shortest Job First)**

    : 실행 시간이 가장 짧은 프로세스를 먼저 실행

    : 평균 대기 시간을 최소화하지만, 긴 작업이 무한히 대기할 수 있는 기아 상태가 발생할 수 있음

  - **비선점형 우선순위 스케줄링 (Non-preemptive Priority Scheduling)**

    : 우선순위가 높은 프로세스가 먼저 실행

    : 현재 실행 중인 프로세스가 완료되거나, 입출력 작업을 위해 대기 상태로 전환될 때까지 계속 실행. 현재 실행 중인 프로세스가 중단되지 않으며, 우선순위가 높은 새로운 프로세스가 도착해도 기존 프로세스가 끝날 때까지 기다림

    : 우선순위가 낮은 프로세스가 무한히 대기할 수 있는 기아 상태가 발생할 수 있으며, 이를 방지하기 위해 에이징 기법을 사용할 수 있습니다.



## 동기와 비동기

### 동기 (Synchronous)

: 작업들이 순차적으로 실행되며, 이전 작업이 완료될 때까지 다음 작업이 대기하는 방식

: 직관적인 코드

: 한 작업이 끝날 때까지 다음 작업이 시작되지 않으므로, 작업이 오래 걸리면 전체 프로세스가 지연될 수 있음 → **블로킹**



### 비동기 (Asynchronous)

: 작업들이 병렬로 실행되는 방식

: 각 작업의 완료 시점은 독립적

: 복잡한 코드 + 동기화 문제 해결 필요할 수 있음

: 시스템 자원의 활용이 최적화되어 높은 응답성과 성능 제공



## 스레싱

: CPU 시간 대부분을 페이지 교체 작업에 할애하여 실제로 유용한 작업이 거의 이루어지지 않는 상태

: 주로 가상 메모리 환경에서 발생



- 원인

  - **과도한 페이지 부재 (Page Fault)**

    : 프로세스가 필요로 하는 페이지가 메모리에 없어서 디스크에서 페이지를 가져와야 할 때 발생

    : 페이지 부재가 자주 발생하면, 프로세스는 대부분 페이지 교체 작업으로 인해 CPU를 소비하게 됨

  - **과도한 프로세스 동시 실행**

    : 너무 많은 프로세스가 동시에 실행될 때, 각 프로세스가 메모리를 경쟁적으로 사용하면서 페이지 부재가 자주 발생할 수 있음

    : 이로 인해 모든 프로세스가 페이지 부재를 경험하고, CPU는 페이지 교체를 위한 작업에만 집중



- 결과
  - 시스템이 거의 모든 시간을 페이지 교체에 할당하므로 실제 유용한 작업이 실행되지 않고 CPU 사용률만 급격히 증가
  - 모든 프로세스가 메모리에 필요한 페이지를 얻지 못하고 대기하게 되어 페이지 부재율 급증
  - 사용자와 시스템의 반응이 느려지며, 시스템이 느려져 사용자 응답 시간 증가



- 방지 방법

  - 페이지 교체 알고리즘

    : 페이지 부재 최소화 목적

    : LRU(Least Recently Used) 와 같은 최적화 페이지 교체 알고리즘 사용

  - 과도한 프로세스가 동시에 실행되지 않도록 시스템 자원과 프로세스 관리 제어

  - 각 프로세스 별 적정 메모리를 할당하여 페이지 부재를 줄임

  - 스와핑 작업을 최적화하여 디스크와 메모리 사이의 데이터 전송을 효율적으로 관리



## 세마포어와 뮤텍스

: 다중 스레드 환경에서 동기화를 달성하기 위한 도구

: 공유 자원에 대한 접근을 조절하는 데 사용



### 세마포어 (Semaphore)

: 정수형 변수를 사용하여 현재 공유 자원에 접근할 수 있은 프로세스, 스레드의 수를 표현하는 메커니즘

: 세마포어 값은 음수가 될 수 있음



- 특징

  - 공유 자원에 대한 접근을 조절하여 동기화 가능

  - 세마포어 연산

    1. **P (wait)** 연산

       : 자원을 사용하기 위해 대기하거나 잠금

       : 세마포어 값을 감소시키고 자원을 할당받을 때까지 대기

    2. **V (signal)** 연산

       : 자원 사용을 마치고 세마포어를 해제

       : 세마포어 값을 증가시키고 대기 중인 스레드 실행

  - `이진 세마포어`, `카운팅 세마포어` 로 나뉨



### 뮤텍스

: 공유 자원에 대한 접근을 단일 스레드에게만 허용하는 메커니즘

: 하나의 프로세스, 스레드에 의해 소유될 수 있는 Key를 기반으로 한 상호배제 기법



- 특징

  - 한 번에 하나의 스레드만이 뮤텍스를 소유하고 공유 자원에 접근할 수 있음

  - `잠금(locked)` , `해제(unlocked)` 두 가지 상태를 가짐

  - 뮤텍스 연산

    1. **Lock (Acquire)** 연산

       : 뮤텍스를 획득하고 자원에 접근할 수 있도록 함

       : 다른 스레드가 뮤텍스를 획득할 때까지 대기

    2. **Unlock (Release)** 연산

       : 뮤텍스를 해제하고 다른 스레드가 뮤텍스를 획득할 수 있도록 함



|        | 세마포어                                                     | 뮤텍스                                                       |
| ------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 목적   | 여러 자원을 동시에 접근할 수 있도록 제어                     | 공유 자원에 대한 접근을 하나의 스레드에만 허용 (상호 배제 구현) |
| 값     | 음수 값을 포함하여 여러 상태 나타낼 수 있음                  | 주로 잠금, 해제만을 의미하는 이진 값을 사용                  |
| 소유자 | 특정 자원에 대한 접근을 허용하는 모든 스레드가 세마포어 조작 가능 | 뮤텍스를 소유하고 있는 스레드만 뮤텍스 해제 가능             |
|        | 상대적으로 복잡한 동기화 문제 해결 가능                      | 단순하고 직관적이며, 상호 배제를 위한 목적으로 주로 사용     |



## 메모리 계층 구조

: 컴퓨터 시스템에서 메모리를 여러 수준으로 나타낸 개념

: CPU가 메모리에 빠르게 접근할 수 있도록 함



![image](https://github.com/SsafyStudy13/CS_Study/assets/122426072/21e04e69-d932-448c-8c0f-ad8f9c14dec1)

### 중앙 처리 장치(CPU, Central Processing Unit)

![image](https://github.com/SsafyStudy13/CS_Study/assets/122426072/9797b400-b9ed-4baf-9389-f4684943f7c7)

: 컴퓨터에서 4대 주요 기능을 관할하는 장치

​	→ 기억, 해석, 연산, 제어

: CPU는 자체적으로 데이터를 저장할 방법이 없어 메모리로 직접 데이터 전송 불가능

​	→ 연산을 위해 반드시 레지스터를 거침



### 레지스터 (Register)

: CPU가 요청을 처리하는 데 필요한 데이터를 일시적으로 저장하는 기억장치

: 프로세서에 위치한 고속 메모리로, 빠른 사용 가능



- CPU 내부 레지스터 종류
  - 프로그램 계수기 (PC, Program Counter)
  - 누산기 (AC, ACcumulator)
  - 명령어 레지스터 (IR, Instruction Register)
  - 상태 레지스터 (SR, Status Register)



### 캐시 (Cache)

: 데이터나 값을 임시 저장하는 장소

: 시스템 효율성 향상에 도움

: 속도가 빠른 장치와 느린 장치 사이에서 속도차에 따른 병목 현상을 완화하기 위한 범용 메모리



- 종류

  - CPU 캐시

    : 대용량의 메인 메모리 접근을 빠르게 하기 위해 CPU 칩 내부나 바로 옆에 탑재하는 작은 메모리

    : 하드웨어를 통해 관리

    : L1, L2, L3 캐시가 있음

  - 디스크 캐시

    : 하드디스크에 내장된 컴퓨터에서 소유하고 있는 메모리

  - 그 외

    : 소프트웨어적으로 관리

    : 페이지 캐시가 해당



### 메모리 (Memory)

: 주기억 장치로서 컴퓨터에서 수치, 명령, 자료를 기억하는 하드웨어 장치

: RAM과 ROM으로 구성

- RAM (Random Access Memory) 

  : 휘발성 기억 장치

  : 빠른 접근을 위한 단기간 데이터 저장

  : 전원이 유지되는 동안 CPU의 연산 및 동작에 필요한 모든 내용 저장

  : 어느 위치든 같은 속도로 접근하고 쓸 수 있음

- ROM (Read Only Memory)

  : 고정 기억 장치, 비휘발성 메모리

  : 전원 종료 되어도 데이터 유지 가능



### 하드 디스크 드라이브(HDD, Hard Disk Drive)

: 비휘발성, 순차접근이 가능한 컴퓨터의 보조 기억 장치

: 용량 대비 가격이 가장 저렴



## 컨텍스트 스위칭

: CPU가 한 프로세스나 스레드에서 다른 프로세스나 스레드로 전환하는 과정



- 과정

  1. **현재 상태 저장**

     : CPU는 현재 실행 중인 프로세스 또는 스레드의 상태(레지스터 값, 프로그램 카운터 등)를 저장

  2. **새로운 상태 로드**

     : 다음에 실행할 프로세스 또는 스레드의 상태를 레지스터에 로드

  3. **제어권 전환**

     :  CPU는 새로운 프로세스나 스레드로 제어권을 넘기고, 해당 프로세스 또는 스레드가 실행



- 필요성

  - 컨텍스트 스위칭을 통해 여러 프로세스나 스레드가 동시에 실행될 수 있음

  - 여러 프로세스 또는 스레드가 동시에 메모리, 입출력 장치 등의 시스템 자원을 공유할 수 있음

    → 자원의 효율적 사용

  - 사용자가 여러 작업을 동시에 수행할 수 있어 각 작업에 대한 빠른 응답 가능

  - 시스템은 여러 작업을 분리하고 병렬로 실행하여 처리량을 늘리고 성능을 향상시킴

