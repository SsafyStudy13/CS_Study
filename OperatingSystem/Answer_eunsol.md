# 운영체제

### 프로세스와 스레드에 대해 설명해주세요. (송채은)

[https://jerryjerryjerry.tistory.com/178](https://jerryjerryjerry.tistory.com/178) : 프로세스란?

[https://jerryjerryjerry.tistory.com/184](https://jerryjerryjerry.tistory.com/184) : 스레드란?

## 💡프로세스

- **실행 중인 프로그램**
- 운영체제에 의해 관리되며 **독립적으로 실행**되고 **자원을 할당 받을 수 있는 단위**
- 메모리에 올라와 실행되고 있는 프로그램의 인스턴스 (독립적인 개체)
- 하드디스크에 있는 프로그램 실행 → **메모리 할당** → 할당된 메모리 공간으로 **바이너리 코드가 올라감** → CPU가 이 데이터의 코드를 한 줄 씩 읽어나가며 실행 → 이때 **메모리에 올려진 데이터를 프로세스**라고 함

### 📌**프로세스의 구조**

- 프로세스를 실행시키기 위해서는 코드의 데이터를 메모리에 올려 실행시켜야 함
- 이때 프로세스마다 고유한 가상 메모리 공간을 제공하며 이 공간은 4개로 나뉨
1. **code 영역 (Text Segment)**
    - 작성한 코드가 저장되는 공간
    - 코드는 컴파일 되어 0과 1로 변환된 기계어가 저장됨
2. **Data 영역**
    - 작성한 코드에서 선언된 전역 변수, 정적 변수, 상수 등을 저장
    - 초기화된 변수와 초기화되지 않은 변수들이 나눠서 저장됨
    - 데이터 영역은 프로그램의 시작 시 초기화되며, 프로세스가 종료될 때까지 유지됨
3. **Stack**
    - 작성한 함수에서 지역변수, 매개변수, return 주소 등을 저장
    - 알고리즘에서 사용하는 stack 구조를 사용해서 stack이라고 부름
    - 프로세스마다 독립적인 stack을 가질 수 있고, stack 포인터를 통해 stack의 상태를 관리
    - 함수가 호출되면 stack 공간이 생성되며 함수가 종료되면 제거됨
4. **Heap**
    - 작성한 코드에서 동적으로 생성되는 데이터 구조나 객체들을 저장
    - ex) 객체나 배열을 생성했을 때 프로그램 실행마다 얼마큼의 데이터가 추가될지 모름 → 데이터가 추가됨에 따라 유동적으로 공간을 늘릴 수 있는 게 힙 영역
    - 동적으로 할당되는 메모리 영역으로 프로세스가 실행 중에 동적으로 메모리를 할당 받고 해제하는 데 사용
    - 프로세스의 주소 공간의 나머지 영역에 위치하며 크기는 동적으로 확장될 수 있음

### 📌프로세스의 상태

- 프로세스를 처리할 때 5가지의 프로세스 상태 생명주기에 따라 프로그램을 처리

![Untitled](%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%20db57a2d26f41487798aedbc0e6aa5eb9/Untitled.png)

1. **프로세스 생성 (new)**
    - 프로세스가 생성된 상태
    - 생성만 되었고 아직 실행되기 위한 자원을 할당 받지 못한 상태
2. **실행 가능 (ready)**
    - 프로세스가 실행을 기다리는 상태
    - 프로세스가 필요한 자원을 모두 할당 받았으며, 실행을 위한 준비가 완료되었지만 CPU를 할당 받지 못한 상태
    - CPU를 할당 받기 위해 스케쥴링 대기열(Queue)에 들어감
3. **실행 상태 (running)**
    - 프로세스가 CPU를 할당 받아 실제로 코드를 실행하는 상태
    - 프로세스가 작업을 처리하고 결과를 만들어 냄
4. **대기 (blocked)**
    - 프로세스 처리 중에 작업 시간이 초과되거나 자원 사용을 위해 대기해야 하는 이벤트가 발생해서 프로세스가 잠시 멈춘 상태
    - CPU를 사용하지 않음
    - 특정 자원을 사용할 수 있을 때까지 실행을 멈추고 다시 대기열(Ready Queue)로 들어가게 되며, 프로세스 처리 가능 상태가 되면 실행(running) 상태로 변경
5. **종료 (terminated, exit)\**
    - 프로세스의 실행이 완료되어 종료된 상태
    - 할당된 자원이 해제되고 프로세스의 메모리 공간은 운영체제에 반환

### 📌프로세스의 PC와 SP

- 프로세스가 실제로 돌아가려면 PC(Program Counter)와 SP(Stack Pointer)가 필요함
- 컴퓨터에는 프로세스를 처리하기 위한 2가지 레지스터 PC, SP가 있음
- 프로세스의 실행 및 메모리 관리와 관련된 역할
1. **PC**
    - 실행할 명령어의 주소를 가리키는 레지스터
    - 코드 실행 → 한 줄 씩 내려가며 실행 → 프로세스는 한 줄을 처리 후 다음 실행할 코드가 어딘지 알려줘야 코드를 찾아서 실행할 수 있음 → 이때 코드의 주소를 저장하는 레지스터
    - 프로세스는 명령어를 순차적으로 실행하면서 PC 값을 증가시켜 다음에 실행할 명령어를 가리킴
    - PC는 프로그램의 흐름을 제어하는 역할
    - 프로세스가 명령어를 실행하다가 분기나 점프 명령어를 만나면 PC의 값을 분기된 주소로 변경하여 해당 명령어를 실행
    - PC는 프로세스가 중단되거나 인터럽트(예외 상황)가 발생했을 때 현재 실행 중이던 명령어의 주소를 저장 → 다시 프로세스가 실행되었을 때 주소를 찾아가 재실행 시킬 수 있는 역할
2. **SP**
    - 현재 실행 중인 프로세스의 스택의 최상단을 가리키는 레지스터
    - 코드를 작성할 때 가장 최근에 호출한 함수 순서대로 스택에 쌓임 → 가장 최근에 호출된 함수(=최상단 함수)의 위치를 알고 있으면 어디까지 함수가 호출되어있는지 프로세스가 알 수 있음
    - 스택 프레임의 시작 주소를 가리키며 스택에 데이터를 저장하거나 불러올 때 사용
    - 함수 호출 시에는 SP가 감소하여 스택에 새로운 스택 프레임을 생성
    - 함수가 반환 되면 SP가 증가하여 이전 스택 프레임으로 되돌아감
    - SP는 프로세스의 스택 영역을 관리하고 스택 오버플로우와 같은 문제를 방지하기 위해 제한된 메모리 영역을 사용하는 등의 역할을 수행

### 📌PCB(Process Control Block)

- 프로그램이 실행되면 프로세스의 정보를 저장하는 별도의 공간이 따로 생기게 됨
- 운영체제의 커널 또한 하나의 프로그램이므로 프로세스와 같이 정보를 저장할 수 있는 공간이 생김
- 커널의 데이터 영역에서는 각 프로세스의 상태, CPU 사용의 정보, 메모리 사용 정보 등 각종 자원을 관리하기 위해 PCB라는 공간을 둠
- 운영체제가 프로세스를 관리하기 위해 사용하는 데이터 구조
- PCB는 각 프로세스마다 유지되며 해당 프로세스의 상태 정보와 제어 정보를 저장
- 프로세스가 생성되면 운영체제는 PCB를 할당하고 프로세스가 종료되면 해당 PCB를 해제
- PC, SP가 PCB에 저장됨
- PCB가 존재하기에 우리의 프로그램이 잠시 중단된 상태에서 다시 실행할 때 처음부터 되돌아가 실행하지 않고 실행을 이어서 처리할 수 있음
- ex) 작업관리자 창에서 현재 실행 중인 프로세스들을 모두 확인할 수 있음 → 이 정보들을 PCB에서 불러옴
- PCB가 저장하는 내용
1. 프로세스 상태
    - 프로세스의 현재 상태 (실행, 준비, 대기 등)
2. 프로그램 카운터
    - 프로세스가 다음에 실행할 명령어의 주소를 가리킴
3. 레지스터
    - 프로세스가 현재 실행되는 동안 사용되는 레지스터 값들을 저장
4. 스케줄링 정보
    - 프로세스의 우선순위, 할당 된 CPU 시간, 스케줄링 알고리즘과 관련된 정보 등 스케줄링에 필요한 정보를 포함
5. 메모리 관리 정보
    - 프로세스가 사용하는 메모리 공간의 주소 범위, 페이지 테이블, 메모리 할당 정보 등과 같이 메모리 관리에 필요한 정보를 저장
6. 입출력 상태
    - 프로세스가 현재 사용 중인 입출력 장치와 관련된 정보를 포함

## 💡스레드

- **프로세스 내부에서 실행되는 작은 작업 단위**
- 프로세스의 실행 흐름을 구성하는 단위
- **하나의 프로세스는 내부에 여러 개의 스레드가 포함될 수 있음**

### 📌특징

- 프로세스들이 서로의 데이터에 접근하는 것이 직접적으로 불가능한데 반면 스레드는 프로세스 내부에 존재하기에 프로세스의 데이터 영역에 접근이 가능
- 스레드끼리 서로의 데이터에 접근 가능
- 스레드도 일종의 작업 단위라서 프로세스처럼 작업이 처리됨
- 스레드도 프로세스처럼 작업을 병렬로 처리해서 속도를 높일 수 있음
- 스레드는 일종의 함수로 구현됨
- 스레드도 함수라서 데이터(지역 변수)를 다루고 데이터를 관리하기 위해 스택 메모리 영역을 가짐
- 이 스택 공간은 프로세스가 가지는 스택 메모리 영역과는 별개이며 스레드의 메모리 영역을 **스레드 스택**이라고 부름

### 📌장점

1. **응답성(성능) 향상**
    - 스레드 간의 작업 분할과 병렬 처리로 인해 사용자가 응용 프로그램을 원활하게 사용하는데 빠른 응답성을 제공
2. **자원 공유 효율성 향상**
    - 스레드는 하나의 프로세스 내에서 실행되기 때문에 프로세스의 자원을 공유하여 접근할 수 있음
    - 프로세스 내부에 있기 때문에 별도의 메모리 공간을 할당할 필요없이 프로세스 내부에서 데이터를 관리
3. **동시성**
    - 여러 개의 스레드가 동시에 실행될 수 있어 작업을 병렬로 처리 가능
4. **간결성**
    - 작업을 분리할 수 있어 코드가 간결해짐

### 📌단점

1. **스레드 간의 상호 간섭**
    - 멀티 스레드가 실행 중인 상황에 스레드 간의 상호간섭 문제가 발생할 수 있음
2. **성능 저하**
    - 스레드를 많이 생성하면 성능 저하가 발생할 수 있음
    - 스레드 스케줄러에서 각각의 스레드들이 병렬로 실행되기 위해 컨텍스트 스위칭이 빈번하게 발생해야 하기 때문에 성능 저하가 발생할 수 있음
3. **동기화 이슈**
    - 여러 스레드가 공유 자원에 동시에 접근할 때 동기화 문제가 발생할 수 있음
4. **자원 소비**
    - 스레드는 개별적인 실행 흐름을 가지기 때문에 스레드마다 스택 및 레지스터 등의 메모리 자원을 소비함 → 스레드의 수가 증가하면 메모리 사용량도 증가하게 되어 시스템 자원이 한계에 도달할 수 있음

### 📌멀티 스레드와 멀티 프로세스

1. **멀티 스레드**
    - **하나의 프로세스 내부에서 여러 개의 스레드가 동시에 실행되는 것**
    - 스레드끼리는 서로의 메모리 공간(스레드 스택)을 공유하고 접근할 수 있음
    - IPC 통신이 아닌 메모리 기반 통신을 사용하기에 통신 속도가 빠름
    - 각 스레드들은 여러 자원을 공유하기에 하나의 스레드에 문제가 생기면 나머지 스레드들도 영향을 받을 수 있음
    - 프로세스 내에서 스레드의 작업을 여러 개로 분할하여 병렬로 처리할 수 있음
2. **멀티 프로세스**
    - **여러 개의 독립적인 프로세스가 동시에 실행되는 것**
    - 각 프로세스는 독립된 메모리 공간을 가지며 서로에게 접근하려면 IPC 기법을 사용해야 함
    - 각 프로세스는 각각 고유한 자원을 관리하고 있어 서로에게 영향을 미치지 않음
    - 하나의 프로세스 작업을 여러 개로 분할하여 병렬로 처리할 수 있음
    - 이때, 프로세스는 스레드 단위로 작업을 분할함

### 데드락이란 무엇인지, 방지할 수 있는 방법에는 어떤 것들이 있는지 설명해주세요. (송채은)

- 데드락
    - 두 개 이상의 프로세스나 스레드가 서로 자원을 얻지 못해서 다음 처리를 하지 못하는 상태
    - 시스템적으로 한정된 자원을 여러 곳에서 사용하려고 할 때 발생
- 일어나는 경우
    
    ![Untitled](%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%20db57a2d26f41487798aedbc0e6aa5eb9/Untitled%201.png)
    
    - t1 : 프로세스1이 자원1을 얻음 / 프로세스2가 자원2를 얻음
    - t2 : 프로세스1이 자원2를 기다림 / 프로세스2가 자원1을 기다림
    - 현재 서로 원하는 자원이 상대방에 할당되어 있어 두 프로세스는 무한정 wait 상태에 빠짐
    - 멀티 프로그래밍 환경에서 한정된 자원을 얻기 위해 서로 경쟁하는 상황 발생
    - 한 프로세스가 자원을 요청했을 때, 동시에 그 자원을 사용할 수 없는 상황이 발생할 수 있음 → 이때 프로세스는 대기 상태로 들어감
    - 대기 상태로 들어간 프로세스들이 실행 상태로 변경될 수 없을 때 교착 상태 발생
- 발생 조건 (4가지 모두 성립해야 데드락 발생)
    - **상호배제**
        - 자원은 한 번에 한 프로세스만 사용할 수 있음
        - *상호 배제 부정 : 여러 프로세스가 공유 자원 사용*
    - **점유 대기**
        - 최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용하고 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 존재해야 함
        - *점유 대기 부정 : 프로세스 실행 전 모든 자원을 할당*
    - **비선점**
        - 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없음
        - *비선점 부정 : 자원 점유 중인 프로세스가 다른 자원을 요구할 때 가진 자원 반납*
    - **순환 대기**
        - 프로세스의 집합에서 순환 형태로 자원을 대기하고 있어야 함
        - *순환 대기 부정 : 자원에 고유번호 할당 후 순서대로 자원 요구*
- 방지
    - **예방과 회피**
        - 교착 상태가 발생하기 전
        - 예방 : 교착 상태 발생 조건 중 하나를 제거하면서 해결 → 자원 낭비가 심함
        - 회피 : 교착 상태 발생 시 피해나감 → ex) 은행원 알고리즘 : 은행에서 모든 고객의 요구가 충족되도록 현금을 할당하는 데서 유래함. 프로세스가 자원을 요구할 때 시스템은 자원을 할당한 후에도 안정 상태로 남아있게 되는지 사전에 검사하여 교착 상태 회피. 안정 상태면 자원 할당, 아니면 다른 프로세스들이 자원 해지할 때까지 대기
    - **탐지와 회복**
        - 교착 상태가 되도록 허용한 다음 회복
        - 탐지 : 자원 할당 그래프를 통해 교착 상태를 탐지. 자원 요청 마다 탐지 알고리즘을 실행시키면 그에 대한 오버헤드가 발생
        - 회복 : 교착 상태 일으킨 프로세스를 종료하거나 할당된 자원을 해제시켜 회복시키는 방법

### 캐시 메모리와 캐시의 지역성(locality)에 대해서 설명해주세요. (송채은)

- **캐시 메모리**
    - **메인 메모리(주기억장치)에서 자주 사용하는 프로그램과 데이터를 미리 저장해둔 고속 메모리**
    - 속도가 빠른 장치(CPU 연산)와 느린 장치(메모리 접근) 간의 속도 차에 따른 병목 현상을 줄이기 위한 범용 메모리
    - 메인 메모리와 CPU 사이에 위치
    - 캐시를 사용하면 메모리에 접근하는 횟수가 줄어 컴퓨터 처리 속도 향상
    - 캐시가 효율적으로 동작하기 위해서는 CPU가 참조할 정보에 대해 잘 예측해야 함
        - 캐시 적중률 극대화
        - 캐시 지역성 고려
- **캐시 지역성**
    - 데이터에 대한 접근이 시간적, 공간적으로 가깝게 발생하는 것
    - 기억장치 내의 정보를 균등하게 엑세스하는 것이 아닌 **어느 한 순간에 특정 부분을 집중적으로 참조하는 특성**
    - 캐시 적중률을 위해 저장할 데이터는 지역성을 가져야 함
    - 종류
        - **시간적 지역성**
            - 특정 데이터가 한번 참조된 경우, 가까운 미래에 또 한번 참조될 가능성이 높은 것
            - 메모리 상의 같은 주소에 여러 차례 읽기 쓰기를 수행할 경우 상대적으로 작은 크기의 캐시를 사용해도 효율성이 높음
        - **공간적 지역성**
            - 특정 데이터와 인접한 주소의 데이터가 참조될 가능성이 높은 것
            - CPU 캐시나 디스크 캐시의 경우 한 메모리 주소에 접근할 때 그 주소 뿐 아니라 해당 블록을 전부 캐시에 가져오도록 함
            - 메모리 주소를 오름차순이나 내림차순으로 순서대로 접근한다면 이미 캐시에 저장되어 있기 때문에 효율성이 높음
- 캐싱 라인
    - 캐시는 프로세서 가까이에 위치하면서 빈번하게 사용되는 데이터를 저장해두는 장소
    - 캐시가 아무리 가까이 있더라도 찾고자하는 데이터가 어느 곳에 저장되어 있는지 몰라 모든 데이터를 순회해야 한다면 시간이 오래 걸림
    - 캐시에 목적 데이터가 저장되어 있다면 바로 접근하여 출력할 수 있어야 캐시를 효율적으로 활용할 수 있음
    - 캐시에 데이터를 저장할 때 일정한 태그들로 묶어 ‘묶음’으로 저장하게 되는데 이를 캐싱라인이라고 함
    - [https://velog.io/@kangdev/운영체제-캐싱-라인-Caching-line](https://velog.io/@kangdev/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%BA%90%EC%8B%B1-%EB%9D%BC%EC%9D%B8-Caching-line)
- 매핑(Mapping, 사상)
    - 캐시 기억장치와 주기억장치 사이에서 정보를 옮기는 것
    - 종류
        - 직접 매핑(Direct Mapping)
            - 주기억장치의 블록들이 지정된 한 개의 캐시 라인으로만 사상될 수 있는 매핑 방법
            - 메인 메모리를 일정한 크기의 블록으로 나누어 각각의 블록을 캐시의 정해진 위치에 매핑하는 방식
            - 장점 : 간단하고 구현하는 비용이 적음
            - 단점 : 캐시 적중률이 낮아질 수 있음, 동일한 캐시 메모리 위치로 매핑된 데이터를 사용할 때는 충돌이 발생
        - 연관 매핑(Associate Mapping)
            - 직접 매핑 방식의 단점을 보완
            - 캐시 메모리의 빈 공간에 임의로 주소를 저장하는 방식
            - 모든 태그들을 병렬로 검사하기 때문에 복잡하고 비용이 높음
            - 거의 사용하지 않음
        - 집합 연관 매핑(Set Associate Mapping)
            - 직접 매핑과 연관 매핑의 장점을 합친 방식
            - 빈 공간에 임의로 주소를 저장하되 미리 정해둔 특정 행에만 저장
            - 어떤 집합에 저장할지 먼저 결정하고 해당 집합 내에서 빈 캐싱라인을 찾아 데이터를 저장
            - 정해진 블록의 집합 내 어디서든 매핑이 가능

### 커널에 대해서 설명해주세요. (송채은)

https://minkwon4.tistory.com/295

- 커널
    - 운영체제 중 **항상 메모리에 올라가 있는 운영체제의 핵심 부분**
    - **하드웨어와 응용 프로그램 사이에서 인터페이스를 제공하는 역할**
    - **컴퓨터 자원들을 관리하는 역할**
    - 커널은 인터페이스로써 응용 프로그램 수행에 필요한 여러가지 서비스를 제공하고 하드웨어 등의 리소스를 관리하는 역할
    - 항상 컴퓨터 자원들을 바라만 보고 있기에 사용자와의 상호작용은 지원하지 않음
    - 사용자와의 직접적인 상호작용을 위해 프로그램 제공. ex) 쉘(Shell) 명령어 해석기
- 커널의 자원 관리
    - 컴퓨터의 하드웨어 자원과 추상화 자원 관리
    - 추상화 : 물리적으로 하나뿐인 하드웨어를 여러 사용자들이 번갈아 사용할 수 있도록 마치 여러 개처럼 보이게 하는 기술
    - 커널이 관리함에 따라 각 사용자들을 하나의 하드웨어를 독점하는 것처럼 느낄 수 있도록 함
- 인터페이스
    - 인터페이스로써 사용자가 컴퓨터만의 언어와 규칙으로 하드웨어와 통신할 수 있도록 도와줌
    - 커널은 사용자가 시스템콜을 통해 컴퓨터 자원을 사용할 수 있게 해주는 자원 관리자
- 운영체제
    - 커널 + 애플리케이션, 유틸리티 = 운영체제
    - 운영체제는 커널 공간과 사용자 공간으로 나뉜다
- 유형

![Untitled](%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%20db57a2d26f41487798aedbc0e6aa5eb9/Untitled%202.png)

- **모놀리식 커널**
    - 애플리케이션을 제외한 모든 시스템 서비스들 (VFS, IPC, File System 등)을 커널이 직접 처리하는 방식
    - 각 서비스들은 커널 내부의 여러 계층에서 관리
    - 모놀리식 커널은 사용자가 운영체제 서비스들을 시스템콜을 통해 사용할 수 있게 해줌
    - 커널이 많은 것을 관리하기 때문에 크기가 크고, 하나의 오류가 전체 시스템에 영향을 끼칠 수 있다는 단점이 있음
    - 커널 내부에서 서비스들이 서로 시스템 자원을 공유하며 효율적으로 관리할 수 있고 내부 서비스를 직접 커널이 수행하기에 빠른 처리속도를 가지는 장점이 있음
    - ex) 유닉스, 임베디드 리눅스, OSEK, WinMobile
- **마이크로 커널**
    - 기존 모놀리식 커널에서 핵심 서비스(Process Management, Memory Management, Network Management 등)만을 남겨두고 나머지는 제외하여 가볍게 만든 커널
    - 기존 모놀리식 커널이 가지고 있던 시스템 서비스들은 개별적인 서버의 형태로 존재
    - 최소화하고 핵심적인 서비스만 모아놓고 서버를 추가하는 방식
    - 프로세스 간 통신을 통해 대부분의 서비스가 수행됨
    - 메시지 전송에 따란 컨텍스트 스위칭이 많이 발생하고 시스템 복잡도가 증가될수록 시스템 부하, 오버헤드가 증가하는 단점이 있음
    - 서버를 추가하는 방식이기에 커널을 변경하지 않고 간단히 기능을 추가, 수정할 수 있고 프로세스가 각각의 서버 영역에서 수행되기 때문에 다른 서비스까지 영향을 끼치지 않는다는 장점이 있음
    - ex) 임베디드 시스템 등에서 사용. MacOS, Windows NT

### 멀티 스레드의 장단점에 대해 설명해주세요. (김은솔)

- 멀티 스레드
    - **하나의 프로세스 내부에서 여러 개의 스레드가 동시에 실행되는 것**
- 왜?
    - 메모리 공간과 시스템 자원 소모가 줄어듦
    - 전역 변수의 공간 또는 동적으로 할당된 공간인 힙 영역을 이용하여 데이터를 주고 받을 수 있음
    - 스레드의 문맥 교환은 프로세스 문맥 교환과는 달리 캐시 메모리를 비울 필요가 없기 때문에 더 빠름
    - 시스템 처리량이 향상되고 자원 소모가 줄어들어 프로그램 응답 시간이 단축됨
- 장점
    - 멀티 프로세스보다 적은 메모리 공간을 차지하고 문맥 교환이 빠름
    - 스레드 간 통신에 별도의 자원을 이용하지 않고도 전역 변수 공간이나 힙 영역을 통해 데이터를 주고 받을 수 있음
    - 스택을 제외한 모든 영역이 메모리를 공유하므로 통신 부담이 적음
- 단점
    - 스레드 간 자원을 공유하기 때문에 하나의 스레드만 오류로 종료되어도 전체 스레드가 종료될 수 있음
    - 동기화 : 전역 변수를 공유하므로 함께 사용할 때 충돌이 발생할 수 있음
    - 교착상태 : 스레드가 자원을 얻지 못해 다음 처리를 하지 못하는 상태, 시스템적으로 한정된 자원을 여러 곳에서 사용하려고 할 때 발생

### 선점형 스케줄링과 비선점형 스케줄링에 대해 설명해주세요. (김은솔)

- **스케줄링**
    - 여러 프로세스가 번갈아가며 사용하는 자원을 **어떤 시점에 어떤 프로세스에게 자원을 할당할지 결정**하는 것
    - 운영체제가 CPU를 효율적으로 활용하기 위한 방법
    - **여러 프로세스 중에서 어떤 프로세스를 먼저 실행할지, 얼마나 오랫동안 실행할지 등을 결정**
- **선점형 스케줄링**
    - 운영체제가 프로세스 실행 중간에 **다른 프로세스로 제어권을 뺏어** 해당 프로세스를 일시중지시키고 **우선순위가 더 높은 프로세스에게 제어권을 넘겨주는 스케줄링**
    - **Priority Scheduling**
        - **우선순위가 높은 프로세스부터 실행**
        - 우선순위가 높은 프로세스가 계속 들어올 경우 우선순위가 낮은 프로세스는 계속 대기하게 되어 **기아상태가 발생할 수 있음**
    - **Round Robin**
        - 각 프로세스에게 **일정한 시간을 할당**해주고 할당된 시간이 지나면 다음 프로세스에게 CPU를 넘기는 방식
        - 할당 시간이 짧으면 문맥 교환이 자주 발생하여 오버헤드가 커질 수 있음
        - 할당 시간이 길면 프로세스의 대기 시간이 길어질 수 있음
- **비선점형 스케줄링**
    - 프로세스가 종료되거나 입출력 등의 이벤트가 발생할 때까지 **해당 프로세스가 제어권을 유지하는 스케줄링**
    - **FCFS (First-Come, First Served)**
        - **먼저 도착한 프로세스를 먼저 실행하는 방식**
        - CPU가 현재 수행 중인 작업을 완료하면 대기 중인 프로세스 중에서 가장 먼저 들어온 프로세스를 실행
        - 구현이 간단하고 공정한 방식
        - 대기 시간이 길어질 수 있고 작업 시간이 긴 프로세스가 먼저 실행될 경우 평균 대기 시간이 길어질 수 있음
    - **SJF (Shortest Job First)**
        - **작업 시간이 가장 짧은 작업을 우선적으로 실행하는 방식**
        - 평균 대기 시간이 짧아짐
        - 작업 시간을 미리 알고 있어야 하며 작업 시간을 추정하는 것이 어렵다면 예측 오류로 인해 평균 대기 시간이 길어질 수 있음
        - 작업 시간이 짧은 프로세스가 지속적으로 들어올 경우 작업 시간이 긴 프로세스는 계속 대기해야 하므로 기아 상태가 발생할 수 있음

### 동기와 비동기에 대해 설명해주세요. (김은솔)

- **동기(Synchronous)**
    - **직렬적으로 태스크를 수행하는 방식**
    - **요청을 보낸 후 응답을 받아야 다음 동작이 이루어지는 방식**
    - 어떤 태스크를 처리할 동안 나머지 태스크는 대기
    - 실제로 CPU가 느려지는 건 아니지만 시스템의 전체적인 효율이 저하된다고 할 수 있음
    - 여러 개의 스레드 또는 프로세스가 공유 자원에 접근할 때 서로의 작업이 서로에게 영향을 미치지 않도록 조절하는 것
    - **동기화를 통해 공유 자원에 대한 접근을 제한함으로써 스레드 또는 프로세스 간의 경쟁이 발생하지 않도록하여 일관성 있는 결과를 보장**
    - ex) 뮤텍스, 세마포어
- **비동기(Asynchronous)**
    - **병렬적으로 태스크를 수행하는 방식**
    - **요청을 보낸 후 응답의 수락 여부와는 상관없이 다음 태스크 동작**
    - 자원을 효율적으로 사용할 수 있음
    - 비동기 처리 방식
        - 콜백 함수 사용
        - Promise
        - Promise를 활용한 async/await
            - async : 함수 이름 앞에 비동기를 사용하겠다는 선언
            - await : 호출할 비동기 함수 앞에 await 키워드 사용
    

### 스레싱에 대해 설명해주세요. (김은솔)

- 스레싱
    - CPU 작업 시간보다 메모리와 스왑 영역 간 페이지 교체에 시간을 많이 소비하는 것
    - **과도한 페이지 교체로 시스템의 성능이 떨어지는 것**
    - CPU의 실제 작업 시간 < 페이지 교체 시간
    - **페이지 부재율이 증가하여 CPU 이용율이 급격하게 떨어지는 현상**
- 발생 원인
    - **프로세스를 처리하는 시간보다 메모리에 적재되지 못한 페이지로 인하여 페이지 교체에 드는 시간이 증가하게 되고 그로 인해 CPU 이용률이 떨어지게 됨**
    - 동시에 실행하는 프로세스가 많아질수록 각 프로세스에 할당된 메모리 페이지 프레임들은 더욱 작아지게 됨 → 너무 적은 페이지 프레임을 할당받은 프로세스들은 페이지 부재가 증가하게 되어 Swapping이 증가하게 되고 결국 CPU 이용률이 더욱 떨어지는 악순환
- 해결 방법
    - **Working Set**
        - 지역성 원리를 이용하여 지역성 집합이 메모리에 동시에 올라갈 수 있도록 보장
            - 지역성 원리 : 프로세스가 일정 시간 동안 집중적으로 특정 주소 영역을 참조하는 경향
        - **프로세스의 작업을 구성하는 자주 참조되는 페이지들을 묶는 것**
    - **페이지 부재 빈도**
        - 프로세스의 **페이지 부재율을 주기적으로 조사**하고 이 값에 근거하여 각 프로세스에 **할당할 메모리 양을 동적으로 예측하고 조절**하는 알고리즘

### 크롬 탭 하나는 프로세스인가요? 스레드인가요? (유지연)

- 크롬의 탭은 프로세스다
    - 크롬은 멀티 프로세스를 사용하며 IPC(Inter Process Communication, 프로세스 간 통신)를 사용
    - 특정 탭이 응답하지 않을 때는 동작하지 않는 탭의 프로세스를 재시작 시켜버리는 방식
- 멀티 프로세스는 높은 성능을 요구하지만 안정적
    - 웹 사이트를 개발자가 별도의 심사 없이 배포하기 때문
    - 크롬이 메모리를 많이 사용하는 이유는 메모리 성능보다 안정적이고 빠른 사용자 경험을 중시하기 때문
- 크롬의 프로세스 처리 방식
    
    ![Untitled](%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%20db57a2d26f41487798aedbc0e6aa5eb9/Untitled%203.png)
    
    - 브라우저 프로세스
        - 탭 외부의 크롬 내장 기능(URL 표시줄, 북마크 바, 이전 페이지, 다음 페이지 등)을 담당
    - 렌더러 프로세스
        - 탭 내부의 웹 사이트에 표시되는 모든 것을 담당
    - 플러그인 프로세스
        - 웹 사이트에서 사용하는 플러그인(flash, PDF, media, music 등)을 담당
    - CPU 프로세스
        - GPU 사용하는 부분은 해당 프로세스가 담당
- 탭은 한 프로세스만 지니는 게 아니라 여러 개의 프로세스를 지님

### 세마포어와 뮤텍스의 차이에 대해 설명해주세요. (유지연)

[https://chelseashin.tistory.com/40](https://chelseashin.tistory.com/40)

- **뮤텍스(Mutex)**
    - 공유된 자원의 데이터나 임계 영역 같은 곳에 스레드의 running Time이 서로 겹치지 않게 하나의 프로세스 또는 스레드가 접근하는 것을 막는 것
    - **동시 프로그래밍에서 공유 불가능한 자원의 동시 사용을 피하기 위해 사용하는 알고리즘**
    - 상호배제를 구현하기 위한 동기화 기법 중 하나
    - 공유 자원에 대한 접근을 동시에 하나의 스레드만 가능하게 제한
    - 동기화 대상이 하나인 게 특징
    - 다른 스레드는 뮤텍스의 lock을 가지기 위해 대기
    - 락을 해제하는 스레드가 있을 때까지 다른 스레드는 접근 불가
    - **한 스레드, 프로세스에 의해 소유될 수 있는 키를 기반으로 한 상호배제 기법**
- **세마포어(Semaphore)**
    - **멀티 프로그래밍 환경에서 공유된 자원에 대한 접근을 제한하는 방법**
    - 리소스의 상태를 나타내는 간단한 카운터
    - 비교적 긴 시간을 확보하려는 리소스에 대해 이용
    - 유닉스 시스템의 프로그래밍에서 세마포어는 운영체제의 리소스를 경쟁적으로 사용하는 다중 프로세스에서 행동을 조정하거나 동기화 시키는 기술
    - 공유된 자원의 데이터 혹은 임계 영역 등에 여러 프로세스 혹은 스레드가 접근하는 것을 막아줌
    - **사용하고 있는 스레드/프로세스의 수를 공통으로 관리하는 하나의 값을 이용해 상호배제를 달성**
    - 현재 공유 자원에 접근할 수 있는 스레드, 프로세스의 수를 나타내는 값을 두어 상호배제를 달성하는 기법
- 차이
    - 동기화 대상의 개수 차이
        - **뮤텍스는 동기화 대상이 오직 하나**
        - 세마포어는 **변수만큼의 프로세스 접근이 가능 (1개 이상)**
    - 자원 소유
        - **뮤텍스는 책임을 지고 자원을 소유할 수 있음**
        - **세마포어는 자원 소유 불가**
    - 락
        - 뮤텍스는 상태가 0, 1 뿐이라서 락을 가질 수 있고 소유하고 있는 스레드만이 이 뮤텍스를 해제할 수 있음
        - 세마포어는 세마포어를 소유하지 않는 스레드가 세마포어를 해제할 수 있음
    - 세마포어는 시스템 범위에 걸쳐있고 파일 시스템 상의 파일로 존재하지만 뮤텍스는 프로세스의 범위를 가지며 프로세스 종료될 때 자동으로 클린업됨

### 메모리 계층구조에 대해 설명해주세요. (유지연)

![Untitled](%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%20db57a2d26f41487798aedbc0e6aa5eb9/Untitled%204.png)

- **메모리 계층 구조**
    - **메모리를 필요에 따라 여러 종류로 나누어 두는 것**
    - **CPU가 메모리에 더 빨리 접근할 수 있음**
    - 상황에 맞게 여러 저장 장치를 사용할 수 있도록 하여 저렴하고 성능 좋은 컴퓨터를 구현하는 설계
    
    | 명칭 | 위치 | 접근 속도 |
    | --- | --- | --- |
    | 레지스터 | CPU 내부 | 빠름 |
    | 캐시 | CPU 내부 | 빠름 |
    | 메모리 | CPU 외부 | 레지스터, 캐시보다 느림 |
    | 하드디스크 | CPU 직접 접근 불가 | 데이터를 메모리로 이동 시켜 접근 가능 |
- **레지스터**
    - **CPU가 요청을 처리하는 데 필요한 데이터를 일시적으로 저장하는 기억장치**
    - 프로세서에 위치한 고속 메모리로 프로세스가 바로 사용할 수 있는 데이터를 담고 있는 영역
- **캐시**
    - **데이터나 값을 미리 복사 해놓는 임시 장소**
    - 시스템의 효율성을 위해 사용
    - 속도가 빠른 장치와 느린 장치 사이에서 속도 차에 따른 병목 현상을 완화하기 위한 범용 메모리
- **메인 메모리**
    - **컴퓨터에서 수치, 명령, 자료 등을 기억하는 컴퓨터 하드웨어 장치**
    - RAM : 휘발성 기억 장치, 컴퓨터가 빠른 엑세스를 위해 데이터를 단기간 저장하는 구성 요소
    - ROM : 고정 기억 장치, 컴퓨터에 지시사항을 영구히 저장하는 비휘발성 메모리
- **하드 디스크**
    - **비휘발성, 순차 접근이 가능한 컴퓨터의 보조 기억 장치**

### 컨텍스트 스위칭에 대해서 설명하고, 왜 컨텍스트 스위칭이 필요한지 설명해주세요. (유지연)

[https://j-su2.tistory.com/63](https://j-su2.tistory.com/63) : 문맥 교환

- **문맥 교환 (Context Switching)**
    - 하나의 프로세스가 CPU를 사용 중인 상태에서 다른 프로세스가 CPU를 사용하도록 하기 위해 **이전의 프로세스의 상태(문맥)를 보관**하고 새로운 프로세스의 상태를 적재하는 작업
    - 한 프로세스의 문맥은 그 프로세스의 프로세스 제어 블록(PCB)에 기록
- PCB : 시스템 내의 프로세스들을 관리하기 위해 프로세스마다 유지하는 정보들을 담는 커널 내 자료구조로 커널 주소 공간의 데이터 영역에 존재
- PCB에 저장되는 내용
    - 프로세스 상태
    - PC
    - CPU 레지스터
    - CPU 스케줄링 정보
    - 메모리 관리 정보
    - 자원 사용 정보
    - 입출력 상태 정보
- 이러한 문맥 정보를 사용해 CPU를 선점하고 있던 프로세스는 프로세스 문맥을 PCB에 저장하게 되고 새롭게 CPU를 할당받을 프로세스는 PCB로부터 예전에 저장했던 자신의 문맥을 실제 하드웨어로 복원하는 과정을 거침
- 시점
    - 멀티 태스킹
        - 다수의 프로세스가 하나의 CPU 자원을 나누어 사용할 때
        - 실행 가능한 프로세스들이 운영체제의 스케줄러에 의해 조금씩 번갈아 수행됨
        - CPU를 할당 받을 때 문맥 교환이 일어남
        - 매우 빠른 속도로 처리되기 때문에 동시에 처리되는 것처럼 느낌
    - 인터럽트 처리
        - 인터럽트 : 컴퓨터 시스템에서 예외 상황이 발생했을 때 CPU에게 알려 처리활 수 있도록 함
        - 인터럽트가 발생할 때 문맥 교환이 일어남
    - 사용자 및 커널 모드 전환
        - 운영체제에서 사용자 모드와 커널 모드 사이의 전환이 필요할 때 필수는 아니지만 운영체제에 따라 문맥 교환이 발생
- 과정
    1. 요청 발생 : 인터럽트 또는 트랩에 의한 요청이 발생
    2. PCB에 저장 : 운영체제는 현재 실행중인 프로세스의 정보를 PCB에 저장
    3. CPU 할당 : 운영체제는 다음 프로세스의 정보를 PCB에서 가져와 CPU를 할당
- 왜?
    - 멀티태스킹(=멀티프로세싱)이 가능하게 함
    - 여러 프로세스와 스레드들을 동시에 실행시키기 위해 (그렇게 보이기 위해)
    - 여러 프로세스와 스레드들이 공정하게 CPU 시간을 나눠 갖기 위해
    - 높은 우선순위의 작업이 빠르게 처리될 수 있게