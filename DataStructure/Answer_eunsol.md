# 자료구조

### 스택과 큐의 차이점을 설명해주세요. (김은솔)

- 스택
    - 같은 구조와 크기의 자료를 정해진 방향으로만 쌓을 수 있음
    - 정해진 한 곳(탑)에서 삽입, 삭제가 이루어짐
    - 후입선출 : 가장 마지막에 삽입된 자료가 가장 먼저 삭제됨
    - stack underflow : 비어있는 스택에서 원소를 추출하려고 할 때
    - stack overflow : 스택이 넘치는 경우
    - 구현 방법 : 배열, 연결 리스트
    - 예시
        - 웹 브라우저 방문기록 (뒤로가기)
- 큐
    - 한 쪽 끝(프론트)에서 삽입, 한 쪽 끝(리어)에서 삭제
    - 선입선출 : 가장 먼저 들어온 원소가 가장 먼저 나감
    - 구현 방법 : 배열, 연결 리스트
    - 예시
        - 프린터 인쇄 대기열
        - 은행 업무 등
- 덱
    - 스택과 큐가 결합된 자료구조. 양쪽 끝에서 추가 제거 모두 수행 가능
- 원형 큐
    - 일반적인 선형 큐와 달리 앞의 공간이 남게 되면 큐의 끝을 앞으로 가져와 순환고리를 만듦
    - 메모리 재사용 가능

<aside>
📢 스택은 삽입, 삭제가 한 곳에서 이루어지는 자료구조입니다. 후입선출 구조로 마지막에 삽입된 요소가 가장 먼저 삭제됩니다. 큐는 삽입, 삭제가 양쪽 끝으로 제한된 자료구조입니다. 선입선출 구조로 먼저 삽입된 요소가 가장 먼저 삭제됩니다.

</aside>

### Array와 LinkedList의 차이점을 설명해주세요. (김은솔)

- Array
    - 연속된 메모리 공간 사용
    - index를 통해 각 요소에 접근 가능
    - 시간 복잡도 : 탐색 - O(1) / 삽입 삭제 - O(n)
    - 컴파일 과정에서 메모리가 할당되는 정적 메모리 할당
    - Stack 영역에 할당
- Linked List
    - 연속되지 않은 메모리 공간 사용
        - 각각의 데이터가 메모리 공간 상에 고유한 노드로 존재. 이 노드는 앞뒤 데이터에 대한 주소를 갖고 있음
    - 노드 간의 연결을 이어주고 끊어주는 과정을 통해 삽입 삭제
    - 시간 복잡도 : 탐색 - O(n) / 삽입 삭제 - O(1)
    - 런타임 환경에서 메모리가 할당되는 동적 메모리 할당
    - Heap 영역에 할당

<aside>
📢 Array는 연속된 메모리 공간을 사용합니다. index를 통해 각 요소에 접근 가능하며 탐색 시에는 O(1), 삽입 삭제 시에는 shift에 필요한 연산이 발생하여 O(n)의 시간 복잡도를 가집니다. Linked List는 연속되지 않은 메모리 공간을 사용합니다. 연결을 끊고 맺는 과정을 통해 삽입, 삭제하며 O(1)의 시간 복잡도를 가지고 탐색 시에는 O(n)의 시간 복잡도를 가지고 있습니다. 따라서 Array는 추가나 삭제보다 빠른 접근을 해야 할 때 사용하고 Linked List는 탐색보다는 추가, 삭제를 자주 할 때 사용합니다.

</aside>

### Array와 ArrayList의 차이점을 설명해주세요. (김은솔)

- 공통
    - indext 사용. 조회, 삽입 성능 비슷
    - 중복 요소 저장 가능
    - Null값 가능
    - 순서가 지정되지 않음
- Array
    - 고정 길이. 정해진 길이의 배열을 모두 채우면 새로운 데이터를 추가하고 싶은 경우 새로운 배열을 만들어 복사해줘야 함. 배열 객체를 생성한 후에는 길이를 마음대로 변경할 수 없음.
    - 다차원 가능
    - length
- ArrayList
    - 가변 길이. 내부적으론 배열로 구성. 디폴트로 10개의 공간을 가진 배열로 시작. capacity 인스턴스 변수를 가짐. ArrayList에 요소들이 더해지면 capacity 또한 자동적으로 늘어남. 배열이 꽉찼을 때 데이터가 들어온다면 크기를 1.5배씩 증가시킨다. 늘어난 배열에 기존의 배열을 복사함.
    - 단일 차원
    - size()

<aside>
📢 Array는 고정 길이를 가지고 ArrayList는 가변 길이를 가진다는 차이가 있습니다. Array는 초기화시 길이가 고정되며 사이즈 변경이 불가합니다. 초기화 시 메모리에 할당되어 속도가 빠릅니다. ArrayList는 사이즈가 동적이며 데이터를 추가할 때마다 크기를 키울 수 있습니다. 데이터 추가시 메모리를 재할당하여 속도가 느립니다. 또한 Array는 다차원이 가능한 반면 ArrayList는 단일 차원만 가능하다는 차이가 있습니다.

</aside>

### Heap에 대해 설명해주세요. (박규영)

- Heap
    - 우선순위 큐를 위해 고안된 완전이진트리 형태의 자료구조
    - 여러 값 중 최대값과 최소값을 빠르게 찾아내도록 만들어진 자료구조
    - 반정렬 상태를 유지 (느슨한 정렬 상태)
        - 부모 노드의 키 값이 자식 노드의 키 값보다 항상 크거나 작음
    - 이진탐색트리와 달리 중복된 값 허용
    - 부모 > 자식 : 최대 힙
    - 부모 < 자식 : 최소 힙
    - 배열로 구현 (0번 인덱스 사용 ㄴㄴ)
- 저장/삭제 개념 (최소 힙)
    - 들어올 새 노드를 우선순위가 가장 낮다는 가정을 하고 맨 끝 위치에 저장한다
    - 부모 노드와 우선순위를 비교해서 위치가 바뀌어야 하면 바꾼다 (반복)
    - 삭제 시 가장 우선순위가 높은 루트 노드를 빼낸다.
    - 마지막 노드를 루트 노드 자리에 옮긴다.
    - 왼쪽 오른쪽 자식 노드 중 우선순위가 높은 것과 비교한다. (반복)
    - 시간복잡도 : O(logN) 참고로 Arrays.sort는 팀소트로 NlogN
- 완전이진트리
    - 마지막 레벨을 제외한 모든 레벨이 모두 채워져 있어야 하고 마지막 레벨은 왼쪽부터 채워져 있어야 함

<aside>
📢 Heap은 우선순위 큐를 위해 만들어진 자료구조로 완전이진트리의 형태를 가집니다. 여러 값 중 최대값과 최소값을 빠르게 찾아내도록 만들어진 자료구조입니다. 힙은 반정렬 상태를 유지하며 부모 노드 값이 자식 노드 값보다 큰 걸 최대 힙, 자식 노드 값보다 작은 걸 최소 힙이라고 합니다.

</aside>

### 버블소트와 퀵소트에 대해 간단히 설명해주시고, 비교해주세요. (박규영)

- 버블정렬
    - 두 인접한 원소를 검사해 정렬
    - 1회전이 끝나면 요소 중 가장 큰 요소가 가장 끝 자리로 정렬됨
    - 추가적인 메모리 사용이 없어 절약됨
    - 시간복잡도 : O(N^2)
- 퀵정렬
    - 분할 정복 알고리즘
    - 기준(피봇)을 정하고 중심보다 작은 요소를 왼쪽, 크면 오른쪽으로 보냄
    - 나눈 데이터에서 또 좌우를 재귀로 반복
    - 시간복잡도 : O(NlogN) 최악: O(N^2)
    - 동일한 요소가 여러 개 있는 경우 정렬 이후에 초기 순서와 달라질 수 있음

<aside>
📢 버블정렬은 두 인접한 원소를 검사하여 정렬하는 방법입니다. 1회전이 끝나면 가장 큰 요소가 가장 끝 자리로 정렬됩니다. 추가적인 메모리 사용이 없어서 절약되는 반면 배열 전체를 순회하기 때문에 O(N^2)의 시간 복잡도를 가집니다. 퀵정렬은 분할 정복 알고리즘을 사용하여 기준을 정하고 기준보다 작은 요소를 왼쪽, 큰 요소를 오른쪽으로 보내며 정렬하는 방법입니다. 나눈 데이터에서 또 중심을 잡고 좌우를 탐색하는 재귀적 방법을 사용하여 정렬합니다. 시간복잡도는 평균적으로 O(NlogN)을 가지지만 최악의 경우 O(N^2)이 될 수도 있습니다.

</aside>

### 최소 신장 트리(MST)에 대해 설명해주세요. (박규영)

- 신장 트리
    - 그래프 내에 있는 모든 정점을 연결하고 사이클이 없는 그래프
- 최소 신장 트리
    - 각 간선이 가지고 있는 가중치의 합이 최소가 되는 신장 트리
- 구현방법
    - 프림 알고리즘, 크루스칼 알고리즘
- 예시 : 통신 네트워크 구축
- 프림
    - 임의의 정점을 시작 정점으로 하고 최소 신장 트리의 루트노드로 삽입
    - 최소 신장 트리에 삽입된 정점과 이 정점과 인접한 정점의 가중치를 확인해서 가장 작은 가중치를 최소 신장 트리에 삽입한다. (이때 사이클이 형성되지 않도록)
    - 위 과정을 반복하며 모든 정점이 최소 신장 트리에 연결되면 종료한다.
    - 그래프에 N개의 정점이 있다면 N개의 정점을 순회해야 하므로 N^2만큼 반복해야 함
    - 이때 힙을 사용하면 빠르게 최솟값 찾을 수 있음
- 크루스칼
    - 그래프 내의 모든 간선의 가중치를 확인하고 가장 작은 가중치부터 확인해서 최소 신장 트리를 만드는 방법 (그리디)
    - 그래프 내의 모든 간선 가중치를 오름차순으로 정렬
    - 가중치를 순회하면서 최소 신장 트리에 삽입 (사이클 형성되지 않도록)
    - 사이클 확인을 위해 분리집합 사용

<aside>
📢 최소 신장 트리란 그래프 내에 있는 모든 정점을 연결하고 사이클이 없는 그래프인 신장 트리에서 각 간선이 가지고 있는 가중치의 합이 최소가 되는 신장트리를 말합니다. 구현 방법으로는 프림 알고리즘과 크루스칼 알고리즘이 있습니다. 통신망, 도로망을 구축할 때 사용합니다.

</aside>

### Java의 Arrays.sort와 Collections.sort에서 사용되는 정렬 알고리즘에 대해 설명해주세요. (전재우)

- Arrays.sort
    - 기본형
        - 듀얼피봇퀵소트 : 피봇 두 개 사용하여 정렬 수행
        - 시간 복잡도 : O(NlogN), 최악: O(N^2)
    - 참조형
        - 팀 소트 : 삽입 정렬과 병합 정렬을 섞어서 사용
        - 시간 복잡도 : O(NlogN), 최선: O(N)
- Collections.sort
    - List 객체를 Object 배열로 변환하여 Arrays.sort() 실행 → 팀소트

<aside>
📢 Arrays.sort는 기본형에서는 듀얼피봇퀵소트를 사용하고 참조형에서는 팀소트를 사용합니다. 듀얼피봇퀵소트는 피봇을 두 개 사용하여 정렬하는 방법으로 평균적으로 NlogN의 시간 복잡도를 가집니다. 팀소트는 병합 정렬과 삽입 정렬을 섞어서 사용하며 NlogN의 시간 복잡도를 가집니다. Collections.sort는 List객체를 Object 배열로 변환하여 Arrays.sort()를 실행하므로 팀소트 방법을 사용합니다.

</aside>

### 그래프와 트리의 차이점에 대해 설명해주세요. (전재우)

- 그래프
    - 노드와 노드 간을 연결하는 간선으로 구성된 자료구조
    - 연결되어 있는 객체 간의 관계를 표현할 수 있는 구조
    - 노드 간에 2개 이상의 경로도 가능
    - 부모-자식 관계같은 거 없음
    - 순환 혹은 비순환 구조를 가짐
    - 방향성 있든가 없든가 함
    - 예시 : 지도, 지하철 노선도의 최단 경로, 선수 과목
- 트리
    - 그래프의 한 종류
    - 방향성이 있음
    - 사이클 없음 (비순환 그래프)
    - 부모-자식 관계라는 개념이 있으며 최상위에 루트 노드가 존재
    - 예시 : 이진 트리, 이진 탐색 트리

<aside>
📢 그래프는 노드와 노드 간을 연결하는 간선으로 구성된 자료구조입니다. 노드 간에 2개 이상의 경로도 가능하며 부모-자식 관계라는 개념은 없고 방향, 무방향, 순환, 비순환이 모두 존재할 수 있습니다. 트리는 그래프의 한 종류로 방향성이 있으며 사이클이 없는 비순환 구조를 가지고 있습니다 .부모-자식 관계라는 개념이 있으며 최상위에 루트 노드가 존재합니다.

</aside>

### 해시테이블에 대해서 설명해주세요. (전재우)

- key를 hash function을 통해 hash값으로 바꾼 뒤 hash값을 index로 사용해 key-value 형식으로 저장하는 자료구조
- key : 고유값. hash function의 input값.
- hash function : key를 고정된 길이의 hash값으로 변경해주는 역할. hash table에서는 key의 개수가 테이블의 크기보다 크기 때문에 서로 다른 key를 input값으로 넣어 함수를 실행함에도 hash값이 동일한 경우가 생김 (해시 충돌)
- hash : hash function의 output값. value의 key가 됨
- value : bucket이라고 불리는 저장소에 저장되는 실질적인 값. hash로 접근 가능
- 순서 없음
- key-value 1:1 매칭 구조로 삽입 삭제 검색이 빠름
- 공간효율성이 떨어짐. hash function 의존도가 높음.
- 시간 복잡도 : 평균: O(1), 최악: O(N)
- 해시 충돌 해결법
    - 분리연결법
        - 연결리스트 형태로 저장
        - 상대적으로 메모리 소모가 적음
    - 개방 주소법
        - 주변에 비어있는 hash를 찾아 충돌 해시를 저장

<aside>
📢 해시 테이블이란 해시 함수를 이용해서 변환한 값을 index로 삼아 key-value 형태로 저장하는 자료구조입니다. 해시테이블은 순서가 없으며 key를 통해 value를 얻을 수 있기 떄문에 삽입, 삭제, 검색이 빠릅니다. O(1)의 시간 복잡도를 가집니다. value는 중복 가능하지만 key는 유니크한 값을 가져야 합니다. 해시테이블에서 사용하는 해시 함수는 입력값이 다르더라도 같은 결과값이 나오는 경우가 있는데 그걸 해시 충돌이라고 합니다. 해시 충돌을 해결하기 위한 방법으로는 분리연결법, 개방주소법 등이 있습니다.

</aside>

### HashMap과 Hashtable의 차이점에 대해 설명해주세요. (유지연)

- 해시 맵
    - Thread-safe하지 않음 (멀티 스레드 환경에서 동시에 객체의 데이터를 조작하는 경우 데이터가 깨질 수 있음) 동기화 지원ㄴㄴ
    - Key에 Null 허용
    - 보조 해시 사용
- 해시테이블
    - Thread-safe함. 동기화 지원ㅇㅇ
    - Key에 Null 허용 ㄴㄴ
    - 보조 해시 사용 ㄴㄴ

<aside>
📢 해시테이블과 해시맵의 가장 큰 차이는 동기화 지원 여부입니다. 해시맵은 Thread-safe하지 않으며 멀티 스레드 환경에서 동시에 데이터를 조작하는 경우 데이터 무결성이 깨질 수 있습니다. 해시테이블은 동기화를 지원합니다. 다른 차이로는 해시맵은 Key에 Null값을 허용하는데 해시테이블은 Null값을 허용하지 않는다는 점도 있습니다.

</aside>

### Priority Queue에 대해 설명해주세요. (유지연)

- FIFO 형식의 자료구조인 큐에 우선순위 개념을 접목시킨 자료구조
- 먼저 들어오는 데이터가 아니라 우선순위가 높은 데이터가 먼저 나가는 형태
- 배열, 연결리스트, 힙으로 구현 (힙이 가장 효율적)
- 시간 복잡도 : O(logN)
- 예시
    - 운영체제 작업 스케쥴링
    - 네트워크 트래픽 제어

<aside>
📢 우선순위 큐는 기존의 FIFO 형식의 큐 자료구조에서 우선순위 개념을 접목시킨 자료구조입니다. 기존 큐와 달리 먼저 들어온 데이터가 아니라 우선순위가 높은 데이터가 먼저 나가는 형태입니다. 배열, 연결리스트, 힙으로 구현 가능하며 힙으로 구현했을 때 시간복잡도는 O(logN)이 됩니다. 대표적으로 운영체제의 작업 스케줄링에서 사용합니다.

</aside>

### 이진트리의 전위, 중위, 후위 순회에 대해 설명해주세요. (유지연)

- 전위
    - 부모 노드를 먼저 방문하는 순회 방식
    - 부모 > 왼 > 오
- 중위
    - 왼쪽 노드를 먼저 방문 후 부모 노드를 방문
    - 왼 > 부모 > 오
- 후위
    - 하위 노드를 먼저 방문 후 부모 노드를 방문
    - 왼 > 오 > 부모

<aside>
📢 전위순회란 부모 노드를 먼저 방문하는 순회방식으로 부모, 왼쪽 노드, 오른쪽 노드 순으로 방문합니다. 중위 순회는 왼쪽 노드를 먼저 방문 후 부모 노드를 방문하는 방법으로 왼쪽 노드, 부모 노드, 오른쪽 노드 순서로 방문합니다. 후위 순회는 하위 노드를 먼저 방문하고 부모 노드를 방문하는 방법으로 왼쪽 노드, 오른쪽 노드, 부모 노드 순서로 방문합니다.

</aside>

### List와 Set의 차이점에 대해 설명해주세요. (송채은)

- List
    - 순서가 있는 콜렉션으로 index로 데이터를 가져올 수 있음
    - 중복 허용
    - 저장되는 데이터 순서를 보장해야 하며 중복된 값을 허용할 때 사용
    - contains() : 시간복잡도 O(N)
- Set
    - 순서가 없는 콜렉션으로 index로 데이터에 접근할 수 없음
    - 중복을 허용하지 않음
    - 중복을 허용하지 않는 콜렉션이 필요할 때 사용
    - contains() : 시간복잡도 O(1)

<aside>
📢 리스트는 순서가 있는 콜렉션으로 index로 데이터에 접근할 수 있고 데이터의 중복을 허용합니다. Set은 순서가 없어 index로 데이터에 접근할 수 없고 데이터의 중복을 허용하지 않습니다. 리스트에 있는 contains함수는 O(N)의 시간복잡도를 가지며 Set의 contains()함수는 O(1)의 시간복잡도를 가집니다.

</aside>

### B-Tree에 대해 설명해주세요. (송채은)

- 데이터베이스와 파일 시스템에 사용되는 트리 자료구조로 이진 트리를 확장해 하나의 노드가 가질 수 있는 자식 노드의 최대 숫자가 2보다 큰 트리 구조
- 노드에는 2개 이상의 데이터가 들어갈 수 있으며 항상 정렬된 상태로 저장된다
- 이진트리와 달리 하나의 노드에 많은 수의 정보를 가질 수 있음 (M차 비-트리)
- 노드는 최대 M개의 자식 노드를 가질 수 있음
- 특정 노드의 데이터가 K개라면 자식 노드의 개수는 K+1개여야 함

<aside>
📢 비트리란 트리 자료구조 중 하나로 이진 트리를 확장해 하나의 노드가 가질 수 있는 자식 노드의 최대 숫자가 2보다 큰 트리 구조입니다. 노드에는 2개 이상의 데이터가 들어갈 수 있으며 항상 정렬된 상태로 저장됩니다. M차 비-트리는 최대 M개의 자식 노드를 가질 수 있으며 특정 노드의 데이터가 K개라면 자식 노드의 개수는 K+1개여야 합니다.

</aside>

### 트라이(Trie) 자료구조에 대해 설명해주세요. (송채은)

- 트라이
    - 문자열을 저장하고 효율적으로 탐색하기 위한 트리 형태의 자료구조
    - 자동완성 기능, 사전 검색 등 문자열을 탐색하는 데 특화된 자료구조
    - 시간복잡도 : O(MlogN), M: 문자열 길이
- 장점
    - 문자열 검색이 빠르다
- 단점
    - 각 노드에서 자식들에 대한 포인터들을 배열로 모두 저장하고 있어 메모리를 많이 차지함

<aside>
📢 트라이 자료구조란 문자열을 저장하고 효율적으로 탐색하기 위한 트리 형태의 자료구조입니다. 각 노드에서 자식들에 대한 포인터들을 배열로 저장하고 있어 메모리를 많이 차지하지만 문자열 검색이 빠르다는 장점을 가지고 있습니다. 트라이의 노드는 자식 노드를 가리키는 포인터와 문자열의 끝임을 알려주는 boolean변수로 이루어져있습니다. 다음 글자에 해당하는 노드가 연결되어 있는지, 문자열의 끝인지를 판별하며 문자열을 찾을 수 있습니다.

</aside>

참고

[https://velog.io/@nana-moon/알고리즘-빅오-표기법big-O-notation이란](https://velog.io/@nana-moon/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B9%85%EC%98%A4-%ED%91%9C%EA%B8%B0%EB%B2%95big-O-notation%EC%9D%B4%EB%9E%80)