# Data Structure

: 데이터를 원하는 규칙, 목적에 맞게 저장하기 위한 구조

</br>

## 선형 자료 구조

> ### Stack
>
> - 마지막에 들어온 데이터를 가장 먼저 내보내는 후입선출(LIFO, Last In First Out)의 자료구조
>
> - 장점
>
>   - 마지막 원소를 가르키는 top을 통해 접근하기 때문에 접근, 삽입, 삭제가 빠름
>
> - 단점
>
>   - top 위치 외의 데이터에 접근할 수 없음
>
> - 시간복잡도
>
>   - push / pop : **O(1)**
>
> - 활용 예시
>
>   - 웹 브라우저 방문기록(뒤로가기)
>
>   - 깊이우선탐색(DFS)
>
>     ```text
>     - 깊이우선탐색
>     	: 왼쪽부터 가장 깊은 레벨까지 먼저 탐색한 후 다음 순서를 탐색하는 방식
>     	: 주로 Stack을 사용해 구현
>     ```
>
>     

</br>

> ### Queue
>
> - 처음에 들어온 데이터를 가장 먼저 내보내는 선입선출(FIFO, First In First Out)의 자료구조
>
> - 장점
>
>   - 첫 원소를 가리키는 front와 마지막 원소를 가리키는 rear를 통해 접근하기 때문에 접근, 삽입, 삭제가 빠름
>
> - 단점
>
>   - 중간에 위치한 데이터에 접근할 수 없음
>
> - 시간복잡도
>
>   - enqueue / dequeue : **O(1)**
>
> - 구현 방법
>
>   - 데이터를 넣을 때마다 rear 포인터를, 뺄 때마다 front 포인터를 갱신
>   - front == rear 일 때 empty 판단 가능
>   - **Array-Base**
>     - 데이터의 삽입, 삭제 모두 O(1) 시간복잡도를 가짐
>     - 전반적인 performance가 더 좋지만, resize가 필요한 최악의 경우에는 느릴 수 있음
>   - **List-Base**
>     - 데이터의 삽입, 삭제 모두 O(1) 시간복잡도를 가짐
>     - 데이터를 삽입할 때마다 메모리를 할당해야하기 때문에 전반적인 runtime이 느릴 수 있음
>
> - 활용 예시
>
>   - 프린터 목록
>
>   - 프로세스 관리
>
>   - 너비우선탐색(BFS)
>
>     ```text
>     - 너비우선탐색
>     	: 위에서 아래방향으로 탐색하는 방식
>     	: 두 노드 사이 최단 경로를 찾을 때 사용
>     	: 주로 Queue를 사용하여 구현
>     ```
>
>     
>
> #### Circular Queue (원형 큐)
>
> - 선형 큐의 경우, 삽입과 삭제를 반복하면 한 번 데이터를 삽입하거나 삭제한 위치를 재사용하지 않는 문제가 발생함. 이 문제를 해결하기 위해 **front와 rear가 연결된 원형 구조**를 갖는 큐
>
> 
>
> #### Priority Queue (우선순위 큐)
>
> - 데이터가 삽입된 순서에 상관없이 우선순위가 높은 데이터를 먼저 내보내는 자료구조
> - 시간복잡도
>   - push / pop : **O(logN)**
>   - 정렬 : **O(NlogN)**
> - 구현 방법
>   1. Array와 LinkedList로 구현할 경우, enqueue 는 O(1), dequeue 는 O(N)의 시간복잡도를 가짐
>   2. Heap으로 구현할 경우, 그 자체로 우선순위 큐의 역할을 할 수 있고, enqueue와 dequeue 모두 O(logN)의 시간복잡도를 가짐
>
> 
>
> #### Stack 두 개로 Queue를 구현하는 방법
>
> : Queue의 **enqueue()를 구현할 때 첫 번째 Stack**(이하 instack)을 사용하고 **dequeue()를 구현할 때 두 번째 Stack**(이하 outstack)을 사용함
>
> - 방법
>
>   1.  enqueue() : instack에 push() 하여 데이터를 저장함
>
>   2.  dequeue()
>
>      : 만약 outstack이 비어 있다면 instack.pop() 하고 outstack.push()를 하여 instack에서 outstack으로 모든 데이터를 옮김
>
>      : outstack.pop() 하면 가장 먼저 삽입됐던 데이터가 가장 먼저 나옴
>
> - 시간복잡도
>
>   1.  enqueue() : instack.push() 를 한 번만 하면 되기 때문에 시간복잡도 **O(1)**
>
>   2.  dequeue() : outstack이 비어 있는 경우가 최악의 경우, 이 때 instack에 있는 N개의 데이터를 instack.pop() 한 뒤 outstack.push()를 해야하으로 총 2N번의 operation 실행. 따라서 시간복잡도 **O(N)**
>
> 
>
> #### Queue 두 개로 Stack을 구현하는 방법
>
> : Stack의 push()를 구현할 때 첫 번째 Queue(이하 q1), pop()을 구현할 때 두 번째 Queue(이하 q2)를 사용함
>
> - 방법
>
>   1.  push() : q1에 enqueue() 하여 데이터를 저장
>
>   2.  pop()
>
>      : q1에 저장된 데이터를 1개 제외하고 q2로 옮김
>
>      : q1에 남아 있는 1개의 데이터를 dequeue() 하여 가장 최근에 삽입한 데이터를 반환
>
>      : q1과 q2의 이름을 swap
>
> - 시간복잡도
>
>   1.  push() : q1.enqueue()를 한 번만 하면 되기 때문에 시간복잡도 **O(1)**
>
>   2.  pop() : q1에 저장되어 있는 N-1개의 원소를 q2로 옮겨야 하기 때문에 시간복잡도 **O(N)**

</br>

> ### Array
>
> - 연관된 데이터를 연속된 메모리에 미리 할당된 크기만큼 저장하는 자료구조
>
> - 특징
>
>   - **고정된 저장 공간**
>   - **순차적 데이터 저장**
>
> - 장점
>
>   - 메모리 상에 연속적으로 저장되기 때문에 인덱스로 빠른 접근이 가능
>   - 빈번한 조회가 필요한 경우 유리
>   - 데이터 개수를 알고 있고 메모리를 적게 쓰는 것이 중요한 상황에 유리
>
> - 단점
>
>   - 배열 선언 시, 크기를 미리 정해두어야하기 때문에 크기가 고정되고 메모리 낭비가 있을 수 있음
>
> - 시간 복잡도
>
>   : base-address와 offset을 활용한 연산으로 특정 인덱스의 주소를 바로 계산할 수 있음
>
>   : base-address는 배열의 시작 주소, offset은 (자료구조의 크기 * index)로 계산함
>
>   - 삽입 / 삭제 : 배열 끝에 삽입, 삭제 시 **O(1)**, 중간에 삽입 시 삽입 이후 데이터를 옮겨야하므로 **O(N)**의 시간복잡도를 가짐
>   - 접근 : **O(1)**
>   - 탐색 : 인덱스를 안다면 **O(1)**, 모른다면 **O(N)**
>
> 
>
> #### Dynamic Array
>
> - Array를 선언한 후 resize를 통해 유동적으로 size를 조절해 데이터를 저장하는 자료구조
>
> - Array의 고정된 저장 공간의 한계점을 보완할 수 있음
>
> - resize 방법
>
>   : 사이즈를 늘린 Array를 선언하고 그 곳으로 모든 데이터를 옮김
>
> - 시간복잡도
>
>   : append 연산은 O(1)의 시간복잡도를 갖지만 resize가 필요한 경우 데이터를 옮기기 때문에 O(N)의 시간복잡도를 가짐. 하지만 이는 가끔 일어나는 일이기 때문에 평균적으로 O(1)의 시간복잡도를 가짐
>
>   → Amortized O(1)

</br>

> ### List
>
> - 데이터를 나란히 저장하고, 중복된 데이터의 저장을 허용하는 자료구조
> - 순서가 있고, 중복을 허용한다는 점에서 Set과 구별되고, 일렬로 나열되어 처음과 끝이 하나씩 있다는 점에서 Graph와 구별됨
>
> 
>
> #### ArrayList
>
> - List를 Array로 구현한 자료구조
> - 장점
>   - 인덱스를 기준으로 탐색하기 때문에 한 번에 참조가 가능
>   - 배열을 선언할 때 정해진 크기만큼 연속된 메모리 주소를 할당 받기 때문에, 임의의 인덱스로 Random Access가 가능
> - 단점
>   - 연속된 메모리 주소를 할당해야하므로 배열의 길이가 초기에 결정되어야 하고 변경이 불가능함
>   - 삭제의 과정에서 데이터의 이동(복사)가 빈번히 일어남
>
> 
>
> #### LinkedList
>
> - 노드라는 구조체로 이루어져 있으며, 각 노드는 데이터와 다음 노드의 주소를 저장함. 물리적으로는 비연속적이지만 논리적으로는 연속성을 갖는 자료구조
> - 메모리 상에서 불연속적으로 데이터가 저장됨
> - 노드의 다음 노드의 주소 값을 통해 불연속적인 데이터를 연결함으로써 논리적 연속성을 보장
> - 장점
>   - 삽입, 삭제가 용이함
>   - 데이터가 추가되는 시점에서 메모리를 할당하기 때문에 효율적인 메모리 사용 가능
>   - 데이터 크기가 정해져 있지 않은 경우 유리
>   - O(1)로 빈번한 삽입과 삭제를 해야하는 경우 유리
>   - 조회 작업이 적은 경우 유리
> - 단점
>   - 인덱스 접근이 불가능하기 때문에 탐색 속도가 느림
> - 시간복잡도
>   - 삽입 / 삭제 : O(1), 만약 삽입하거나 삭제할 노드를 모른다면 탐색을 거쳐야 하기 때문에 O(N) 소요
>   - 접근 / 탐색 : O(N)
>
> 
>
> #### Array와 ArrayList의 차이 
>
> - Array는 메모리 할당 받는 크기가 고정적이고, ArrayList는 가변적임
> - Array는 초기화 시 메모리에 할당되어 ArrayList 보다 속도가 빠르고, ArrayList는 데이터 추가 및 삭제 시 메모리를 재할당하기 때문에 Array 보다 속도가 느림
>
> 
>
> #### Array와 LinkedList의 차이
>
> - **메모리에 저장되는 방식**과 이에 따른 **operation의 연산 속도**에서 가장 큰 차이가 있음
>
>   → Array는 메모리 상에서 연속적으로 데이터를 저장하는 자료구조, LinkedList는 메모리 상에서는 연속적이지 않지만 각 노드가 다음 노드의 주소값을 저장해놓음으로써 논리적 연속성을 유지
>
>   → 데이터 조회 시, Array의 경우 O(1), LinkedList의 경우 O(N)의 시간복잡도를 가짐
>
>   → 데이터 삽입 / 삭제 시, Array의 경우 O(N), LinkedList의 경우 O(1) 시간 복잡도를 가짐
>
>   → 데이터의 크기를 알고와 빈번한 조회가 필요한 경우 Array 사용이 유리
>
>   → 데이터 크기가 불확실하고 빈번한 삽입, 삭제가 필요한 경우 LinkedList 사용이 유리
>
> - **메모리 할당 시기**가 다름
>
>   → Array는 컴파일 단계에서 스택 영역에 메모리를 할당 받음
>
>   → LinkedList는 런타임 단계에서 새로운 노드를 추가할 때마다 힙 영역에 메모리를 할당 받음

</br>

## 비선형 자료 구조

> ### Graph
>
> - 간선과 정점의 집합으로 구성된 자료구조
> - 사이클 형성 가능
> - 무방향, 방향 그래프 모두 가능
> - 간선에 가중치를 부여할 수 있음
>
> - Tree보다 포괄적인 개념
> - 장점
>   - 복잡한 관계를 표현하는 데 효과정
> - 단점
>   - 메모리 사용량이 큼
>   - 알고리즘의 시간 복잡도가 높을 수 있음
> - 활용 예시
>   - 도로 경로 탐색
>   - 지하철 노선도

</br>

> ### Tree
>
> - 노드와 간선으로 이루어진 자료구조로, 무방향이면서 사이클이 없는 그래프
> - 계층적 데이터를 나타내는 노드들의 집합
> - 루트 노드를 제외한 모든 노드는 단 하나의 부모 노드를 가짐
>
> 
>
> #### 이진 트리 (Binary Tree)
>
> - 모든 노드의 자식 노드의 개수가 2 이하인 트리
> - 순회 방식
>   - 전위 : 루트 → 왼쪽 자식 → 오른쪽 자식
>   - 중위 : 왼쪽 자식 → 루트 → 오른쪽 자식
>   - 후위 : 왼쪽 자식 → 오른쪽 자식 → 루트
>
> 
>
> #### 이진 탐색 트리 (BST)
>
> - 이진 탐색과 LinkedList를 결합한 자료구조
>
> - 정렬된 트리로 노드의 왼쪽 값은 항상 작은 값을, 오른쪽 값은 항상 큰 값을 가진 노드들로 이루어져 있는 자료구조, 정렬된 이진 트리
> - 각 노드의 키가 중복되지 않음
> - 장점
>   - 이진 탐색의 효율적인 탐색 능력을 유지하면서, 빈번한 자료 삽입과 삭제가 가능
> - 시간복잡도
>   - 탐색, 삽입, 삭제 : 평균 O(logN), 최악의 경우(한쪽으로 치우친 트리인 경우) O(N)
>
> 
>
> #### 자가 균형 이진 탐색 트리 (Self-Balancing BST)
>
> - 트리가 편향된 경우 발생할 수 있는 O(N) 연산을 개선하기 위한 자료구조
> - 이진 트리의 균형을 유지해 높이를 가능한 낮게 유지하는 트리
> - 종류
>   - **AVL 트리**
>     - 트리에 노드를 삽입, 삭제할 때마다 자가 균형 조정 메서드를 호출하여 트리의 균형을 유지
>     - 자가 균형 메서드는 왼쪽 자식과 오른쪽 자식의 높이 차이가 1보다 커지면 회전을 통해 트리의 균형을 유지
>   - **Red-Black 트리**
>     - 각 노드를 red와 black으로 구분하여, 트리에 노드를 삽입, 삭제할 때 특정한 규칙을 지키도록 조정하여 트리의 균형을 유지
>     - 노드의 자식 노드가 없을 경우 자식을 가리키는 포인터는 NIL 값을 저장하고 NIL을 리프 노드로 간주
>     - 루트 노드와 말단 노드는 모두 black
>     - red의 자식은 모두 black
>     - AVL 보다 느슨하게 균형을 유지하기 때문에 삽입과 삭제가 빠름
> - 시간복잡도
>   - 탐색, 삽입, 저장 : **O(logN)**
>
> 
>
> #### 최소 신장 트리 (MST)
>
> - 최소한의 비용으로 모든 정점을 연결한 것
> - 조건
>   - 최소한의 간선으로 모든 정점이 연결될 것
>   - 모든 신장 트리 중 가중치의 값이 최소일 것
>   - 사이클을 형성하지 않을 것
> - 구현 알고리즘
>   - Prim
>   - Kruskal
>
> 
>
> #### B-Tree
>
> - 이진 트리를 확장해 모든 리프 노드들이 같은 높이를 갖도록 하는 트리
> - 노드는 정렬된 N개의 Key를 가질 수 있고, 그 경우 자식노드는 N+1개가 됨 (이때 키는 중복되지 않음)
> - 탐색, 삽입, 삭제 시에도 균형이 유지되도록 구조가 조정됨
> - 시간복잡도
>   - 탐색, 삽입, 삭제 : O(logN)
>
> 
>
> #### B+Tree
>
> - B-Tree의 변형
> - 내부 노드에는 Key만 저장하고 실제 데이터는 리프 노드에 저장하여 내부 노드 공간 효율성을 높인 트리
> - 리프 노드는 이중 LinkedList로 연결되어있어 검색에 용이
>
> 
>
> #### Trie
>
> - 문자열을 저장하고 효율적으로 탐색하기 위한 트리 형태의 자료구조
>
> - 루트 노드에서부터 각 문자 하나씩 자식노드에 저장하는 방식
>
> - 장점
>
>   - 문자열 탐색 속도가 빠름
>
>     → 이진 검색 트리에서는 탐색에 O(logN) 이 걸리고 문자열을 비교하는 시간이 추가로 들어 O(MlogN) 시간이 걸리는데 반해, Trie는 저장된 문자열 개수에 상관없이 O(M)의 시간복잡도를 가짐
>
> - 단점
>
>   - 공간 복잡도가 높음
>
> - 시간복잡도
>
>   - 길이가 M인 문자열 탐색 : **O(M)**

</br>

> ### Heap
>
> - 완전 이진 트리를 기본으로 하여, 여러 개의 값 중 최대 값이나 최솟값을 빠르게 찾아내기 위해 사용
> - 우선순위 큐를 구현하는 데 사용
> - 최대 힙의 경우, 루트 노드가 가장 큰 값을 가짐
> - 최소 힙의 경우, 루트 노드가 가장 작은 값짐
> - 빠른 삽입과 삭제 가능
> - 시간복잡도
>   - 삽입 : 새로운 값을 마지막 노드에 넣고 swap하면서 정렬하기 때문에 **O(logN)**
>   - 삭제 : 루트 노드를 pop한 뒤 마지막 노드를 루트 노드 위치에 넣고 swap하면서 정렬하기 때문에 **O(logN)**
>   - 최댓값, 최솟값 탐색 : **O(1)**
>
> 
>
> #### Heap을 Array로 구현한 이유
>
> - Heap은 새로운 노드를 마지막 위치에 추가한 뒤 정렬하는데, 이 때 Array 기반으로 구현하면 이 과정이 수월하기 때문
> - 완전이진트리 기반이므로 배열의 인덱스로 부모-자식 인덱스를 쉽게 찾을 수 있기 때문

</br>

## 그 외 구조

> ### Map
>
> - Key-Value 쌍으로 이루어진 자료구조
> - Key 값은 고유함
> - 장점
>   - Key를 기반으로 값에 접근하므로 탐색 및 삽입이 빠름
> - 단점
>   - 메모리 사용량이 증가할 수 잇음

</br>

> ### Set
>
> - 고유한 요소만을 포함하는 자료구조
> - 합집합, 교집합, 차집합과 같은 집합 연산 지원
> - 순서가 없음, 요소를 추가한 순서대로 저장되지 않음
>
> - 장점
>   - 중복을 허용하지 않으므로 고유성 보장
> - 단점
>   - 요소의 순서가 없기 때문에 순차적 연산이 필요한 경우에는 적합하지 않음
>
> 
>
> #### List와 Set의 차이
>
> - 중복 허용 여부
>   - List : 중복 허용
>   - Set : 중복 허용하지 않음, 중복 제거

</br>

> ### Hash Table
>
> - 키에 대한 해시 값을 사용해 값을 저장하고 조회하며 key-value 쌍의 개수에 따라 동적으로 크기가 증가하는 자료구조
>
> - 빈 slot이 적으면 충돌이 잦아져 성능 손실이 발생하므로 일정 임계점 이상 데이터가 채워지면 해시 테이블 resize(동적 확장) 필요
>
> - 장점
>
>   - 적은 리소스로 많은 데이터를 효율적으로 관리 가능
>   - 인덱스를 사용해서 빠른 탐색 가능
>   - 키와 해시값이 연관성이 낮아 보안성이 높음
>   - 중복 제거에 유용
>
> - 단점
>
>   - 해시 충돌 발생 가능성이 있으며 최악의 경우 O(N)의 시간복잡도를 가짐
>
>   - 데이터가 저장되기 전에 미리 저장공간(slot, bucket)을 확보해야하므로
>
>     → 공간복잡도가 큼, 낮은 공간 효율성
>
>   - 높은 해시 함수 의존도
>
>   - 순서를 보장하지 않으므로 순서나 관계가 필요할 때는 적합하지 않음
>
> - 시간복잡도
>
>   - 저장, 삭제, 탐색 : O(1), 충돌로 인한 최악의 경우 O(N)
>
>     → 해시 함수의 시간복잡도가 O(1)임을 가정한다면 해시 함수를 적용해 Key 값을 구해 배열의 인덱스 연산으로 바로 조회 가능
>
>     ```text
>     - 해시 함수
>     	: 임의 데이터를 고정 길이의 데이터로 매핑하는 함수
>     	: 해시테이블에서는 키에 대한 해시 값을 인덱스로 사용하는데, 이때 고르게 분포될 수 있는 해시 함수를 선택해야 효율적인 테이블 사용이 가능함
>     	: 연산속도가 빠르고 해시값이 최대한 고르게 분포되는 함수가 좋은 해시 함수 조건
>     ```
>
> 
>
> #### Collision (충돌)
>
> - 충돌을 처리하기 위해 `Chaining` 기법과  `Open Addressing` 방법을 사용
>
>   1. **Chaining**
>
>      : LinkedList나 Tree를 활용해 충돌이 발생하면 노드를 추가해 데이터를 저장하는 방법
>
>      - 장점
>        - 테이블 확장을 늦추고 구현이 간단함
>      - 단점
>        - 추가 메모리를 사용해야함
>        - 조회 성능이 O(1)보다 안좋아짐
>        - 최악의 경우, N개의 모든 key가 동일한 해시값을 갖게 되면 길이가 N인 LinkedList가 생성되고 검색, 삭제 시 O(N) 의 시간복잡도를 갖게 됨
>
>   2. **Open Addressing**
>
>      : 미리 정한 규칙에 따라 비어있는 해시 테이블에 데이터를 저장하는 방법
>
>      : 빈 Slot을 찾는 방법에 따라 Linear Probing, Quadratic Probing, Double Hashing으로 구분
>
>      - 장점
>        - 추가 메모리를 사용하지 않으므로 LinkedList, Tree 를 활용하는 chaining 방식에 비해 적은 메모리 사용
>      - 단점
>        - 충돌 횟수가 많아지면 특정 영역에 데이터가 집중적으로 몰리는 클러스터링 현상 발생
>        - 조회, 검색, 삭제 시 인덱스의 키 값이 찾고자하는 값이 아니라면 추가적인 탐색 필요
>
>      - Double Hashing
>
>        : 비어있는 Slot을 찾기 위해 새로운 해시 함수를 사용해 탐사 이동폭을 더 랜덤하게 만들어 클러스터링 문제를 줄임
>
> 
>
> #### Hash Map과 Hash Table의 차이
>
> - 두 가지 자료구조 모두 해시함수를 사용하여 데이터를 저장하고 검색하는 방식은 동일
>
> - **동기화 지원 여부**와 **null 값 허용 여부**에서 차이가 있음
>
>   - Hash Map
>
>     - 동기화 되지 않아 Thread-safe 하지 않음
>
>       → Multi Thread 에서 안전하지 않을 수 있지만 단일 Thread 환경에서는 빠르게 동작
>
>     - null 값 허용
>
>     - Java에서 `HashMap` 클래스 사용
>
>   - Hash Table
>
>     - 동기화되므로  Thread-safe 함
>
>       →  Multi Thread 환경에서 안전하지만, 동기화 오버헤드로 인해 단일 스레드 환경에서는 성능이 저하될 수 있음
>
>     - null 값 허용하지 않음
>
>     - Java에서 `HashTable` 클래스 사용

</br>

## 정렬

> ### Bubble Sort
>
> - 서로 인접한 두 원소의 대소를 비교하여 자리를 교환하는 정렬 알고리즘
> - 장점
>   - 구현이 쉬움
>   - 정렬하고자 하는 배열 안에서 교환하므로 다른 메모리 공간을 필요로 하지 않음
> - 단점
>   - 시간복잡도가 최악, 최선, 평균 모두 O(n^2)이므로 비효율적
>   - 빈번한 swap 발생
> - 시간복잡도 : **O(n^2)**

</br>

> ### Quick Sort
>
> - pivot을 활용하여 pivot보다 큰 값과 작은 값을 분할하는 정렬 알고리즘
>
> - 장점
>
>   - 데이터의 불필요한 이동을 줄임
>   - 가장 빠른 정렬 속도
>   - 정렬하고자 하는 배열 안에서 교환하므로 다른 메모리 공간을 필요로 하지 않음
>
> - 단점
>
>   - 정렬된 배열에 대해서는 오히려 수행시간이 길어짐
>
> - 시간복잡도
>
>   - 최선, 평균 : O(NlogN)
>
>   - 최악 : O(N^2)
>
>     → pivot이 최솟값이나 최댓값으로 지정되어 분할되지 않았을 경우
>
>     → 배열이 오름차순/내림차순 정렬된 경우

</br>

> ### Java의 정렬 알고리즘
>
> - Arrays.sort
>   - 배열을 정렬하는 데 사용
>   - DualPivotQuickSort 사용
>     - pivot 2개로 구간을 3개로 나우어 진행
>     - 평균적으로 Quick Sort 보다 나은 성능
>     - 시간복잡도
>       - 평균 : O(NlogN)
>       - 최악 : O(N^2)
>
> 
>
> - Collections.sort
>   - List 형태의 collection을 정렬하는데 사용
>   - TimSort 사용
>     - 삽입 정렬과 합병 정렬을 결합하여 만든 정렬 알고리즘
>     - 시간복잡도
>       - 평균, 최악 : O(NlogN)
>
> 
>
> #### Arrays와 Collections에서 사용하는 알고리즘이 다른 이유
>
> - CPU 캐싱 전략에 영향을 미치는 **참조 지역성의 원리** 때문
> - 참조 지역성의 원리 : 동일한 값 또는 해당 값 근처에 있는 스토리지 위치가 자주 액세스 되는 특성
> - Array의 경우 메모리적으로 연속적인 주소를 갖지만 List의 경우 연속적인 주소값을 가지지 않음. 이러한 특성이 참조 지역성의 원리에 영향을 미치기 때문에 다른 알고리즘을 사용하여 높은 성능을 이끌어냄

</br>

